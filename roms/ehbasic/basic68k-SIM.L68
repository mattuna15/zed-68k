00A00040 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 15/07/2020 13:09:36

00000000                             1  *************************************************************************************
00000000                             2  *                                           *
00000000                             3  *   Enhanced BASIC for the Motorola MC680xx                     *
00000000                             4  *                                           *
00000000                             5  *   This version is for the TS2 single board computer.                  *
00000000                             6  *   Jeff Tranter (tranter@pobox.com)                        *
00000000                             7  *                                           *
00000000                             8  *************************************************************************************
00000000                             9  *                                           *
00000000                            10  *   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
00000000                            11  *   for personal use only. All commercial rights are reserved.          *
00000000                            12  *                                           *
00000000                            13  *   More 68000 and other projects can be found on my website at ..          *
00000000                            14  *                                           *
00000000                            15  *    http://mycorner.no-ip.org/index.html                       *
00000000                            16  *                                           *
00000000                            17  *   mail : leeedavison@googlemail.com                       *
00000000                            18  *                                           *
00000000                            19  *************************************************************************************
00000000                            20  
00000000                            21  * Ver 3.52
00000000                            22  
00000000                            23  * Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            24  * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            25  * Ver 3.50 unary minus in concatenate generates a type mismatch error
00000000                            26  * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            27  * Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            28  * Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            29  * Ver 3.46 updates function and function variable handling
00000000                            30  
00000000                            31  *************************************************************************************
00000000                            32  *
00000000                            33  * Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            34  * option of not returning an error for a non existant variable. If this is the
00000000                            35  * behaviour you want just change novar to some non zero value
00000000                            36  
00000000  =00000000                 37  novar       EQU 0               * non existant variables cause errors
00000000                            38  
00000000                            39  
00000000                            40  *************************************************************************************
00000000                            41  
00000000                            42  * Ver 3.44 adds overflow indication to the USING$() function
00000000                            43  * Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            44  * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            45  * Ver 3.41 removes undocumented features of the USING$() function
00000000                            46  * Ver 3.40 adds the USING$() function
00000000                            47  * Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            48  * Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            49  
00000000                            50  *************************************************************************************
00000000                            51  *
00000000                            52  * Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            53  * response does not cause a program break. If this is the behaviour you want just
00000000                            54  * change nobrk to some non zero value.
00000000                            55  
00000000  =00000000                 56  nobrk       EQU 0               * null response to INPUT causes a break
00000000                            57  
00000000                            58  
00000000                            59  *************************************************************************************
00000000                            60  *
00000000                            61  * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                            62  * pointer in a3. this means that this could now be run as a task on a multitasking
00000000                            63  * system where memory resources may change.
00000000                            64  
00000000                            65  
00000000                            66  *************************************************************************************
00000000                            67  
00000000                            68  
00000000                            69      INCLUDE "basic68k.inc"
00000000                            70  
00000000                            71  
00000064                            72          ORG     100         * start of RAM
00000064                            73   
00000064                            74  ram_strt    ds.l    $300            * allow 1K for the stack, this should be plenty
00000C64                            75                          * for any BASIC program that doesn't do something
00000C64                            76                          * silly, it could even be much less.
00000C64                            77  ram_base
00000C64                            78  LAB_WARM    ds.w    1           * BASIC warm start entry point
00000C66                            79  Wrmjpv  ds.l    1           * BASIC warm start jump vector
00000C6A                            80  
00000C6A                            81  Usrjmp  ds.w    1           * USR function JMP address
00000C6C                            82  Usrjpv  ds.l    1           * USR function JMP vector
00000C70                            83  
00000C70                            84  
00000C70                            85  V_INPT  ds.w    1           * non halting scan input device entry point
00000C72                            86  V_INPTv ds.l    1           * non halting scan input device jump vector
00000C76                            87  
00000C76                            88  V_OUTP  ds.w    1           * send byte to output device entry point
00000C78                            89  V_OUTPv ds.l    1           * send byte to output device jump vector
00000C7C                            90  
00000C7C                            91  V_LOAD  ds.w    1           * load BASIC program entry point
00000C7E                            92  V_LOADv ds.l    1           * load BASIC program jump vector
00000C82                            93  
00000C82                            94  V_SAVE  ds.w    1           * save BASIC program entry point
00000C84                            95  V_SAVEv ds.l    1           * save BASIC program jump vector
00000C88                            96  
00000C88                            97  V_CTLC  ds.w    1           * save CTRL-C check entry point
00000C8A                            98  V_CTLCv ds.l    1           * save CTRL-C check jump vector
00000C8E                            99  
00000C8E                           100  Itemp       ds.l    1           * temporary integer (for GOTO etc)
00000C92                           101  
00000C92                           102  Smeml       ds.l    1           * start of memory       (start of program)
00000C96                           103  
00000C96                           104  
00000C96                           105  Sfncl       ds.l    1           * start of functions    (end of Program)
00000C9A                           106  
00000C9A                           107  
00000C9A                           108  Svarl       ds.l    1           * start of variables    (end of functions)
00000C9E                           109  
00000C9E                           110  
00000C9E                           111  Sstrl       ds.l    1           * start of strings  (end of variables)
00000CA2                           112  
00000CA2                           113  
00000CA2                           114  Sarryl  ds.l    1           * start of arrays       (end of strings)
00000CA6                           115  
00000CA6                           116  
00000CA6                           117  Earryl  ds.l    1           * end of arrays     (start of free mem)
00000CAA                           118  Sstorl  ds.l    1           * string storage        (moving down)
00000CAE                           119  Ememl       ds.l    1           * end of memory     (upper bound of RAM)
00000CB2                           120  Sutill  ds.l    1           * string utility ptr
00000CB6                           121  Clinel  ds.l    1           * current line      (Basic line number)
00000CBA                           122  Blinel  ds.l    1           * break line        (Basic line number)
00000CBE                           123  
00000CBE                           124  Cpntrl  ds.l    1           * continue pointer
00000CC2                           125  Dlinel  ds.l    1           * current DATA line
00000CC6                           126  Dptrl       ds.l    1           * DATA pointer
00000CCA                           127  Rdptrl  ds.l    1           * read pointer
00000CCE                           128  Varname ds.l    1           * current var name
00000CD2                           129  Cvaral  ds.l    1           * current var address
00000CD6                           130  Lvarpl  ds.l    1           * variable pointer for LET and FOR/NEXT
00000CDA                           131  
00000CDA                           132  des_sk_e    ds.l    6           * descriptor stack end address
00000CF2                           133  des_sk                  * descriptor stack start address
00000CF2                           134                          * use a4 for the descriptor pointer
00000CF2                           135          ds.w    1           
00000CF4                           136  Ibuffs  ds.l    $40         * start of input buffer
00000DF4                           137  Ibuffe
00000DF4                           138                          * end of input buffer
00000DF4                           139  
00000DF4                           140  FAC1_m  ds.l    1           * FAC1 mantissa1
00000DF8                           141  FAC1_e  ds.w    1           * FAC1 exponent
00000DFA  =00000DF9                142  FAC1_s  EQU FAC1_e+1        * FAC1 sign (b7)
00000DFA                           143          ds.w    1           
00000DFC                           144  
00000DFC                           145  FAC2_m  ds.l    1           * FAC2 mantissa1
00000E00                           146  FAC2_e  ds.l    1           * FAC2 exponent
00000E04  =00000E01                147  FAC2_s  EQU FAC2_e+1        * FAC2 sign (b7)
00000E04  =00000E02                148  FAC_sc  EQU FAC2_e+2        * FAC sign comparison, Acc#1 vs #2
00000E04  =00000E03                149  flag        EQU FAC2_e+3        * flag byte for divide routine
00000E04                           150  
00000E04                           151  PRNlword    ds.l    1           * PRNG seed long word
00000E08                           152  
00000E08                           153  ut1_pl  ds.l    1           * utility pointer 1
00000E0C                           154  
00000E0C                           155  Asptl       ds.l    1           * array size/pointer
00000E10                           156  Astrtl  ds.l    1           * array start pointer
00000E14                           157  
00000E14  =00000E10                158  numexp  EQU Astrtl      * string to float number exponent count
00000E14  =00000E11                159  expcnt  EQU Astrtl+1        * string to float exponent count
00000E14                           160  
00000E14  =00000E13                161  expneg  EQU Astrtl+3        * string to float eval exponent -ve flag
00000E14                           162  
00000E14                           163  func_l  ds.l    1           * function pointer
00000E18                           164  
00000E18                           165  
00000E18                           166                          * these two need to be a word aligned pair !
00000E18                           167  Defdim  ds.w    1           * default DIM flag
00000E1A  =00000E18                168  cosout  EQU Defdim      * flag which CORDIC output (re-use byte)
00000E1A  =00000E19                169  Dtypef  EQU Defdim+1        * data type flag, $80=string, $40=integer, $00=float
00000E1A                           170  
00000E1A                           171  
00000E1A                           172  Binss       ds.l    4           * number to bin string start (32 chrs)
00000E2A                           173  
00000E2A                           174  Decss       ds.l    1           * number to decimal string start (16 chrs)
00000E2E                           175          ds.w    1           *
00000E30                           176  Usdss       ds.w    1           * unsigned decimal string start (10 chrs)
00000E32                           177  
00000E32                           178  Hexss       ds.l    2           * number to hex string start (8 chrs)
00000E3A                           179  
00000E3A                           180  BHsend  ds.w    1           * bin/decimal/hex string end
00000E3C                           181  
00000E3C                           182  
00000E3C                           183  prstk       ds.b    1           * stacked function index
00000E3D                           184  
00000E3D                           185  tpower  ds.b    1           * remember CORDIC power
00000E3E                           186  
00000E3E                           187  Asrch       ds.b    1           * scan-between-quotes flag, alt search character
00000E3F                           188  
00000E3F                           189  Dimcnt  ds.b    1           * # of dimensions
00000E40                           190  
00000E40                           191  Breakf  ds.b    1           * break flag, $00=END else=break
00000E41                           192  Oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
00000E42                           193  Gclctd  ds.b    1           * garbage collected flag
00000E43                           194  Sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00000E44                           195  Imode       ds.b    1           * input mode flag, $00=INPUT, $98=READ
00000E45                           196  
00000E45                           197  Cflag       ds.b    1           * comparison evaluation flag
00000E46                           198  
00000E46                           199  TabSiz  ds.b    1           * TAB step size
00000E47                           200  
00000E47                           201  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
00000E48                           202                          * bit 2 set if >
00000E48                           203                          * bit 1 set if =
00000E48                           204                          * bit 0 set if <
00000E48                           205  
00000E48                           206  Nullct  ds.b    1           * nulls output after each line
00000E49                           207  TPos        ds.b    1           * BASIC terminal position byte
00000E4A                           208  TWidth  ds.b    1           * BASIC terminal width byte
00000E4B                           209  Iclim       ds.b    1           * input column limit
00000E4C                           210  ccflag  ds.b    1           * CTRL-C check flag
00000E4D                           211  ccbyte  ds.b    1           * CTRL-C last received byte
00000E4E                           212  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
00000E4F                           213  
00000E4F                           214  
00000E4F                           215  file_byte   ds.b    1           * load/save data byte
00000E50                           216  file_id ds.l    1           * load/save file ID
00000E54                           217  
00000E54                           218  even                    * dummy even value and zero pad byte
00000E54                           219  
00000E54                           220  prg_strt
00000E54                           221  
00000E54  =00001000                222  ram_addr    EQU $01000      * RAM start address
00000E54  =00006000                223  ram_size    EQU $06000      * RAM size
00000E54                           224  
00000E54                           225  -------------------- end include --------------------
00000E54                           226                              * RAM offset definitions
00000E54                           227  
00000E54                           228  * Use this value to run out of ROM
00A00000                           229      ORG     $A00000         
00A00000                           230  * Use this value to run out of RAM
00A00000                           231  *   ORG     $000800         * past the vectors in a real system
00A00000                           232  
00A00000  =00F00009                233  ACIAC    EQU $F00009
00A00000  =00F0000B                234  ACIAD    EQU ACIAC+2
00A00000  =00000000                235  RDRF     EQU 0           ; ACIAC Receive Data Register Full
00A00000  =00000001                236  TDRE     EQU 1           ; ACIAC Transmit Data Register Empty
00A00000                           237  
00A00000                           238  
00A00000  6000 003E                239           BRA    code_start       * For convenience, so you can start from first address
00A00004                           240           
00A00004                           241   
00A00004                           242  
00A00004                           243  *************************************************************************************
00A00004                           244  *
00A00004                           245  * the following code is simulator specific, change to suit your system
00A00004                           246  
00A00004                           247  * output character to the console from register d0.b
00A00004                           248  
00A00004                           249  VEC_OUT
00A00004  48E7 C000                250      MOVEM.l d0-d1,-(sp)         * save d0, d1
00A00008  1200                     251      MOVE.b  d0,d1               * copy character
00A0000A  7006                     252      MOVEQ       #6,d0               * character out
00A0000C  4E4F                     253      TRAP        #15             * do I/O function
00A0000E  4CDF 0003                254      MOVEM.l (sp)+,d0-d1         * restore d0, d1
00A00012  4E75                     255      RTS
00A00014                           256  
00A00014                           257  
00A00014                           258  *************************************************************************************
00A00014                           259  *
00A00014                           260  * input a character from the console into register d0
00A00014                           261  * else return Cb=0 if there's no character available
00A00014                           262  
00A00014                           263  VEC_IN
00A00014  2F01                     264      MOVE.l  d1,-(sp)            * save d1
00A00016  7007                     265      MOVEQ       #7,d0               * get the status
00A00018  4E4F                     266      TRAP        #15             * do I/O function
00A0001A                           267  
00A0001A  1001                     268      MOVE.b  d1,d0               * copy the returned status
00A0001C  6606                     269      BNE.s       RETCHR          * if a character is waiting go get it
00A0001E                           270  
00A0001E  221F                     271      MOVE.l  (sp)+,d1            * else restore d1
00A00020  4A00                     272      TST.b       d0              * set the z flag
00A00022                           273  *   ANDI.b  #$FE,CCR            * clear the carry, flag we got no byte
00A00022                           274  *                           * done by the TST.b
00A00022  4E75                     275      RTS
00A00024                           276  
00A00024                           277  RETCHR
00A00024  7005                     278      MOVEQ       #5,d0               * get byte form the keyboard
00A00026  4E4F                     279      TRAP        #15             * do I/O function
00A00028                           280  
00A00028  1001                     281      MOVE.b  d1,d0               * copy the returned byte
00A0002A  221F                     282      MOVE.l  (sp)+,d1            * restore d1
00A0002C  4A00                     283      TST.b       d0              * set the z flag on the received byte
00A0002E  003C 0001                284      ORI.b       #1,CCR          * set the carry, flag we got a byte
00A00032  4E75                     285      RTS
00A00034                           286  
00A00034                           287  *************************************************************************************
00A00034                           288  *
00A00034                           289  * LOAD routine for the TS2 computer (not implemented)
00A00034                           290  
00A00034                           291  VEC_LD
00A00034  7E2E                     292      MOVEQ       #$2E,d7                 * error code $2E "Not implemented" error
00A00036  6000 0140                293      BRA     LAB_XERR            * do error #d7, then warm start
00A0003A                           294  
00A0003A                           295  *************************************************************************************
00A0003A                           296  *
00A0003A                           297  * SAVE routine for the TS2 computer (not implemented)
00A0003A                           298  
00A0003A                           299  VEC_SV
00A0003A  7E2E                     300      MOVEQ       #$2E,d7                 * error code $2E "Not implemented" error
00A0003C  6000 013A                301      BRA     LAB_XERR            * do error #d7, then warm start
00A00040                           302  
00A00040                           303  *************************************************************************************
00A00040                           304  *
00A00040                           305  * turn off simulator key echo
00A00040                           306  
00A00040                           307  code_start
00A00040  700C                     308           MOVEQ      #12,d0          * keyboard echo
00A00042  7200                     309           MOVEQ      #0,d1               * turn off echo
00A00044  4E4F                     310           TRAP       #15             * do I/O function
00A00046                           311           
00A00046                           312           
00A00046  41F9 00F00009            313          LEA.L   ACIAC,A0       * A0 points to console ACIA
00A0004C  10BC 0015                314          MOVE.B  #$15,(A0)       * Set up ACIA1 constants (no IRQ,
00A00050                           315                                  * RTS* low, 8 bit, no parity, 1 stop)
00A00050                           316  
00A00050                           317  * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
00A00050                           318  * in d0. these values are at the end of the .inc file
00A00050                           319  
00A00050  207C 00001000            320      MOVEA.l #ram_addr,a0        * tell BASIC where RAM starts
00A00056  203C 00006000            321      MOVE.l  #ram_size,d0        * tell BASIC how big RAM is
00A0005C                           322  
00A0005C                           323  * end of simulator specific code
00A0005C                           324  
00A0005C                           325  
00A0005C                           326  ****************************************************************************************
00A0005C                           327  ****************************************************************************************
00A0005C                           328  ****************************************************************************************
00A0005C                           329  ****************************************************************************************
00A0005C                           330  *
00A0005C                           331  * Register use :- (must improve this !!)
00A0005C                           332  *
00A0005C                           333  *   a6 -    temp Bpntr              * temporary BASIC execute pointer
00A0005C                           334  *   a5 -    Bpntr                   * BASIC execute (get byte) pointer
00A0005C                           335  *   a4 -    des_sk                      * descriptor stack pointer
00A0005C                           336  *   a3 -    ram_strt                * start of RAM. all RAM references are offsets
00A0005C                           337  *                           * from this value
00A0005C                           338  *
00A0005C                           339  
00A0005C                           340  *************************************************************************************
00A0005C                           341  *
00A0005C                           342  * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
00A0005C                           343  * in d0
00A0005C                           344  
00A0005C                           345  LAB_COLD
00A0005C  B0BC 00004000            346      CMP.l       #$4000,d0           * compare size with 16k
00A00062  6C08                     347      BGE.s       LAB_sizok           * branch if >= 16k
00A00064                           348  
00A00064  7005                     349      MOVEQ       #5,d0               * error 5 - not enough RAM
00A00066  1E3C 00E4                350          move.b          #228,D7                         * Go to TUTOR function
00A0006A  4E4E                     351          trap            #14                             * Call TRAP14 handler
00A0006C                           352  
00A0006C                           353  LAB_sizok
00A0006C  2648                     354      MOVEA.l a0,a3               * copy RAM base to a3
00A0006E  D1C0                     355      ADDA.l  d0,a0               * a0 is top of RAM
00A00070  2748 0CAE                356      MOVE.l  a0,Ememl(a3)        * set end of mem
00A00074  4FEB 0C64                357      LEA     ram_base(a3),sp     * set stack to RAM start + 1k  * set stack to RAM start + 1k
00A00078                           358  
00A00078  303C 4EF9                359      MOVE.w  #$4EF9,d0           * JMP opcode
00A0007C  204F                     360      MOVEA.l sp,a0               * point to start of vector table
00A0007E                           361  
00A0007E  30C0                     362      MOVE.w  d0,(a0)+            * LAB_WARM
00A00080  43FA FFDA                363      LEA     LAB_COLD(pc),a1     * initial warm start vector
00A00084  20C9                     364      MOVE.l  a1,(a0)+            * set vector
00A00086                           365  
00A00086  30C0                     366      MOVE.w  d0,(a0)+            * Usrjmp
00A00088  43FA 00DC                367      LEA     LAB_FCER(pc),a1     * initial user function vector
00A0008C                           368                              * "Function call" error
00A0008C  20C9                     369      MOVE.l  a1,(a0)+            * set vector
00A0008E                           370  
00A0008E  30C0                     371      MOVE.w  d0,(a0)+            * V_INPT JMP opcode
00A00090  43FA FF82                372      LEA     VEC_IN(pc),a1       * get byte from input device vector
00A00094  20C9                     373      MOVE.l  a1,(a0)+            * set vector
00A00096                           374  
00A00096  30C0                     375      MOVE.w  d0,(a0)+            * V_OUTP JMP opcode
00A00098  43FA FF6A                376      LEA     VEC_OUT(pc),a1      * send byte to output device vector
00A0009C  20C9                     377      MOVE.l  a1,(a0)+            * set vector
00A0009E                           378  
00A0009E  30C0                     379      MOVE.w  d0,(a0)+            * V_LOAD JMP opcode
00A000A0  43FA FF92                380      LEA     VEC_LD(pc),a1       * load BASIC program vector
00A000A4  20C9                     381      MOVE.l  a1,(a0)+            * set vector
00A000A6                           382  
00A000A6  30C0                     383      MOVE.w  d0,(a0)+            * V_SAVE JMP opcode
00A000A8  43FA FF90                384      LEA     VEC_SV(pc),a1       * save BASIC program vector
00A000AC  20C9                     385      MOVE.l  a1,(a0)+            * set vector
00A000AE                           386  
00A000AE  30C0                     387      MOVE.w  d0,(a0)+            * V_CTLC JMP opcode
00A000B0  43FA 261E                388      LEA     VEC_CC(pc),a1       * save CTRL-C check vector
00A000B4  20C9                     389      MOVE.l  a1,(a0)+            * set vector
00A000B6                           390  
00A000B6                           391  * set-up start values
00A000B6                           392  
00A000B6                           393  *##LAB_GMEM
00A000B6  7000                     394      MOVEQ       #$00,d0         * clear d0
00A000B8  1740 0E48                395      MOVE.b  d0,Nullct(a3)       * default NULL count
00A000BC  1740 0E49                396      MOVE.b  d0,TPos(a3)         * clear terminal position
00A000C0  1740 0E4C                397      MOVE.b  d0,ccflag(a3)       * allow CTRL-C check
00A000C4  3740 0E52                398      MOVE.w  d0,prg_strt-2(a3)       * clear start word
00A000C8  3740 0E3A                399      MOVE.w  d0,BHsend(a3)       * clear value to string end word
00A000CC                           400  
00A000CC  177C 0050 0E4A           401      MOVE.b  #$50,TWidth(a3)     * default terminal width byte for simulator
00A000D2  177C 000E 0E46           402      MOVE.b  #$0E,TabSiz(a3)     * save default tab size = 14
00A000D8                           403  
00A000D8  177C 0038 0E4B           404      MOVE.b  #$38,Iclim(a3)      * default limit for TAB = 14 for simulator
00A000DE                           405  
00A000DE  49EB 0CF2                406      LEA     des_sk(a3),a4       * set descriptor stack start
00A000E2                           407  
00A000E2  41EB 0E54                408      LEA     prg_strt(a3),a0     * get start of mem
00A000E6  2748 0C92                409      MOVE.l  a0,Smeml(a3)        * save start of mem
00A000EA                           410  
00A000EA  6100 0322                411      BSR     LAB_1463            * do "NEW" and "CLEAR"
00A000EE  6100 0898                412      BSR     LAB_CRLF            * print CR/LF
00A000F2  202B 0CAE                413      MOVE.l  Ememl(a3),d0        * get end of mem
00A000F6  90AB 0C92                414      SUB.l       Smeml(a3),d0        * subtract start of mem
00A000FA                           415  
00A000FA  6100 1BCC                416      BSR     LAB_295E            * print d0 as unsigned integer (bytes free)
00A000FE  41FA 33EE                417      LEA     LAB_SMSG(pc),a0     * point to start message
00A00102  6100 08E2                418      BSR     LAB_18C3            * print null terminated string from memory
00A00106                           419  
00A00106  41FA 29D2                420      LEA     LAB_RSED(pc),a0     * get pointer to value
00A0010A  6100 1A68                421      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00A0010E                           422  
00A0010E  41FA 0092                423      LEA     LAB_1274(pc),a0     * get warm start vector
00A00112  2748 0C66                424      MOVE.l  a0,Wrmjpv(a3)       * set warm start vector
00A00116  6100 1FD2                425      BSR     LAB_RND         * initialise
00A0011A  4EEB 0C64                426      JMP     LAB_WARM(a3)        * go do warm start
00A0011E                           427  
00A0011E                           428  
00A0011E                           429  *************************************************************************************
00A0011E                           430  *
00A0011E                           431  * do format error
00A0011E                           432  
00A0011E                           433  LAB_FOER
00A0011E  7E2C                     434      MOVEQ       #$2C,d7         * error code $2C "Format" error
00A00120  6056                     435      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00122                           436  
00A00122                           437  
00A00122                           438  *************************************************************************************
00A00122                           439  *
00A00122                           440  * do address error
00A00122                           441  
00A00122                           442  LAB_ADER
00A00122  7E2A                     443      MOVEQ       #$2A,d7         * error code $2A "Address" error
00A00124  6052                     444      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00126                           445  
00A00126                           446  
00A00126                           447  *************************************************************************************
00A00126                           448  *
00A00126                           449  * do wrong dimensions error
00A00126                           450  
00A00126                           451  LAB_WDER
00A00126  7E28                     452      MOVEQ       #$28,d7         * error code $28 "Wrong dimensions" error
00A00128  604E                     453      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0012A                           454  
00A0012A                           455  
00A0012A                           456  *************************************************************************************
00A0012A                           457  *
00A0012A                           458  * do undimensioned array error
00A0012A                           459  
00A0012A                           460  LAB_UDER
00A0012A  7E26                     461      MOVEQ       #$26,d7         * error code $26 "undimensioned array" error
00A0012C  604A                     462      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0012E                           463  
00A0012E                           464  
00A0012E                           465  *************************************************************************************
00A0012E                           466  *
00A0012E                           467  * do undefined variable error
00A0012E                           468  
00A0012E                           469  LAB_UVER
00A0012E                           470  
00A0012E                           471  * if you do want a non existant variable to return an error then leave the novar
00A0012E                           472  * value at the top of this file set to zero
00A0012E                           473  
00A0012E                 TRUE      474   ifeq   novar
00A0012E                           475  
00A0012E  7E24                     476      MOVEQ       #$24,d7         * error code $24 "undefined variable" error
00A00130  6046                     477      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00132                           478  
00A00132                           479   endc
00A00132                           480  
00A00132                           481  * if you want a non existant variable to return a null value then set the novar
00A00132                           482  * value at the top of this file to some non zero value
00A00132                           483  
00A00132                 FALSE     484   ifne   novar
00A00132                           485   endc
00A00132                           486  
00A00132                           487  
00A00132                           488  *************************************************************************************
00A00132                           489  *
00A00132                           490  * do loop without do error
00A00132                           491  
00A00132                           492  LAB_LDER
00A00132  7E22                     493      MOVEQ       #$22,d7         * error code $22 "LOOP without DO" error
00A00134  6042                     494      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00136                           495  
00A00136                           496  
00A00136                           497  *************************************************************************************
00A00136                           498  *
00A00136                           499  * do undefined function error
00A00136                           500  
00A00136                           501  LAB_UFER
00A00136  7E20                     502      MOVEQ       #$20,d7         * error code $20 "Undefined function" error
00A00138  603E                     503      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0013A                           504  
00A0013A                           505  
00A0013A                           506  *************************************************************************************
00A0013A                           507  *
00A0013A                           508  * do can't continue error
00A0013A                           509  
00A0013A                           510  LAB_CCER
00A0013A  7E1E                     511      MOVEQ       #$1E,d7         * error code $1E "Can't continue" error
00A0013C  603A                     512      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0013E                           513  
00A0013E                           514  
00A0013E                           515  *************************************************************************************
00A0013E                           516  *
00A0013E                           517  * do string too complex error
00A0013E                           518  
00A0013E                           519  LAB_SCER
00A0013E  7E1C                     520      MOVEQ       #$1C,d7         * error code $1C "String too complex" error
00A00140  6036                     521      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00142                           522  
00A00142                           523  
00A00142                           524  *************************************************************************************
00A00142                           525  *
00A00142                           526  * do string too long error
00A00142                           527  
00A00142                           528  LAB_SLER
00A00142  7E1A                     529      MOVEQ       #$1A,d7         * error code $1A "String too long" error
00A00144  6032                     530      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00146                           531  
00A00146                           532  
00A00146                           533  *************************************************************************************
00A00146                           534  *
00A00146                           535  * do type missmatch error
00A00146                           536  
00A00146                           537  LAB_TMER
00A00146  7E18                     538      MOVEQ       #$18,d7         * error code $18 "Type mismatch" error
00A00148  602E                     539      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0014A                           540  
00A0014A                           541  
00A0014A                           542  *************************************************************************************
00A0014A                           543  *
00A0014A                           544  * do illegal direct error
00A0014A                           545  
00A0014A                           546  LAB_IDER
00A0014A  7E16                     547      MOVEQ       #$16,d7         * error code $16 "Illegal direct" error
00A0014C  602A                     548      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0014E                           549  
00A0014E                           550  
00A0014E                           551  *************************************************************************************
00A0014E                           552  *
00A0014E                           553  * do divide by zero error
00A0014E                           554  
00A0014E                           555  LAB_DZER
00A0014E  7E14                     556      MOVEQ       #$14,d7         * error code $14 "Divide by zero" error
00A00150  6026                     557      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00152                           558  
00A00152                           559  
00A00152                           560  *************************************************************************************
00A00152                           561  *
00A00152                           562  * do double dimension error
00A00152                           563  
00A00152                           564  LAB_DDER
00A00152  7E12                     565      MOVEQ       #$12,d7         * error code $12 "Double dimension" error
00A00154  6022                     566      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00156                           567  
00A00156                           568  
00A00156                           569  *************************************************************************************
00A00156                           570  *
00A00156                           571  * do array bounds error
00A00156                           572  
00A00156                           573  LAB_ABER
00A00156  7E10                     574      MOVEQ       #$10,d7         * error code $10 "Array bounds" error
00A00158  601E                     575      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0015A                           576  
00A0015A                           577  
00A0015A                           578  *************************************************************************************
00A0015A                           579  *
00A0015A                           580  * do undefined satement error
00A0015A                           581  
00A0015A                           582  LAB_USER
00A0015A  7E0E                     583      MOVEQ       #$0E,d7         * error code $0E "Undefined statement" error
00A0015C  601A                     584      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0015E                           585  
00A0015E                           586  
00A0015E                           587  *************************************************************************************
00A0015E                           588  *
00A0015E                           589  * do out of memory error
00A0015E                           590  
00A0015E                           591  LAB_OMER
00A0015E  7E0C                     592      MOVEQ       #$0C,d7         * error code $0C "Out of memory" error
00A00160  6016                     593      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00162                           594  
00A00162                           595  
00A00162                           596  *************************************************************************************
00A00162                           597  *
00A00162                           598  * do overflow error
00A00162                           599  
00A00162                           600  LAB_OFER
00A00162  7E0A                     601      MOVEQ       #$0A,d7         * error code $0A "Overflow" error
00A00164  6012                     602      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00166                           603  
00A00166                           604  
00A00166                           605  *************************************************************************************
00A00166                           606  *
00A00166                           607  * do function call error
00A00166                           608  
00A00166                           609  LAB_FCER
00A00166  7E08                     610      MOVEQ       #$08,d7         * error code $08 "Function call" error
00A00168  600E                     611      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0016A                           612  
00A0016A                           613  
00A0016A                           614  *************************************************************************************
00A0016A                           615  *
00A0016A                           616  * do out of data error
00A0016A                           617  
00A0016A                           618  LAB_ODER
00A0016A  7E06                     619      MOVEQ       #$06,d7         * error code $06 "Out of DATA" error
00A0016C  600A                     620      BRA.s       LAB_XERR            * do error #d7, then warm start
00A0016E                           621  
00A0016E                           622  
00A0016E                           623  *************************************************************************************
00A0016E                           624  *
00A0016E                           625  * do return without gosub error
00A0016E                           626  
00A0016E                           627  LAB_RGER
00A0016E  7E04                     628      MOVEQ       #$04,d7         * error code $04 "RETURN without GOSUB" error
00A00170  6006                     629      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00172                           630  
00A00172                           631  
00A00172                           632  *************************************************************************************
00A00172                           633  *
00A00172                           634  * do syntax error
00A00172                           635  
00A00172                           636  LAB_SNER
00A00172  7E02                     637      MOVEQ       #$02,d7         * error code $02 "Syntax" error
00A00174  6002                     638      BRA.s       LAB_XERR            * do error #d7, then warm start
00A00176                           639  
00A00176                           640  
00A00176                           641  *************************************************************************************
00A00176                           642  *
00A00176                           643  * do next without for error
00A00176                           644  
00A00176                           645  LAB_NFER
00A00176  7E00                     646      MOVEQ       #$00,d7         * error code $00 "NEXT without FOR" error
00A00178                           647  
00A00178                           648  
00A00178                           649  *************************************************************************************
00A00178                           650  *
00A00178                           651  * do error #d7, then warm start
00A00178                           652  
00A00178                           653  LAB_XERR
00A00178  6100 02CA                654      BSR     LAB_1491            * flush stack & clear continue flag
00A0017C  6100 080A                655      BSR     LAB_CRLF            * print CR/LF
00A00180  43FA 2FE4                656      LEA     LAB_BAER(pc),a1     * start of error message pointer table
00A00184  3E31 7000                657      MOVE.w  (a1,d7.w),d7        * get error message offset
00A00188  41F1 7000                658      LEA     (a1,d7.w),a0        * get error message address
00A0018C  6100 0858                659      BSR     LAB_18C3            * print null terminated string from memory
00A00190  41FA 331F                660      LEA     LAB_EMSG(pc),a0     * point to " Error" message
00A00194                           661  LAB_1269
00A00194  6100 0850                662      BSR     LAB_18C3            * print null terminated string from memory
00A00198  202B 0CB6                663      MOVE.l  Clinel(a3),d0       * get current line
00A0019C  6B04                     664      BMI.s       LAB_1274            * go do warm start if -ve # (was immediate mode)
00A0019E                           665  
00A0019E                           666                              * else print line number
00A0019E  6100 1B1C                667      BSR     LAB_2953            * print " in line [LINE #]"
00A001A2                           668  
00A001A2                           669  * BASIC warm start entry point, wait for Basic command
00A001A2                           670  
00A001A2                           671  LAB_1274
00A001A2  41FA 3340                672      LEA     LAB_RMSG(pc),a0     * point to "Ready" message
00A001A6  6100 083E                673      BSR     LAB_18C3            * go do print string
00A001AA                           674  
00A001AA                           675  * wait for Basic command - no "Ready"
00A001AA                           676  
00A001AA                           677  LAB_127D
00A001AA  72FF                     678      MOVEQ       #-1,d1          * set to -1
00A001AC  2741 0CB6                679      MOVE.l  d1,Clinel(a3)       * set current line #
00A001B0  1741 0E40                680      MOVE.b  d1,Breakf(a3)       * set break flag
00A001B4  4BEB 0CF4                681      LEA     Ibuffs(a3),a5       * set basic execute pointer ready for new line
00A001B8                           682  LAB_127E
00A001B8  6100 00EC                683      BSR     LAB_1357            * call for BASIC input
00A001BC  6100 0BF4                684      BSR     LAB_GBYT            * scan memory
00A001C0  67F6                     685      BEQ.s       LAB_127E            * loop while null
00A001C2                           686  
00A001C2                           687  * got to interpret input line now ....
00A001C2                           688  
00A001C2  6508                     689      BCS.s       LAB_1295            * branch if numeric character, handle new
00A001C4                           690                              * BASIC line
00A001C4                           691  
00A001C4                           692                              * no line number so do immediate mode, a5
00A001C4                           693                              * points to the buffer start
00A001C4  6100 0156                694      BSR     LAB_13A6            * crunch keywords into Basic tokens
00A001C8                           695                              * crunch from (a5), output to (a0)
00A001C8                           696                              * returns ..
00A001C8                           697                              * d2 is length, d1 trashed, d0 trashed,
00A001C8                           698                              * a1 trashed
00A001C8  6000 03C4                699      BRA     LAB_15F6            * go scan & interpret code
00A001CC                           700  
00A001CC                           701  
00A001CC                           702  *************************************************************************************
00A001CC                           703  *
00A001CC                           704  * handle a new BASIC line
00A001CC                           705  
00A001CC                           706  LAB_1295
00A001CC  6100 063A                707      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00A001D0  6100 014A                708      BSR     LAB_13A6            * crunch keywords into Basic tokens
00A001D4                           709                              * crunch from (a5), output to (a0)
00A001D4                           710                              * returns .. d2 is length,
00A001D4                           711                              * d1 trashed, d0 trashed, a1 trashed
00A001D4  222B 0C8E                712      MOVE.l  Itemp(a3),d1        * get required line #
00A001D8  6100 0218                713      BSR     LAB_SSLN            * search BASIC for d1 line number
00A001DC                           714                              * returns pointer in a0
00A001DC  6532                     715      BCS.s       LAB_12E6            * branch if not found
00A001DE                           716  
00A001DE                           717                              * aroooogah! line # already exists! delete it
00A001DE  2250                     718      MOVEA.l (a0),a1         * get start of block (next line pointer)
00A001E0  202B 0C96                719      MOVE.l  Sfncl(a3),d0        * get end of block (start of functions)
00A001E4  9089                     720      SUB.l       a1,d0               * subtract start of block ( = bytes to move)
00A001E6  E288                     721      LSR.l       #1,d0               * /2 (word move)
00A001E8  5380                     722      SUBQ.l  #1,d0               * adjust for DBF loop
00A001EA  4840                     723      SWAP        d0              * swap high word to low word
00A001EC  2448                     724      MOVEA.l a0,a2               * copy destination
00A001EE                           725  LAB_12AE
00A001EE  4840                     726      SWAP        d0              * swap high word to low word
00A001F0                           727  LAB_12B0
00A001F0  34D9                     728      MOVE.w  (a1)+,(a2)+         * copy word
00A001F2  51C8 FFFC                729      DBF     d0,LAB_12B0         * decrement low count and loop until done
00A001F6                           730  
00A001F6  4840                     731      SWAP        d0              * swap high word to low word
00A001F8  51C8 FFF4                732      DBF     d0,LAB_12AE         * decrement high count and loop until done
00A001FC                           733  
00A001FC  274A 0C96                734      MOVE.l  a2,Sfncl(a3)        * start of functions
00A00200  274A 0C9A                735      MOVE.l  a2,Svarl(a3)        * save start of variables
00A00204  274A 0C9E                736      MOVE.l  a2,Sstrl(a3)        * start of strings
00A00208  274A 0CA2                737      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00A0020C  274A 0CA6                738      MOVE.l  a2,Earryl(a3)       * save end of arrays
00A00210                           739  
00A00210                           740                              * got new line in buffer and no existing same #
00A00210                           741  LAB_12E6
00A00210  102B 0CF4                742      MOVE.b  Ibuffs(a3),d0       * get byte from start of input buffer
00A00214  6764                     743      BEQ.s       LAB_1325            * if null line go do line chaining
00A00216                           744  
00A00216                           745                              * got new line and it isn't empty line
00A00216  226B 0C96                746      MOVEA.l Sfncl(a3),a1        * get start of functions (end of block to move)
00A0021A  45F1 2008                747      LEA     8(a1,d2),a2         * copy it, add line length and add room for
00A0021E                           748                              * pointer and line number
00A0021E                           749  
00A0021E  274A 0C96                750      MOVE.l  a2,Sfncl(a3)        * start of functions
00A00222  274A 0C9A                751      MOVE.l  a2,Svarl(a3)        * save start of variables
00A00226  274A 0C9E                752      MOVE.l  a2,Sstrl(a3)        * start of strings
00A0022A  274A 0CA2                753      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00A0022E  274A 0CA6                754      MOVE.l  a2,Earryl(a3)       * save end of arrays
00A00232  276B 0CAE 0CAA           755      MOVE.l  Ememl(a3),Sstorl(a3)    * copy end of mem to start of strings, clear
00A00238                           756                              * strings
00A00238                           757  
00A00238  2209                     758      MOVE.l  a1,d1               * copy end of block to move
00A0023A  9288                     759      SUB.l       a0,d1               * subtract start of block to move
00A0023C  E289                     760      LSR.l       #1,d1               * /2 (word copy)
00A0023E  5381                     761      SUBQ.l  #1,d1               * correct for loop end on -1
00A00240  4841                     762      SWAP        d1              * swap high word to low word
00A00242                           763  LAB_12FF
00A00242  4841                     764      SWAP        d1              * swap high word to low word
00A00244                           765  LAB_1301
00A00244  3521                     766      MOVE.w  -(a1),-(a2)         * decrement pointers and copy word
00A00246  51C9 FFFC                767      DBF     d1,LAB_1301         * decrement & loop
00A0024A                           768  
00A0024A  4841                     769      SWAP        d1              * swap high word to low word
00A0024C  51C9 FFF4                770      DBF     d1,LAB_12FF         * decrement high count and loop until done
00A00250                           771  
00A00250                           772  * space is opened up, now copy the crunched line from the input buffer into the space
00A00250                           773  
00A00250  43EB 0CF4                774      LEA     Ibuffs(a3),a1       * source is input buffer
00A00254  2448                     775      MOVEA.l a0,a2               * copy destination
00A00256  72FF                     776      MOVEQ       #-1,d1          * set to allow re-chaining
00A00258  24C1                     777      MOVE.l  d1,(a2)+            * set next line pointer (allow re-chaining)
00A0025A  24EB 0C8E                778      MOVE.l  Itemp(a3),(a2)+     * save line number
00A0025E  E24A                     779      LSR.w       #1,d2               * /2 (word copy)
00A00260  5342                     780      SUBQ.w  #1,d2               * correct for loop end on -1
00A00262                           781  LAB_1303
00A00262  34D9                     782      MOVE.w  (a1)+,(a2)+         * copy word
00A00264  51CA FFFC                783      DBF     d2,LAB_1303         * decrement & loop
00A00268                           784  
00A00268  6010                     785      BRA.s       LAB_1325            * go test for end of prog
00A0026A                           786  
00A0026A                           787  * rebuild chaining of BASIC lines
00A0026A                           788  
00A0026A                           789  LAB_132E
00A0026A  5048                     790      ADDQ.w  #8,a0               * point to first code byte of line, there is
00A0026C                           791                              * always 1 byte + [EOL] as null entries are
00A0026C                           792                              * deleted
00A0026C                           793  LAB_1330
00A0026C  4A18                     794      TST.b       (a0)+               * test byte 
00A0026E  66FC                     795      BNE.s       LAB_1330            * loop if not [EOL]
00A00270                           796  
00A00270                           797                              * was [EOL] so get next line start
00A00270  3208                     798      MOVE.w  a0,d1               * past pad byte(s)
00A00272  0241 0001                799      ANDI.w  #1,d1               * mask odd bit
00A00276  D0C1                     800      ADD.w       d1,a0               * add back to ensure even
00A00278  2288                     801      MOVE.l  a0,(a1)         * save next line pointer to current line
00A0027A                           802  LAB_1325
00A0027A  2248                     803      MOVEA.l a0,a1               * copy pointer for this line
00A0027C  4A90                     804      TST.l       (a0)                * test pointer to next line
00A0027E  66EA                     805      BNE.s       LAB_132E            * not end of program yet so we must
00A00280                           806                              * go and fix the pointers
00A00280                           807  
00A00280  6100 0198                808      BSR     LAB_1477            * reset execution to start, clear variables
00A00284                           809                              * and flush stack
00A00284  6000 FF24                810      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
00A00288                           811  
00A00288                           812  
00A00288                           813  *************************************************************************************
00A00288                           814  *
00A00288                           815  * receive a line from the keyboard
00A00288                           816                              * character $08 as delete key, BACKSPACE on
00A00288                           817                              * standard keyboard
00A00288                           818  LAB_134B
00A00288  6100 0776                819      BSR     LAB_PRNA            * go print the character
00A0028C  7020                     820      MOVEQ       #' ',d0         * load [SPACE]
00A0028E  6100 0770                821      BSR     LAB_PRNA            * go print
00A00292  7008                     822      MOVEQ       #$08,d0         * load [BACKSPACE]
00A00294  6100 076A                823      BSR     LAB_PRNA            * go print
00A00298  5341                     824      SUBQ.w  #$01,d1         * decrement the buffer index (delete)
00A0029A  6010                     825      BRA.s       LAB_1359            * re-enter loop
00A0029C                           826  
00A0029C                           827  * print "? " and get BASIC input
00A0029C                           828  * return a0 pointing to the buffer start
00A0029C                           829  
00A0029C                           830  LAB_INLN
00A0029C  6100 0760                831      BSR     LAB_18E3            * print "?" character
00A002A0  7020                     832      MOVEQ       #' ',d0         * load " "
00A002A2  6100 075C                833      BSR     LAB_PRNA            * go print
00A002A6                           834  
00A002A6                           835  * call for BASIC input (main entry point)
00A002A6                           836  * return a0 pointing to the buffer start
00A002A6                           837  
00A002A6                           838  LAB_1357
00A002A6  7200                     839      MOVEQ       #$00,d1         * clear buffer index
00A002A8  41EB 0CF4                840      LEA     Ibuffs(a3),a0       * set buffer base pointer
00A002AC                           841  LAB_1359
00A002AC  4EAB 0C70                842      JSR     V_INPT(a3)          * call scan input device
00A002B0  64FA                     843      BCC.s       LAB_1359            * loop if no byte
00A002B2                           844  
00A002B2  67F8                     845      BEQ.s       LAB_1359            * loop if null byte
00A002B4                           846  
00A002B4  B03C 0007                847      CMP.b       #$07,d0         * compare with [BELL]
00A002B8  6718                     848      BEQ.s       LAB_1378            * branch if [BELL]
00A002BA                           849  
00A002BA  B03C 000D                850      CMP.b       #$0D,d0         * compare with [CR]
00A002BE  6700 06C2                851      BEQ     LAB_1866            * do CR/LF exit if [CR]
00A002C2                           852  
00A002C2  4A41                     853      TST.w       d1              * set flags on buffer index
00A002C4  6606                     854      BNE.s       LAB_1374            * branch if not empty
00A002C6                           855  
00A002C6                           856  * the next two lines ignore any non printing character and [SPACE] if the input buffer
00A002C6                           857  * is empty
00A002C6                           858  
00A002C6  B03C 0020                859      CMP.b       #' ',d0         * compare with [SP]+1
00A002CA  63E0                     860      BLS.s       LAB_1359            * if < ignore character
00A002CC                           861  
00A002CC                           862  *## CMP.b       #' '+1,d0           * compare with [SP]+1
00A002CC                           863  *## BCS.s       LAB_1359            * if < ignore character
00A002CC                           864  
00A002CC                           865  LAB_1374
00A002CC  B03C 0008                866      CMP.b       #$08,d0         * compare with [BACKSPACE]
00A002D0  67B6                     867      BEQ.s       LAB_134B            * go delete last character
00A002D2                           868  
00A002D2                           869  LAB_1378
00A002D2  B27C 00FF                870      CMP.w       #(Ibuffe-Ibuffs-1),d1   * compare character count with max-1
00A002D6  640C                     871      BCC.s       LAB_138E            * skip store & do [BELL] if buffer full
00A002D8                           872  
00A002D8  1180 1000                873      MOVE.b  d0,(a0,d1.w)        * else store in buffer
00A002DC  5241                     874      ADDQ.w  #$01,d1         * increment index
00A002DE                           875  LAB_137F
00A002DE  6100 0720                876      BSR     LAB_PRNA            * go print the character
00A002E2  60C8                     877      BRA.s       LAB_1359            * always loop for next character
00A002E4                           878  
00A002E4                           879  * announce buffer full
00A002E4                           880  
00A002E4                           881  LAB_138E
00A002E4  7007                     882      MOVEQ       #$07,d0         * [BELL] character into d0
00A002E6  60F6                     883      BRA.s       LAB_137F            * go print the [BELL] but ignore input character
00A002E8                           884  
00A002E8                           885  
00A002E8                           886  *************************************************************************************
00A002E8                           887  *
00A002E8                           888  * copy a hex value without crunching
00A002E8                           889  
00A002E8                           890  LAB_1392
00A002E8  1180 2000                891      MOVE.b  d0,(a0,d2.w)        * save the byte to the output
00A002EC  5242                     892      ADDQ.w  #1,d2               * increment the buffer save index
00A002EE                           893  
00A002EE  5241                     894      ADDQ.w  #1,d1               * increment the buffer read index
00A002F0  1035 1000                895      MOVE.b  (a5,d1.w),d0        * get a byte from the input buffer
00A002F4  6700 0094                896      BEQ     LAB_13EC            * if [EOL] go save it without crunching
00A002F8                           897  
00A002F8  B03C 0020                898      CMP.b       #' ',d0         * compare the character with " "
00A002FC  67EA                     899      BEQ.s       LAB_1392            * if [SPACE] just go save it and get another
00A002FE                           900  
00A002FE  B03C 0030                901      CMP.b       #'0',d0         * compare the character with "0"
00A00302  654A                     902      BCS.s       LAB_13C6            * if < "0" quit the hex save loop
00A00304                           903  
00A00304  B03C 0039                904      CMP.b       #'9',d0         * compare with "9"
00A00308  63DE                     905      BLS.s       LAB_1392            * if it is "0" to "9" save it and get another
00A0030A                           906  
00A0030A  7ADF                     907      MOVEQ       #-33,d5         * mask xx0x xxxx, ASCII upper case
00A0030C  CA00                     908      AND.b       d0,d5               * mask the character
00A0030E                           909  
00A0030E  BA3C 0041                910      CMP.b       #'A',d5         * compare with "A"
00A00312  6540                     911      BCS.s       LAB_13CC            * if < "A" quit the hex save loop
00A00314                           912  
00A00314  BA3C 0046                913      CMP.b       #'F',d5         * compare with "F"
00A00318  63CE                     914      BLS.s       LAB_1392            * if it is "A" to "F" save it and get another
00A0031A                           915  
00A0031A  6038                     916      BRA.s       LAB_13CC            * else continue crunching
00A0031C                           917  
00A0031C                           918  * crunch keywords into Basic tokens
00A0031C                           919  * crunch from (a5), output to (a0)
00A0031C                           920  * returns ..
00A0031C                           921  * d4 trashed
00A0031C                           922  * d3 trashed
00A0031C                           923  * d2 is length
00A0031C                           924  * d1 trashed
00A0031C                           925  * d0 trashed
00A0031C                           926  * a1 trashed
00A0031C                           927  
00A0031C                           928  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00A0031C                           929  * old list search
00A0031C                           930  
00A0031C                           931  LAB_13A6
00A0031C  7200                     932      MOVEQ       #0,d1               * clear the read index
00A0031E  2401                     933      MOVE.l  d1,d2               * clear the save index
00A00320  1741 0E41                934      MOVE.b  d1,Oquote(a3)       * clear the open quote/DATA flag
00A00324                           935  LAB_13AC
00A00324  7000                     936      MOVEQ       #0,d0               * clear word
00A00326  1035 1000                937      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00A0032A  675E                     938      BEQ.s       LAB_13EC            * if null save byte then continue crunching
00A0032C                           939  
00A0032C  B03C 005F                940      CMP.b       #'_',d0         * compare with "_"
00A00330  6458                     941      BCC.s       LAB_13EC            * if >= "_" save byte then continue crunching
00A00332                           942  
00A00332  B03C 003C                943      CMP.b       #'<',d0         * compare with "<"
00A00336  641C                     944      BCC.s       LAB_13CC            * if >= "<" go crunch
00A00338                           945  
00A00338  B03C 0030                946      CMP.b       #'0',d0         * compare with "0"
00A0033C  644C                     947      BCC.s       LAB_13EC            * if >= "0" save byte then continue crunching
00A0033E                           948  
00A0033E  1740 0E3E                949      MOVE.b  d0,Asrch(a3)        * save buffer byte as search character
00A00342  B03C 0022                950      CMP.b       #$22,d0         * is it quote character?
00A00346  6776                     951      BEQ.s       LAB_1410            * branch if so (copy quoted string)
00A00348                           952  
00A00348  B03C 0024                953      CMP.b       #'$',d0         * is it the hex value character?
00A0034C  679A                     954      BEQ.s       LAB_1392            * if so go copy a hex value
00A0034E                           955  
00A0034E                           956  LAB_13C6
00A0034E  B03C 002A                957      CMP.b       #'*',d0         * compare with "*"
00A00352  6536                     958      BCS.s       LAB_13EC            * if <= "*" save byte then continue crunching
00A00354                           959  
00A00354                           960                              * crunch rest
00A00354                           961  LAB_13CC
00A00354  082B 0006 0E41           962      BTST.b  #6,Oquote(a3)       * test open quote/DATA token flag
00A0035A  662E                     963      BNE.s       LAB_13EC            * branch if b6 of Oquote set (was DATA)
00A0035C                           964                              * go save byte then continue crunching
00A0035C                           965  
00A0035C  0400 002A                966      SUB.b       #$2A,d0         * normalise byte
00A00360  D040                     967      ADD.w       d0,d0               * *2 makes word offset (high byte=$00)
00A00362  43FA 2C04                968      LEA     TAB_CHRT(pc),a1     * get keyword offset table address
00A00366  3031 0000                969      MOVE.w  (a1,d0.w),d0        * get offset into keyword table
00A0036A  6B6E                     970      BMI.s       LAB_141F            * branch if no keywords for character
00A0036C                           971  
00A0036C  43FA 2F90                972      LEA     TAB_STAR(pc),a1     * get keyword table address
00A00370  D2C0                     973      ADDA.w  d0,a1               * add keyword offset
00A00372  76FF                     974      MOVEQ       #-1,d3          * clear index
00A00374  3801                     975      MOVE.w  d1,d4               * copy read index
00A00376                           976  LAB_13D6
00A00376  5243                     977      ADDQ.w  #1,d3               * increment table index
00A00378  1031 3000                978      MOVE.b  (a1,d3.w),d0        * get byte from table
00A0037C                           979  LAB_13D8
00A0037C  6B0A                     980      BMI.s       LAB_13EA            * branch if token, save token and continue
00A0037E                           981                              * crunching
00A0037E                           982  
00A0037E  5244                     983      ADDQ.w  #1,d4               * increment read index
00A00380  B035 4000                984      CMP.b       (a5,d4.w),d0        * compare byte from input buffer
00A00384  67F0                     985      BEQ.s       LAB_13D6            * loop if character match
00A00386                           986  
00A00386  6040                     987      BRA.s       LAB_1417            * branch if no match
00A00388                           988  
00A00388                           989  LAB_13EA
00A00388  3204                     990      MOVE.w  d4,d1               * update read index
00A0038A                           991  LAB_13EC
00A0038A  1180 2000                992      MOVE.b  d0,(a0,d2.w)        * save byte to output
00A0038E  5242                     993      ADDQ.w  #1,d2               * increment buffer save index
00A00390  5241                     994      ADDQ.w  #1,d1               * increment buffer read index
00A00392  4A00                     995      TST.b       d0              * set flags
00A00394  674A                     996      BEQ.s       LAB_142A            * branch if was null [EOL]
00A00396                           997  
00A00396                           998                              * d0 holds token or byte here
00A00396  0400 003A                999      SUB.b       #$3A,d0         * subtract ":"
00A0039A  6706                    1000      BEQ.s       LAB_13FF            * branch if it was ":" (is now $00)
00A0039C                          1001  
00A0039C                          1002                              * d0 now holds token-$3A
00A0039C  B03C 0049               1003      CMP.b       #(TK_DATA-$3A),d0       * compare with DATA token - $3A
00A003A0  6604                    1004      BNE.s       LAB_1401            * branch if not DATA
00A003A2                          1005  
00A003A2                          1006                              * token was : or DATA
00A003A2                          1007  LAB_13FF
00A003A2  1740 0E41               1008      MOVE.b  d0,Oquote(a3)       * save token-$3A ($00 for ":", TK_DATA-$3A for
00A003A6                          1009                              * DATA)
00A003A6                          1010  LAB_1401
00A003A6  0400 0055               1011      SUB.b       #(TK_REM-$3A),d0        * subtract REM token offset
00A003AA  6600 FF78               1012      BNE     LAB_13AC            * If wasn't REM then go crunch rest of line
00A003AE                          1013  
00A003AE  1740 0E3E               1014      MOVE.b  d0,Asrch(a3)        * else was REM so set search for [EOL]
00A003B2                          1015  
00A003B2                          1016                              * loop for REM, "..." etc.
00A003B2                          1017  LAB_1408
00A003B2  1035 1000               1018      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00A003B6  67D2                    1019      BEQ.s       LAB_13EC            * branch if null [EOL]
00A003B8                          1020  
00A003B8  B02B 0E3E               1021      CMP.b       Asrch(a3),d0        * compare with stored character
00A003BC  67CC                    1022      BEQ.s       LAB_13EC            * branch if match (end quote, REM, :, or DATA)
00A003BE                          1023  
00A003BE                          1024                              * entry for copy string in quotes, don't crunch
00A003BE                          1025  LAB_1410
00A003BE  1180 2000               1026      MOVE.b  d0,(a0,d2.w)        * save byte to output
00A003C2  5242                    1027      ADDQ.w  #1,d2               * increment buffer save index
00A003C4  5241                    1028      ADDQ.w  #1,d1               * increment buffer read index
00A003C6  60EA                    1029      BRA.s       LAB_1408            * loop
00A003C8                          1030  
00A003C8                          1031  * not found keyword this go so find the end of this word in the table
00A003C8                          1032  
00A003C8                          1033  LAB_1417
00A003C8  3801                    1034      MOVE.w  d1,d4               * reset read pointer
00A003CA                          1035  LAB_141B
00A003CA  5243                    1036      ADDQ.w  #1,d3               * increment keyword table pointer, flag
00A003CC                          1037                              * unchanged
00A003CC  1031 3000               1038      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00A003D0  6AF8                    1039      BPL.s       LAB_141B            * if not end of keyword go do next byte
00A003D2                          1040  
00A003D2  5243                    1041      ADDQ.w  #1,d3               * increment keyword table pointer flag
00A003D4                          1042                              * unchanged
00A003D4  1031 3000               1043      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00A003D8  66A2                    1044      BNE.s       LAB_13D8            * go test next word if not zero byte (table end)
00A003DA                          1045  
00A003DA                          1046                              * reached end of table with no match
00A003DA                          1047  LAB_141F
00A003DA  1035 1000               1048      MOVE.b  (a5,d1.w),d0        * restore byte from input buffer
00A003DE  60AA                    1049      BRA.s       LAB_13EC            * go save byte in output and continue crunching
00A003E0                          1050  
00A003E0                          1051                              * reached [EOL]
00A003E0                          1052  LAB_142A
00A003E0  7000                    1053      MOVEQ       #0,d0               * ensure longword clear
00A003E2  0102                    1054      BTST        d0,d2               * test odd bit (fastest)
00A003E4  6706                    1055      BEQ.s       LAB_142C            * branch if no bytes to fill
00A003E6                          1056  
00A003E6  1180 2000               1057      MOVE.b  d0,(a0,d2.w)        * clear next byte
00A003EA  5242                    1058      ADDQ.w  #1,d2               * increment buffer save index
00A003EC                          1059  LAB_142C
00A003EC  2180 2000               1060      MOVE.l  d0,(a0,d2.w)        * clear next line pointer, EOT in immediate mode
00A003F0  4E75                    1061      RTS
00A003F2                          1062  
00A003F2                          1063  
00A003F2                          1064  *************************************************************************************
00A003F2                          1065  *
00A003F2                          1066  * search Basic for d1 line number from start of mem
00A003F2                          1067  
00A003F2                          1068  LAB_SSLN
00A003F2  206B 0C92               1069      MOVEA.l Smeml(a3),a0        * get start of program mem
00A003F6  6002                    1070      BRA.s       LAB_SCLN            * go search for required line from a0
00A003F8                          1071  
00A003F8                          1072  LAB_145F
00A003F8  2040                    1073      MOVEA.l d0,a0               * copy next line pointer
00A003FA                          1074  
00A003FA                          1075  * search Basic for d1 line number from a0
00A003FA                          1076  * returns Cb=0 if found
00A003FA                          1077  * returns a0 pointer to found or next higher (not found) line
00A003FA                          1078  
00A003FA                          1079  LAB_SCLN
00A003FA  2018                    1080      MOVE.l  (a0)+,d0            * get next line pointer and point to line #
00A003FC  6708                    1081      BEQ.s       LAB_145E            * is end marker so we're done, do 'no line' exit
00A003FE                          1082  
00A003FE  B290                    1083      CMP.l       (a0),d1         * compare this line # with required line #
00A00400  6EF6                    1084      BGT.s       LAB_145F            * loop if required # > this #
00A00402                          1085  
00A00402  5948                    1086      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00A00404  4E75                    1087      RTS
00A00406                          1088  
00A00406                          1089  LAB_145E
00A00406  5948                    1090      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00A00408  5380                    1091      SUBQ.l  #1,d0               * make end program found = -1, set carry
00A0040A  4E75                    1092      RTS
00A0040C                          1093  
00A0040C                          1094  
00A0040C                          1095  *************************************************************************************
00A0040C                          1096  *
00A0040C                          1097  * perform NEW
00A0040C                          1098  
00A0040C                          1099  LAB_NEW
00A0040C  664C                    1100      BNE.s       RTS_005         * exit if not end of statement (do syntax error)
00A0040E                          1101  
00A0040E                          1102  LAB_1463
00A0040E  206B 0C92               1103      MOVEA.l Smeml(a3),a0        * point to start of program memory
00A00412  7000                    1104      MOVEQ       #0,d0               * clear longword
00A00414  20C0                    1105      MOVE.l  d0,(a0)+            * clear first line, next line pointer
00A00416  2748 0C96               1106      MOVE.l  a0,Sfncl(a3)        * set start of functions
00A0041A                          1107  
00A0041A                          1108  * reset execution to start, clear variables and flush stack
00A0041A                          1109  
00A0041A                          1110  LAB_1477
00A0041A  2A6B 0C92               1111      MOVEA.l Smeml(a3),a5        * reset BASIC execute pointer
00A0041E  534D                    1112      SUBQ.w  #1,a5               * -1 (as end of previous line)
00A00420                          1113  
00A00420                          1114  * "CLEAR" command gets here
00A00420                          1115  
00A00420                          1116  LAB_147A
00A00420  276B 0CAE 0CAA          1117      MOVE.l  Ememl(a3),Sstorl(a3)    * save end of mem as bottom of string space
00A00426  202B 0C96               1118      MOVE.l  Sfncl(a3),d0        * get start of functions
00A0042A  2740 0C9A               1119      MOVE.l  d0,Svarl(a3)        * start of variables
00A0042E  2740 0C9E               1120      MOVE.l  d0,Sstrl(a3)        * start of strings
00A00432  2740 0CA2               1121      MOVE.l  d0,Sarryl(a3)       * set start of arrays
00A00436  2740 0CA6               1122      MOVE.l  d0,Earryl(a3)       * set end of arrays
00A0043A                          1123  LAB_1480
00A0043A  7000                    1124      MOVEQ       #0,d0               * set Zb
00A0043C  1740 0E4E               1125      MOVE.b  d0,ccnull(a3)       * clear get byte countdown
00A00440  6100 01CE               1126      BSR     LAB_RESTORE         * perform RESTORE command
00A00444                          1127  
00A00444                          1128  * flush stack & clear continue flag
00A00444                          1129  
00A00444                          1130  LAB_1491
00A00444  49EB 0CF2               1131      LEA     des_sk(a3),a4       * reset descriptor stack pointer
00A00448                          1132  
00A00448  201F                    1133      MOVE.l  (sp)+,d0            * pull return address
00A0044A  4FEB 0C64               1134      LEA     ram_base(a3),sp     * set stack to RAM start + 1k* set stack to RAM start + 1k, flush stack
00A0044E  2F00                    1135      MOVE.l  d0,-(sp)            * restore return address
00A00450                          1136  
00A00450  7000                    1137      MOVEQ       #0,d0               * clear longword
00A00452  2740 0CBE               1138      MOVE.l  d0,Cpntrl(a3)       * clear continue pointer
00A00456  1740 0E43               1139      MOVE.b  d0,Sufnxf(a3)       * clear subscript/FNX flag
00A0045A                          1140  RTS_005
00A0045A  4E75                    1141      RTS
00A0045C                          1142  
00A0045C                          1143  
00A0045C                          1144  *************************************************************************************
00A0045C                          1145  *
00A0045C                          1146  * perform CLEAR
00A0045C                          1147  
00A0045C                          1148  LAB_CLEAR
00A0045C  67C2                    1149      BEQ.s       LAB_147A            * if no following byte go do "CLEAR"
00A0045E                          1150  
00A0045E  4E75                    1151      RTS                     * was following byte (go do syntax error)
00A00460                          1152  
00A00460                          1153  
00A00460                          1154  *************************************************************************************
00A00460                          1155  *
00A00460                          1156  * perform LIST [n][-m]
00A00460                          1157  
00A00460                          1158  LAB_LIST
00A00460  6512                    1159      BCS.s       LAB_14BD            * branch if next character numeric (LIST n...)
00A00462                          1160  
00A00462  72FF                    1161      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00A00464  2741 0C8E               1162      MOVE.l  d1,Itemp(a3)        * save to Itemp
00A00468                          1163  
00A00468  7200                    1164      MOVEQ       #0,d1               * set start to $00000000
00A0046A  4A00                    1165      TST.b       d0              * test next byte
00A0046C  670A                    1166      BEQ.s       LAB_14C0            * branch if next character [NULL] (LIST)
00A0046E                          1167  
00A0046E  B03C 00B3               1168      CMP.b       #TK_MINUS,d0        * compare with token for -
00A00472  66E6                    1169      BNE.s       RTS_005         * exit if not - (LIST -m)
00A00474                          1170  
00A00474                          1171                              * LIST [[n]-[m]] this sets the n, if present,
00A00474                          1172                              * as the start and end
00A00474                          1173  LAB_14BD
00A00474  6100 0392               1174      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00A00478                          1175  LAB_14C0
00A00478  6100 FF78               1176      BSR     LAB_SSLN            * search BASIC for d1 line number
00A0047C                          1177                              * (pointer in a0)
00A0047C  6100 0934               1178      BSR     LAB_GBYT            * scan memory
00A00480  6716                    1179      BEQ.s       LAB_14D4            * branch if no more characters
00A00482                          1180  
00A00482                          1181                              * this bit checks the - is present
00A00482  B03C 00B3               1182      CMP.b       #TK_MINUS,d0        * compare with token for -
00A00486  66D2                    1183      BNE.s       RTS_005         * return if not "-" (will be Syntax error)
00A00488                          1184  
00A00488  72FF                    1185      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00A0048A  2741 0C8E               1186      MOVE.l  d1,Itemp(a3)        * save Itemp
00A0048E                          1187  
00A0048E                          1188                              * LIST [n]-[m] the - was there so see if
00A0048E                          1189                              * there is an m to set as the end value
00A0048E  6100 0920               1190      BSR     LAB_IGBY            * increment & scan memory
00A00492  6704                    1191      BEQ.s       LAB_14D4            * branch if was [NULL] (LIST n-)
00A00494                          1192  
00A00494  6100 0372               1193      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00A00498                          1194  LAB_14D4
00A00498  177C 0000 0E41          1195      MOVE.b  #$00,Oquote(a3)     * clear open quote flag
00A0049E  6100 04E8               1196      BSR     LAB_CRLF            * print CR/LF
00A004A2  2018                    1197      MOVE.l  (a0)+,d0            * get next line pointer
00A004A4  67B4                    1198      BEQ.s       RTS_005         * if null all done so exit
00A004A6                          1199  
00A004A6  2240                    1200      MOVEA.l d0,a1               * copy next line pointer
00A004A8  6100 012C               1201      BSR     LAB_1629            * do CRTL-C check vector
00A004AC                          1202  
00A004AC  2018                    1203      MOVE.l  (a0)+,d0            * get this line #
00A004AE  B0AB 0C8E               1204      CMP.l       Itemp(a3),d0        * compare end line # with this line #
00A004B2  62A6                    1205      BHI.s       RTS_005         * if this line greater all done so exit
00A004B4                          1206  
00A004B4                          1207  LAB_14E2
00A004B4  48E7 00C0               1208      MOVEM.l a0-a1,-(sp)         * save registers
00A004B8  6100 180E               1209      BSR     LAB_295E            * print d0 as unsigned integer
00A004BC  4CDF 0300               1210      MOVEM.l (sp)+,a0-a1         * restore registers
00A004C0  7020                    1211      MOVEQ       #$20,d0         * space is the next character
00A004C2                          1212  LAB_150C
00A004C2  6100 053C               1213      BSR     LAB_PRNA            * go print the character
00A004C6  B03C 0022               1214      CMP.b       #$22,d0         * was it " character
00A004CA  6606                    1215      BNE.s       LAB_1519            * branch if not
00A004CC                          1216  
00A004CC                          1217                              * we're either entering or leaving quotes
00A004CC  0A2B 00FF 0E41          1218      EOR.b       #$FF,Oquote(a3)     * toggle open quote flag
00A004D2                          1219  LAB_1519
00A004D2  1018                    1220      MOVE.b  (a0)+,d0            * get byte and increment pointer
00A004D4  6608                    1221      BNE.s       LAB_152E            * branch if not [EOL] (go print)
00A004D6                          1222  
00A004D6                          1223                              * was [EOL]
00A004D6  2049                    1224      MOVEA.l a1,a0               * copy next line pointer
00A004D8  2008                    1225      MOVE.l  a0,d0               * copy to set flags
00A004DA  66BC                    1226      BNE.s       LAB_14D4            * go do next line if not [EOT]
00A004DC                          1227  
00A004DC  4E75                    1228      RTS
00A004DE                          1229  
00A004DE                          1230  LAB_152E
00A004DE  6AE2                    1231      BPL.s       LAB_150C            * just go print it if not token byte
00A004E0                          1232  
00A004E0                          1233                              * else it was a token byte so maybe uncrunch it
00A004E0  4A2B 0E41               1234      TST.b       Oquote(a3)          * test the open quote flag
00A004E4  6BDC                    1235      BMI.s       LAB_150C            * just go print character if open quote set
00A004E6                          1236  
00A004E6                          1237                              * else uncrunch BASIC token
00A004E6  45FA 2AEA               1238      LEA     LAB_KEYT(pc),a2     * get keyword table address
00A004EA  727F                    1239      MOVEQ       #$7F,d1         * mask into d1
00A004EC  C200                    1240      AND.b       d0,d1               * copy and mask token
00A004EE  E549                    1241      LSL.w       #2,d1               * *4
00A004F0  45F2 1000               1242      LEA     (a2,d1.w),a2        * get keyword entry address
00A004F4  101A                    1243      MOVE.b  (a2)+,d0            * get byte from keyword table
00A004F6  6100 0508               1244      BSR     LAB_PRNA            * go print the first character
00A004FA  7200                    1245      MOVEQ       #0,d1               * clear d1
00A004FC  121A                    1246      MOVE.b  (a2)+,d1            * get remaining length byte from keyword table
00A004FE  6BD2                    1247      BMI.s       LAB_1519            * if -ve done so go get next byte
00A00500                          1248  
00A00500  3012                    1249      MOVE.w  (a2),d0         * get offset to rest
00A00502  45FA 2DFA               1250      LEA     TAB_STAR(pc),a2     * get keyword table address
00A00506  45F2 0000               1251      LEA     (a2,d0.w),a2        * get address of rest
00A0050A                          1252  LAB_1540
00A0050A  101A                    1253      MOVE.b  (a2)+,d0            * get byte from keyword table
00A0050C  6100 04F2               1254      BSR     LAB_PRNA            * go print the character
00A00510  51C9 FFF8               1255      DBF     d1,LAB_1540         * decrement and loop if more to do
00A00514                          1256  
00A00514  60BC                    1257      BRA.s       LAB_1519            * go get next byte
00A00516                          1258  
00A00516                          1259  
00A00516                          1260  *************************************************************************************
00A00516                          1261  *
00A00516                          1262  * perform FOR
00A00516                          1263  
00A00516                          1264  LAB_FOR
00A00516  6100 0390               1265      BSR     LAB_LET         * go do LET
00A0051A                          1266  
00A0051A  202B 0CD6               1267      MOVE.l  Lvarpl(a3),d0       * get the loop variable pointer
00A0051E  B0AB 0C9E               1268      CMP.l       Sstrl(a3),d0        * compare it with the end of vars memory
00A00522  6C00 FC22               1269      BGE     LAB_TMER            * if greater go do type mismatch error
00A00526                          1270  
00A00526                          1271  * test for not less than the start of variables memory if needed
00A00526                          1272  *
00A00526                          1273  *   CMP.l       Svarl(a3),d0        * compare it with the start of variables memory
00A00526                          1274  *   BLT     LAB_TMER            * if not variables memory do type mismatch error
00A00526                          1275  
00A00526                          1276  *   MOVEQ       #28,d0          * we need 28 bytes !
00A00526                          1277  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00A00526                          1278  
00A00526  6100 0214               1279      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00A0052A                          1280                              * returns a0 as pointer to [:] or [EOL]
00A0052A  2E88                    1281      MOVE.l  a0,(sp)         * push onto stack (and dump the return address)
00A0052C  2F2B 0CB6               1282      MOVE.l  Clinel(a3),-(sp)        * push current line onto stack
00A00530                          1283  
00A00530  70AA                    1284      MOVEQ       #TK_TO-$100,d0      * set "TO" token
00A00532  6100 0874               1285      BSR     LAB_SCCA            * scan for CHR$(d0) else syntax error/warm start
00A00536  6100 0702               1286      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00A0053A  1F2B 0E19               1287      MOVE.b  Dtypef(a3),-(sp)        * push the FOR variable data type onto stack
00A0053E  6100 06F8               1288      BSR     LAB_EVNM            * evaluate expression and check is numeric else
00A00542                          1289                              * do type mismatch
00A00542                          1290  
00A00542  2F2B 0DF4               1291      MOVE.l  FAC1_m(a3),-(sp)        * push TO value mantissa
00A00546  3F2B 0DF8               1292      MOVE.w  FAC1_e(a3),-(sp)        * push TO value exponent and sign
00A0054A                          1293  
00A0054A  277C 80000000 0DF4      1294      MOVE.l  #$80000000,FAC1_m(a3)   * set default STEP size mantissa
00A00552  377C 8100 0DF8          1295      MOVE.w  #$8100,FAC1_e(a3)       * set default STEP size exponent and sign
00A00558                          1296  
00A00558  6100 0858               1297      BSR     LAB_GBYT            * scan memory
00A0055C  B03C 00AF               1298      CMP.b       #TK_STEP,d0         * compare with STEP token
00A00560  6608                    1299      BNE.s       LAB_15B3            * jump if not "STEP"
00A00562                          1300  
00A00562                          1301                              * was STEP token so ....
00A00562  6100 084C               1302      BSR     LAB_IGBY            * increment & scan memory
00A00566  6100 06D0               1303      BSR     LAB_EVNM            * evaluate expression & check is numeric
00A0056A                          1304                              * else do type mismatch
00A0056A                          1305  LAB_15B3
00A0056A  2F2B 0DF4               1306      MOVE.l  FAC1_m(a3),-(sp)        * push STEP value mantissa
00A0056E  3F2B 0DF8               1307      MOVE.w  FAC1_e(a3),-(sp)        * push STEP value exponent and sign
00A00572                          1308  
00A00572  2F2B 0CD6               1309      MOVE.l  Lvarpl(a3),-(sp)        * push variable pointer for FOR/NEXT
00A00576  3F3C 0081               1310      MOVE.w  #TK_FOR,-(sp)       * push FOR token on stack
00A0057A                          1311  
00A0057A  6018                    1312      BRA.s       LAB_15C2            * go do interpreter inner loop
00A0057C                          1313  
00A0057C                          1314  LAB_15DC                        * have reached [EOL]+1
00A0057C  300D                    1315      MOVE.w  a5,d0               * copy BASIC execute pointer
00A0057E  C07C 0001               1316      AND.w       #1,d0               * and make line start address even
00A00582  DAC0                    1317      ADD.w       d0,a5               * add to BASIC execute pointer
00A00584  201D                    1318      MOVE.l  (a5)+,d0            * get next line pointer
00A00586  6700 FC1A               1319      BEQ     LAB_1274            * if null go to immediate mode, no "BREAK"
00A0058A                          1320                              * message (was immediate or [EOT] marker)
00A0058A                          1321  
00A0058A  275D 0CB6               1322      MOVE.l  (a5)+,Clinel(a3)        * save (new) current line #
00A0058E                          1323  LAB_15F6
00A0058E  6100 0822               1324      BSR     LAB_GBYT            * get BASIC byte
00A00592  611A                    1325      BSR.s       LAB_15FF            * go interpret BASIC code from (a5)
00A00594                          1326  
00A00594                          1327  * interpreter inner loop (re)entry point
00A00594                          1328  
00A00594                          1329  LAB_15C2
00A00594  6140                    1330      BSR.s       LAB_1629            * do CRTL-C check vector
00A00596  4A2B 0CB6               1331      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00A0059A  6B04                    1332      BMI.s       LAB_15D1            * branch if immediate mode
00A0059C                          1333  
00A0059C  274D 0CBE               1334      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00A005A0                          1335  LAB_15D1
00A005A0  101D                    1336      MOVE.b  (a5)+,d0            * get this byte & increment pointer
00A005A2  67D8                    1337      BEQ.s       LAB_15DC            * loop if [EOL]
00A005A4                          1338  
00A005A4  B03C 003A               1339      CMP.b       #$3A,d0         * compare with ":"
00A005A8  67E4                    1340      BEQ.s       LAB_15F6            * loop if was statement separator
00A005AA                          1341  
00A005AA  6000 FBC6               1342      BRA     LAB_SNER            * else syntax error, then warm start
00A005AE                          1343  
00A005AE                          1344  
00A005AE                          1345  *************************************************************************************
00A005AE                          1346  *
00A005AE                          1347  * interpret BASIC code from (a5)
00A005AE                          1348  
00A005AE                          1349  LAB_15FF
00A005AE  6700 008C               1350      BEQ     RTS_006         * exit if zero [EOL]
00A005B2                          1351  
00A005B2                          1352  LAB_1602
00A005B2  0A00 0080               1353      EORI.b  #$80,d0         * normalise token
00A005B6  6B00 02F0               1354      BMI     LAB_LET         * if not token, go do implied LET
00A005BA                          1355  
00A005BA  B03C 0028               1356      CMP.b       #(TK_TAB-$80),d0        * compare normalised token with TAB
00A005BE  6400 FBB2               1357      BCC     LAB_SNER            * branch if d0>=TAB, syntax error/warm start
00A005C2                          1358                              * only tokens before TAB can start a statement
00A005C2                          1359  
00A005C2  4880                    1360      EXT.w       d0              * byte to word (clear high byte)
00A005C4  D040                    1361      ADD.w       d0,d0               * *2
00A005C6  41FA 2868               1362      LEA     LAB_CTBL(pc),a0     * get vector table base address
00A005CA  3030 0000               1363      MOVE.w  (a0,d0.w),d0        * get offset to vector
00A005CE  4870 0000               1364      PEA     (a0,d0.w)           * push vector
00A005D2  6000 07DC               1365      BRA     LAB_IGBY            * get following byte & execute vector
00A005D6                          1366  
00A005D6                          1367  
00A005D6                          1368  *************************************************************************************
00A005D6                          1369  *
00A005D6                          1370  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00A005D6                          1371  * key press is detected.
00A005D6                          1372  
00A005D6                          1373  LAB_1629
00A005D6  4EEB 0C88               1374      JMP     V_CTLC(a3)          * ctrl c check vector
00A005DA                          1375  
00A005DA                          1376  * if there was a key press it gets back here .....
00A005DA                          1377  
00A005DA                          1378  LAB_1636
00A005DA  B03C 0003               1379      CMP.b       #$03,d0         * compare with CTRL-C
00A005DE  670C                    1380      BEQ.s       LAB_163B            * STOP if was CTRL-C
00A005E0                          1381  
00A005E0                          1382  LAB_1639
00A005E0  4E75                    1383      RTS                     *
00A005E2                          1384  
00A005E2                          1385  
00A005E2                          1386  *************************************************************************************
00A005E2                          1387  *
00A005E2                          1388  * perform END
00A005E2                          1389  
00A005E2                          1390  LAB_END
00A005E2  66FC                    1391      BNE.s       LAB_1639            * exit if something follows STOP
00A005E4  177C 0000 0E40          1392      MOVE.b  #0,Breakf(a3)       * clear break flag, indicate program end
00A005EA                          1393  
00A005EA                          1394  
00A005EA                          1395  *************************************************************************************
00A005EA                          1396  *
00A005EA                          1397  * perform STOP
00A005EA                          1398  
00A005EA                          1399  LAB_STOP
00A005EA  66F4                    1400      BNE.s       LAB_1639            * exit if something follows STOP
00A005EC                          1401  
00A005EC                          1402  LAB_163B
00A005EC  43EB 0DF4               1403      LEA     Ibuffe(a3),a1       * get buffer end
00A005F0  BBC9                    1404      CMPA.l  a1,a5               * compare execute address with buffer end
00A005F2  650A                    1405      BCS.s       LAB_164F            * branch if BASIC pointer is in buffer
00A005F4                          1406                              * can't continue in immediate mode
00A005F4                          1407  
00A005F4                          1408                              * else...
00A005F4  274D 0CBE               1409      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00A005F8                          1410  LAB_1647
00A005F8  276B 0CB6 0CBA          1411      MOVE.l  Clinel(a3),Blinel(a3)   * save break line
00A005FE                          1412  LAB_164F
00A005FE  584F                    1413      ADDQ.w  #4,sp               * dump return address, don't return to execute
00A00600                          1414                              * loop
00A00600  102B 0E40               1415      MOVE.b  Breakf(a3),d0       * get break flag
00A00604  6700 FB9C               1416      BEQ     LAB_1274            * go do warm start if was program end
00A00608                          1417  
00A00608  41FA 2E9F               1418      LEA     LAB_BMSG(pc),a0     * point to "Break"
00A0060C  6000 FB86               1419      BRA     LAB_1269            * print "Break" and do warm start
00A00610                          1420  
00A00610                          1421  
00A00610                          1422  *************************************************************************************
00A00610                          1423  *
00A00610                          1424  * perform RESTORE
00A00610                          1425  
00A00610                          1426  LAB_RESTORE
00A00610  206B 0C92               1427      MOVEA.l Smeml(a3),a0        * copy start of memory
00A00614  6720                    1428      BEQ.s       LAB_1624            * branch if next character null (RESTORE)
00A00616                          1429  
00A00616  6100 01F0               1430      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00A0061A  B2AB 0CB6               1431      CMP.l       Clinel(a3),d1       * compare current line # with required line #
00A0061E  630E                    1432      BLS.s       LAB_GSCH            * branch if >= (start search from beginning)
00A00620                          1433  
00A00620  204D                    1434      MOVEA.l a5,a0               * copy BASIC execute pointer
00A00622                          1435  LAB_RESs
00A00622  4A18                    1436      TST.b       (a0)+               * test next byte & increment pointer
00A00624  66FC                    1437      BNE.s       LAB_RESs            * loop if not EOL
00A00626                          1438  
00A00626  3008                    1439      MOVE.w  a0,d0               * copy pointer
00A00628  C07C 0001               1440      AND.w       #1,d0               * mask odd bit
00A0062C  D0C0                    1441      ADD.w       d0,a0               * add pointer
00A0062E                          1442                              * search for line in Itemp from (a0)
00A0062E                          1443  LAB_GSCH
00A0062E  6100 FDCA               1444      BSR     LAB_SCLN            * search for d1 line number from a0
00A00632                          1445                              * returns Cb=0 if found
00A00632  6500 FB26               1446      BCS     LAB_USER            * go do "Undefined statement" error if not found
00A00636                          1447  
00A00636                          1448  LAB_1624
00A00636  4A20                    1449      TST.b       -(a0)               * decrement pointer (faster)
00A00638  2748 0CC6               1450      MOVE.l  a0,Dptrl(a3)        * save DATA pointer
00A0063C                          1451  RTS_006
00A0063C  4E75                    1452      RTS
00A0063E                          1453  
00A0063E                          1454  
00A0063E                          1455  *************************************************************************************
00A0063E                          1456  *
00A0063E                          1457  * perform NULL
00A0063E                          1458  
00A0063E                          1459  LAB_NULL
00A0063E  6100 10DA               1460      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00A00642  1740 0E48               1461      MOVE.b  d0,Nullct(a3)       * save new NULL count
00A00646  4E75                    1462      RTS
00A00648                          1463  
00A00648                          1464  
00A00648                          1465  *************************************************************************************
00A00648                          1466  *
00A00648                          1467  * perform CONT
00A00648                          1468  
00A00648                          1469  LAB_CONT
00A00648  6600 FB28               1470      BNE     LAB_SNER            * if following byte exit to do syntax error
00A0064C                          1471  
00A0064C  4A2B 0CB6               1472      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00A00650  6A00 FAE8               1473      BPL     LAB_CCER            * if running go do can't continue error
00A00654                          1474  
00A00654  202B 0CBE               1475      MOVE.l  Cpntrl(a3),d0       * get continue pointer
00A00658  6700 FAE0               1476      BEQ     LAB_CCER            * go do can't continue error if we can't
00A0065C                          1477  
00A0065C                          1478                              * we can continue so ...
00A0065C  2A40                    1479      MOVEA.l d0,a5               * save continue pointer as BASIC execute pointer
00A0065E  276B 0CBA 0CB6          1480      MOVE.l  Blinel(a3),Clinel(a3)   * set break line as current line
00A00664  4E75                    1481      RTS
00A00666                          1482  
00A00666                          1483  
00A00666                          1484  *************************************************************************************
00A00666                          1485  *
00A00666                          1486  * perform RUN
00A00666                          1487  
00A00666                          1488  LAB_RUN
00A00666  660C                    1489      BNE.s       LAB_RUNn            * if following byte do RUN n
00A00668                          1490  
00A00668  6100 FDB0               1491      BSR     LAB_1477            * execution to start, clear vars & flush stack
00A0066C  274D 0CBE               1492      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00A00670  6000 FF22               1493      BRA     LAB_15C2            * go do interpreter inner loop
00A00674                          1494                              * (can't RTS, we flushed the stack!)
00A00674                          1495  
00A00674                          1496  LAB_RUNn
00A00674  6100 FDAA               1497      BSR     LAB_147A            * go do "CLEAR"
00A00678  601C                    1498      BRA.s       LAB_16B0            * get n and do GOTO n
00A0067A                          1499  
00A0067A                          1500  
00A0067A                          1501  *************************************************************************************
00A0067A                          1502  *
00A0067A                          1503  * perform DO
00A0067A                          1504  
00A0067A                          1505  LAB_DO
00A0067A                          1506  *   MOVE.l  #$05,d0         * need 5 bytes for DO
00A0067A                          1507  *   BSR.s       LAB_1212            * check room on stack for A bytes
00A0067A  2F0D                    1508      MOVE.l  a5,-(sp)            * push BASIC execute pointer on stack
00A0067C  2F2B 0CB6               1509      MOVE.l  Clinel(a3),-(sp)        * push current line on stack
00A00680  3F3C 009C               1510      MOVE.w  #TK_DO,-(sp)        * push token for DO on stack
00A00684  487A FF0E               1511      PEA     LAB_15C2(pc)        * set return address
00A00688  6000 0728               1512      BRA     LAB_GBYT            * scan memory & return to interpreter inner loop
00A0068C                          1513  
00A0068C                          1514  
00A0068C                          1515  *************************************************************************************
00A0068C                          1516  *
00A0068C                          1517  * perform GOSUB
00A0068C                          1518  
00A0068C                          1519  LAB_GOSUB
00A0068C                          1520  *   MOVE.l  #10,d0          * need 10 bytes for GOSUB
00A0068C                          1521  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00A0068C  2F0D                    1522      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00A0068E  2F2B 0CB6               1523      MOVE.l  Clinel(a3),-(sp)        * push current line
00A00692  3F3C 008D               1524      MOVE.w  #TK_GOSUB,-(sp)     * push token for GOSUB
00A00696                          1525  LAB_16B0
00A00696  6100 071A               1526      BSR     LAB_GBYT            * scan memory
00A0069A  487A FEF8               1527      PEA     LAB_15C2(pc)        * return to interpreter inner loop after GOTO n
00A0069E                          1528  
00A0069E                          1529  * this PEA is needed because either we just cleared the stack and have nowhere to return
00A0069E                          1530  * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00A0069E                          1531  * we whould have returned to is buried. This burried return address will be unstacked by
00A0069E                          1532  * the corresponding RETURN command
00A0069E                          1533  
00A0069E                          1534  
00A0069E                          1535  *************************************************************************************
00A0069E                          1536  *
00A0069E                          1537  * perform GOTO
00A0069E                          1538  
00A0069E                          1539  LAB_GOTO
00A0069E  6100 0168               1540      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00A006A2  206B 0C92               1541      MOVEA.l Smeml(a3),a0        * get start of memory
00A006A6  B2AB 0CB6               1542      CMP.l       Clinel(a3),d1       * compare current line with wanted #
00A006AA  630E                    1543      BLS.s       LAB_16D0            * branch if current # => wanted #
00A006AC                          1544  
00A006AC  204D                    1545      MOVEA.l a5,a0               * copy BASIC execute pointer
00A006AE                          1546  LAB_GOTs
00A006AE  4A18                    1547      TST.b       (a0)+               * test next byte & increment pointer
00A006B0  66FC                    1548      BNE.s       LAB_GOTs            * loop if not EOL
00A006B2                          1549  
00A006B2  3008                    1550      MOVE.w  a0,d0               * past pad byte(s)
00A006B4  C07C 0001               1551      AND.w       #1,d0               * mask odd bit
00A006B8  D0C0                    1552      ADD.w       d0,a0               * add to pointer
00A006BA                          1553  
00A006BA                          1554  LAB_16D0
00A006BA  6100 FD3E               1555      BSR     LAB_SCLN            * search for d1 line number from a0
00A006BE                          1556                              * returns Cb=0 if found
00A006BE  6500 FA9A               1557      BCS     LAB_USER            * if carry set go do "Undefined statement" error
00A006C2                          1558  
00A006C2  2A48                    1559      MOVEA.l a0,a5               * copy to basic execute pointer
00A006C4  534D                    1560      SUBQ.w  #1,a5               * decrement pointer
00A006C6  274D 0CBE               1561      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00A006CA  4E75                    1562      RTS
00A006CC                          1563  
00A006CC                          1564  
00A006CC                          1565  *************************************************************************************
00A006CC                          1566  *
00A006CC                          1567  * perform LOOP
00A006CC                          1568  
00A006CC                          1569  LAB_LOOP
00A006CC  0C6F 009C 0004          1570      CMP.w       #TK_DO,4(sp)        * compare token on stack with DO token
00A006D2  6600 FA5E               1571      BNE     LAB_LDER            * branch if no matching DO
00A006D6                          1572  
00A006D6  1E00                    1573      MOVE.b  d0,d7               * copy following token (byte)
00A006D8  672E                    1574      BEQ.s       LoopAlways          * if no following token loop forever
00A006DA                          1575  
00A006DA  BE3C 003A               1576      CMP.b       #':',d7         * compare with ":"
00A006DE  6728                    1577      BEQ.s       LoopAlways          * if no following token loop forever
00A006E0                          1578  
00A006E0  0407 00B0               1579      SUB.b       #TK_UNTIL,d7        * subtract token for UNTIL
00A006E4  6708                    1580      BEQ.s       DoRest          * branch if was UNTIL
00A006E6                          1581  
00A006E6  5307                    1582      SUBQ.b  #1,d7               * decrement result
00A006E8  6600 FA88               1583      BNE     LAB_SNER            * if not WHILE go do syntax error & warm start
00A006EC                          1584                              * only if the token was WHILE will this fail
00A006EC                          1585  
00A006EC  7EFF                    1586      MOVEQ       #-1,d7          * set invert result longword
00A006EE                          1587  DoRest
00A006EE  6100 06C0               1588      BSR     LAB_IGBY            * increment & scan memory
00A006F2  6100 055C               1589      BSR     LAB_EVEX            * evaluate expression
00A006F6  4A2B 0DF8               1590      TST.b       FAC1_e(a3)          * test FAC1 exponent
00A006FA  6706                    1591      BEQ.s       DoCmp               * if = 0 go do straight compare
00A006FC                          1592  
00A006FC  177C 00FF 0DF8          1593      MOVE.b  #$FF,FAC1_e(a3)     * else set all bits
00A00702                          1594  DoCmp
00A00702  BF2B 0DF8               1595      EOR.b       d7,FAC1_e(a3)       * EOR with invert byte
00A00706  6614                    1596      BNE.s       LoopDone            * if <> 0 clear stack & back to interpreter loop
00A00708                          1597  
00A00708                          1598                              * loop condition wasn't met so do it again
00A00708                          1599  LoopAlways
00A00708  276F 0006 0CB6          1600      MOVE.l  6(sp),Clinel(a3)        * copy DO current line
00A0070E  2A6F 000A               1601      MOVE.l  10(sp),a5           * save BASIC execute pointer
00A00712                          1602  
00A00712  41FA FE80               1603      LEA     LAB_15C2(pc),a0     * get return address
00A00716  2E88                    1604      MOVE.l  a0,(sp)         * dump the call to this routine and set the
00A00718                          1605                              * return address
00A00718  6000 0698               1606      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00A0071C                          1607                              * loop
00A0071C                          1608  
00A0071C                          1609                              * clear stack & back to interpreter loop
00A0071C                          1610  LoopDone
00A0071C  4FEF 000E               1611      LEA     14(sp),sp           * dump structure and call from stack
00A00720  6014                    1612      BRA.s       LAB_DATA            * go perform DATA (find : or [EOL])
00A00722                          1613  
00A00722                          1614  
00A00722                          1615  *************************************************************************************
00A00722                          1616  *
00A00722                          1617  * perform RETURN
00A00722                          1618  
00A00722                          1619  LAB_RETURN
00A00722  6616                    1620      BNE.s       RTS_007         * exit if following token to allow syntax error
00A00724                          1621  
00A00724  0C6F 008D 0004          1622      CMP.w       #TK_GOSUB,4(sp)     * compare token from stack with GOSUB
00A0072A  6600 FA42               1623      BNE     LAB_RGER            * do RETURN without GOSUB error if no matching
00A0072E                          1624                              * GOSUB
00A0072E                          1625  
00A0072E  5C4F                    1626      ADDQ.w  #6,sp               * dump calling address & token
00A00730  275F 0CB6               1627      MOVE.l  (sp)+,Clinel(a3)        * pull current line
00A00734  2A5F                    1628      MOVE.l  (sp)+,a5            * pull BASIC execute pointer
00A00736                          1629                              * now do perform "DATA" statement as we could be
00A00736                          1630                              * returning into the middle of an ON <var> GOSUB
00A00736                          1631                              * n,m,p,q line (the return address used by the
00A00736                          1632                              * DATA statement is the one pushed before the
00A00736                          1633                              * GOSUB was executed!)
00A00736                          1634  
00A00736                          1635  
00A00736                          1636  *************************************************************************************
00A00736                          1637  *
00A00736                          1638  * perform DATA
00A00736                          1639  
00A00736                          1640  LAB_DATA
00A00736  6104                    1641      BSR.s       LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00A00738                          1642                              * returns a0 as pointer to [:] or [EOL]
00A00738  2A48                    1643      MOVEA.l a0,a5               * skip rest of statement
00A0073A                          1644  RTS_007
00A0073A  4E75                    1645      RTS
00A0073C                          1646  
00A0073C                          1647  
00A0073C                          1648  *************************************************************************************
00A0073C                          1649  *
00A0073C                          1650  * scan for next BASIC statement ([:] or [EOL])
00A0073C                          1651  * returns a0 as pointer to [:] or [EOL]
00A0073C                          1652  
00A0073C                          1653  LAB_SNBS
00A0073C  204D                    1654      MOVEA.l a5,a0               * copy BASIC execute pointer
00A0073E  7222                    1655      MOVEQ       #$22,d1         * set string quote character
00A00740  743A                    1656      MOVEQ       #$3A,d2         * set look for character = ":"
00A00742  6008                    1657      BRA.s       LAB_172D            * go do search
00A00744                          1658  
00A00744                          1659  LAB_172C
00A00744  B400                    1660      CMP.b       d0,d2               * compare with ":"
00A00746  6708                    1661      BEQ.s       RTS_007a            * exit if found
00A00748                          1662  
00A00748  B200                    1663      CMP.b       d0,d1               * compare with '"'
00A0074A  670C                    1664      BEQ.s       LAB_1725            * if found go search for [EOL]
00A0074C                          1665  
00A0074C                          1666  LAB_172D
00A0074C  1018                    1667      MOVE.b  (a0)+,d0            * get next byte
00A0074E  66F4                    1668      BNE.s       LAB_172C            * loop if not null [EOL]
00A00750                          1669  
00A00750                          1670  RTS_007a
00A00750  5348                    1671      SUBQ.w  #1,a0               * correct pointer
00A00752  4E75                    1672      RTS
00A00754                          1673  
00A00754                          1674  LAB_1723
00A00754  B200                    1675      CMP.b       d0,d1               * compare with '"'
00A00756  67F4                    1676      BEQ.s       LAB_172D            * if found go search for ":" or [EOL]
00A00758                          1677  
00A00758                          1678  LAB_1725
00A00758  1018                    1679      MOVE.b  (a0)+,d0            * get next byte
00A0075A  66F8                    1680      BNE.s       LAB_1723            * loop if not null [EOL]
00A0075C                          1681  
00A0075C  60F2                    1682      BRA.s       RTS_007a            * correct pointer & return
00A0075E                          1683  
00A0075E                          1684  
00A0075E                          1685  *************************************************************************************
00A0075E                          1686  *
00A0075E                          1687  * perform IF
00A0075E                          1688  
00A0075E                          1689  LAB_IF
00A0075E  6100 04F0               1690      BSR     LAB_EVEX            * evaluate expression
00A00762  6100 064E               1691      BSR     LAB_GBYT            * scan memory
00A00766  B03C 00AD               1692      CMP.b       #TK_THEN,d0         * compare with THEN token
00A0076A  6714                    1693      BEQ.s       LAB_174B            * if it was THEN then continue
00A0076C                          1694  
00A0076C                          1695                              * wasn't IF .. THEN so must be IF .. GOTO
00A0076C  B03C 0089               1696      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00A00770  6600 FA00               1697      BNE     LAB_SNER            * if not GOTO token do syntax error/warm start
00A00774                          1698  
00A00774                          1699                              * was GOTO so check for GOTO <n>
00A00774  204D                    1700      MOVE.l  a5,a0               * save the execute pointer
00A00776  6100 0638               1701      BSR     LAB_IGBY            * scan memory, test for a numeric character
00A0077A  2A48                    1702      MOVE.l  a0,a5               * restore the execute pointer
00A0077C  6400 F9F4               1703      BCC     LAB_SNER            * if not numeric do syntax error/warm start
00A00780                          1704  
00A00780                          1705  LAB_174B
00A00780  102B 0DF8               1706      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A00784  671E                    1707      BEQ.s       LAB_174E            * if result was zero go look for an ELSE
00A00786                          1708  
00A00786  6100 0628               1709      BSR     LAB_IGBY            * increment & scan memory
00A0078A  6500 FF12               1710      BCS     LAB_GOTO            * if numeric do GOTO n
00A0078E                          1711                              * a GOTO <n> will never return to the IF
00A0078E                          1712                              * statement so there is no need to return
00A0078E                          1713                              * to this code
00A0078E                          1714  
00A0078E  B03C 008E               1715      CMP.b       #TK_RETURN,d0       * compare with RETURN token
00A00792  6700 FE1E               1716      BEQ     LAB_1602            * if RETURN then interpret BASIC code from (a5)
00A00796                          1717                              * and don't return here
00A00796                          1718  
00A00796  6100 FE16               1719      BSR     LAB_15FF            * else interpret BASIC code from (a5)
00A0079A                          1720  
00A0079A                          1721  * the IF was executed and there may be a following ELSE so the code needs to return
00A0079A                          1722  * here to check and ignore the ELSE if present
00A0079A                          1723  
00A0079A  1015                    1724      MOVE.b  (a5),d0         * get the next basic byte
00A0079C  B03C 00A9               1725      CMP.b       #TK_ELSE,d0         * compare it with the token for ELSE
00A007A0  6794                    1726      BEQ     LAB_DATA            * if ELSE ignore the following statement
00A007A2                          1727  
00A007A2                          1728  * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00A007A2                          1729  * following ELSE will, correctly, cause a syntax error
00A007A2                          1730  
00A007A2  4E75                    1731      RTS                     * else return to interpreter inner loop
00A007A4                          1732  
00A007A4                          1733  * perform ELSE after IF
00A007A4                          1734  
00A007A4                          1735  LAB_174E
00A007A4  101D                    1736      MOVE.b  (a5)+,d0            * faster increment past THEN
00A007A6  76A9                    1737      MOVEQ       #TK_ELSE,d3         * set search for ELSE token
00A007A8  788B                    1738      MOVEQ       #TK_IF,d4           * set search for IF token
00A007AA  7A00                    1739      MOVEQ       #0,d5               * clear the nesting depth
00A007AC                          1740  LAB_1750
00A007AC  101D                    1741      MOVE.b  (a5)+,d0            * get next BASIC byte & increment ptr
00A007AE  6720                    1742      BEQ.s       LAB_1754            * if EOL correct the pointer and return
00A007B0                          1743  
00A007B0  B004                    1744      CMP.b       d4,d0               * compare with "IF" token
00A007B2  6604                    1745      BNE.s       LAB_1752            * skip if not nested IF
00A007B4                          1746  
00A007B4  5245                    1747      ADDQ.w  #1,d5               * else increment the nesting depth ..
00A007B6  60F4                    1748      BRA.s       LAB_1750            * .. and continue looking
00A007B8                          1749  
00A007B8                          1750  LAB_1752
00A007B8  B003                    1751      CMP.b       d3,d0               * compare with ELSE token
00A007BA  66F0                    1752      BNE.s       LAB_1750            * if not ELSE continue looking
00A007BC                          1753  
00A007BC                          1754  LAB_1756
00A007BC  51CD FFEE               1755      DBF     d5,LAB_1750         * loop if still nested
00A007C0                          1756  
00A007C0                          1757  * found the matching ELSE, now do <{n|statement}>
00A007C0                          1758  
00A007C0  6100 05F0               1759      BSR     LAB_GBYT            * scan memory
00A007C4  6500 FED8               1760      BCS     LAB_GOTO            * if numeric do GOTO n
00A007C8                          1761                              * code will return to the interpreter loop
00A007C8                          1762                              * at the tail end of the GOTO <n>
00A007C8                          1763  
00A007C8  6000 FDE4               1764      BRA     LAB_15FF            * else interpret BASIC code from (a5)
00A007CC                          1765                              * code will return to the interpreter loop
00A007CC                          1766                              * at the tail end of the <statement>
00A007CC                          1767  
00A007CC                          1768  
00A007CC                          1769  *************************************************************************************
00A007CC                          1770  *
00A007CC                          1771  * perform REM, skip (rest of) line
00A007CC                          1772  
00A007CC                          1773  LAB_REM
00A007CC  4A1D                    1774      TST.b       (a5)+               * test byte & increment pointer
00A007CE  66FC                    1775      BNE.s       LAB_REM         * loop if not EOL
00A007D0                          1776  
00A007D0                          1777  LAB_1754
00A007D0  534D                    1778      SUBQ.w  #1,a5               * correct the execute pointer
00A007D2  4E75                    1779      RTS
00A007D4                          1780  
00A007D4                          1781  
00A007D4                          1782  *************************************************************************************
00A007D4                          1783  *
00A007D4                          1784  * perform ON
00A007D4                          1785  
00A007D4                          1786  LAB_ON
00A007D4  6100 0F44               1787      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00A007D8  1400                    1788      MOVE.b  d0,d2               * copy byte
00A007DA  6100 05D6               1789      BSR     LAB_GBYT            * restore BASIC byte
00A007DE  3F00                    1790      MOVE.w  d0,-(sp)            * push GOTO/GOSUB token
00A007E0  B03C 008D               1791      CMP.b       #TK_GOSUB,d0        * compare with GOSUB token
00A007E4  6708                    1792      BEQ.s       LAB_176C            * branch if GOSUB
00A007E6                          1793  
00A007E6  B03C 0089               1794      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00A007EA  6600 F986               1795      BNE     LAB_SNER            * if not GOTO do syntax error, then warm start
00A007EE                          1796  
00A007EE                          1797  * next character was GOTO or GOSUB
00A007EE                          1798  
00A007EE                          1799  LAB_176C
00A007EE  5302                    1800      SUBQ.b  #1,d2               * decrement index (byte value)
00A007F0  6606                    1801      BNE.s       LAB_1773            * branch if not zero
00A007F2                          1802  
00A007F2  301F                    1803      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token
00A007F4  6000 FDBC               1804      BRA     LAB_1602            * go execute it
00A007F8                          1805  
00A007F8                          1806  LAB_1773
00A007F8  6100 05B6               1807      BSR     LAB_IGBY            * increment & scan memory
00A007FC  610A                    1808      BSR.s       LAB_GFPN            * get fixed-point number into temp integer & d1
00A007FE                          1809                              * (skip this n)
00A007FE  B03C 002C               1810      CMP.b       #$2C,d0         * compare next character with ","
00A00802  67EA                    1811      BEQ.s       LAB_176C            * loop if ","
00A00804                          1812  
00A00804  301F                    1813      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token (run out of options)
00A00806  4E75                    1814      RTS                     * and exit
00A00808                          1815  
00A00808                          1816  
00A00808                          1817  *************************************************************************************
00A00808                          1818  *
00A00808                          1819  * get fixed-point number into temp integer & d1
00A00808                          1820  * interpret number from (a5), leave (a5) pointing to byte after #
00A00808                          1821  
00A00808                          1822  LAB_GFPN
00A00808  7200                    1823      MOVEQ       #$00,d1         * clear integer register
00A0080A  2001                    1824      MOVE.l  d1,d0               * clear d0
00A0080C  6100 05A4               1825      BSR     LAB_GBYT            * scan memory, Cb=1 if "0"-"9", & get byte
00A00810  642E                    1826      BCC.s       LAB_1786            * return if carry clear, chr was not "0"-"9"
00A00812                          1827  
00A00812  2F02                    1828      MOVE.l  d2,-(sp)            * save d2
00A00814                          1829  LAB_1785
00A00814  2401                    1830      MOVE.l  d1,d2               * copy integer register
00A00816  D281                    1831      ADD.l       d1,d1               * *2
00A00818  6500 F958               1832      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00A0081C                          1833  
00A0081C  D281                    1834      ADD.l       d1,d1               * *4
00A0081E  6500 F952               1835      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00A00822                          1836  
00A00822  D282                    1837      ADD.l       d2,d1               * *1 + *4
00A00824  6500 F94C               1838      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00A00828                          1839  
00A00828  D281                    1840      ADD.l       d1,d1               * *10
00A0082A  6500 F946               1841      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00A0082E                          1842  
00A0082E  0400 0030               1843      SUB.b       #$30,d0         * subtract $30 from byte
00A00832  D280                    1844      ADD.l       d0,d1               * add to integer register, the top 24 bits are
00A00834                          1845                              * always clear
00A00834  6900 F93C               1846      BVS     LAB_SNER            * if overflow do syntax error, then warm start
00A00838                          1847                              * this makes the maximum line number 2147483647
00A00838  6100 0576               1848      BSR     LAB_IGBY            * increment & scan memory
00A0083C  65D6                    1849      BCS.s       LAB_1785            * loop for next character if "0"-"9"
00A0083E                          1850  
00A0083E  241F                    1851      MOVE.l  (sp)+,d2            * restore d2
00A00840                          1852  LAB_1786
00A00840  2741 0C8E               1853      MOVE.l  d1,Itemp(a3)        * save Itemp
00A00844  4E75                    1854      RTS
00A00846                          1855  
00A00846                          1856  
00A00846                          1857  *************************************************************************************
00A00846                          1858  *
00A00846                          1859  * perform DEC
00A00846                          1860  
00A00846                          1861  LAB_DEC
00A00846  3F3C 8180               1862      MOVE.w  #$8180,-(sp)        * set -1 sign/exponent
00A0084A  600A                    1863      BRA.s       LAB_17B7            * go do DEC
00A0084C                          1864  
00A0084C                          1865  
00A0084C                          1866  *************************************************************************************
00A0084C                          1867  *
00A0084C                          1868  * perform INC
00A0084C                          1869  
00A0084C                          1870  LAB_INC
00A0084C  3F3C 8100               1871      MOVE.w  #$8100,-(sp)        * set 1 sign/exponent
00A00850  6004                    1872      BRA.s       LAB_17B7            * go do INC
00A00852                          1873  
00A00852                          1874                              * was "," so another INCR variable to do
00A00852                          1875  LAB_17B8
00A00852  6100 055C               1876      BSR     LAB_IGBY            * increment and scan memory
00A00856                          1877  LAB_17B7
00A00856  6100 0768               1878      BSR     LAB_GVAR            * get variable address in a0
00A0085A                          1879  
00A0085A                          1880  * if you want a non existant variable to return a null value then set the novar
00A0085A                          1881  * value at the top of this file to some non zero value
00A0085A                          1882  
00A0085A                 FALSE    1883   ifne   novar
00A0085A                          1884   endc
00A0085A                          1885  
00A0085A  4A2B 0E19               1886      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A0085E                          1887                              * $00=float
00A0085E  6B00 F8E6               1888      BMI     LAB_TMER            * if string do "Type mismatch" error/warm start
00A00862                          1889  
00A00862  6636                    1890      BNE.s       LAB_INCI            * go do integer INC/DEC
00A00864                          1891  
00A00864  2748 0CD6               1892      MOVE.l  a0,Lvarpl(a3)       * save var address
00A00868  6100 130A               1893      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00A0086C  277C 80000000 0DFC      1894      MOVE.l  #$80000000,FAC2_m(a3)   * set FAC2 mantissa for 1
00A00874  3017                    1895      MOVE.w  (sp),d0         * move exponent & sign to d0
00A00876  3740 0E00               1896      MOVE.w  d0,FAC2_e(a3)       * move exponent & sign to FAC2
00A0087A  176B 0DF9 0E02          1897      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00A00880  B12B 0E02               1898      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00A00884  6100 100A               1899      BSR     LAB_ADD         * add FAC2 to FAC1
00A00888  6100 1306               1900      BSR     LAB_PFAC            * pack FAC1 into variable (Lvarpl)
00A0088C                          1901  LAB_INCT
00A0088C  6100 0524               1902      BSR     LAB_GBYT            * scan memory
00A00890  0C00 002C               1903      CMPI.b  #$2C,d0         * compare with ","
00A00894  67BC                    1904      BEQ.s       LAB_17B8            * continue if "," (another variable to do)
00A00896                          1905  
00A00896  544F                    1906      ADDQ.w  #2,sp               * else dump sign & exponent
00A00898  4E75                    1907      RTS
00A0089A                          1908  
00A0089A                          1909  LAB_INCI
00A0089A  4A2F 0001               1910      TST.b       1(sp)               * test sign
00A0089E  6604                    1911      BNE.s       LAB_DECI            * branch if DEC
00A008A0                          1912  
00A008A0  5290                    1913      ADDQ.l  #1,(a0)         * increment variable
00A008A2  60E8                    1914      BRA.s       LAB_INCT            * go scan for more
00A008A4                          1915  
00A008A4                          1916  LAB_DECI
00A008A4  5390                    1917      SUBQ.l  #1,(a0)         * decrement variable
00A008A6  60E4                    1918      BRA.s       LAB_INCT            * go scan for more
00A008A8                          1919  
00A008A8                          1920  
00A008A8                          1921  *************************************************************************************
00A008A8                          1922  *
00A008A8                          1923  * perform LET
00A008A8                          1924  
00A008A8                          1925  LAB_LET
00A008A8  6100 0712               1926      BSR     LAB_SVAR            * search for or create a variable
00A008AC                          1927                              * return the variable address in a0
00A008AC  2748 0CD6               1928      MOVE.l  a0,Lvarpl(a3)       * save variable address
00A008B0  1F2B 0E19               1929      MOVE.b  Dtypef(a3),-(sp)        * push var data type, $80=string, $40=integer,
00A008B4                          1930                              * $00=float
00A008B4  70BD                    1931      MOVEQ       #TK_EQUAL-$100,d0       * get = token
00A008B6  6100 04F0               1932      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00A008BA                          1933                              * start
00A008BA  6100 0394               1934      BSR     LAB_EVEX            * evaluate expression
00A008BE  102B 0E19               1935      MOVE.b  Dtypef(a3),d0       * copy expression data type
00A008C2  175F 0E19               1936      MOVE.b  (sp)+,Dtypef(a3)        * pop variable data type
00A008C6  E318                    1937      ROL.b       #1,d0               * set carry if expression type = string
00A008C8  6100 0372               1938      BSR     LAB_CKTM            * type match check, set C for string
00A008CC  6700 12C2               1939      BEQ     LAB_PFAC            * if number pack FAC1 into variable Lvarpl & RET
00A008D0                          1940  
00A008D0                          1941  * string LET
00A008D0                          1942  
00A008D0                          1943  LAB_17D5
00A008D0  246B 0CD6               1944      MOVEA.l Lvarpl(a3),a2       * get pointer to variable
00A008D4                          1945  LAB_17D6
00A008D4  206B 0DF4               1946      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00A008D8  2250                    1947      MOVEA.l (a0),a1         * get string pointer
00A008DA  B3EB 0CAA               1948      CMP.l       Sstorl(a3),a1       * compare string memory start with string
00A008DE                          1949                              * pointer
00A008DE  6516                    1950      BCS.s       LAB_1811            * if it was in program memory assign the value
00A008E0                          1951                              * and exit
00A008E0                          1952  
00A008E0  B1EB 0C96               1953      CMPA.l  Sfncl(a3),a0        * compare functions start with descriptor
00A008E4                          1954                              * pointer
00A008E4  6510                    1955      BCS.s       LAB_1811            * branch if >= (string is on stack)
00A008E6                          1956  
00A008E6                          1957                              * string is variable$ make space and copy string
00A008E6                          1958  LAB_1810
00A008E6  7200                    1959      MOVEQ       #0,d1               * clear length
00A008E8  3228 0004               1960      MOVE.w  4(a0),d1            * get string length
00A008EC  2050                    1961      MOVEA.l (a0),a0         * get string pointer
00A008EE  6100 0B04               1962      BSR     LAB_20C9            * copy string
00A008F2  206B 0DF4               1963      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer back
00A008F6                          1964                              * clean stack & assign value to string variable
00A008F6                          1965  LAB_1811
00A008F6  B9C8                    1966      CMPA.l  a0,a4               * is string on the descriptor stack
00A008F8  6602                    1967      BNE.s       LAB_1813            * skip pop if not
00A008FA                          1968  
00A008FA  5C4C                    1969      ADDQ.w  #$06,a4         * else update stack pointer
00A008FC                          1970  LAB_1813
00A008FC  24D8                    1971      MOVE.l  (a0)+,(a2)+         * save pointer to variable
00A008FE  3490                    1972      MOVE.w  (a0),(a2)           * save length to variable
00A00900                          1973  RTS_008
00A00900  4E75                    1974      RTS
00A00902                          1975  
00A00902                          1976  
00A00902                          1977  *************************************************************************************
00A00902                          1978  *
00A00902                          1979  * perform GET
00A00902                          1980  
00A00902                          1981  LAB_GET
00A00902  6100 06B8               1982      BSR     LAB_SVAR            * search for or create a variable
00A00906                          1983                              * return the variable address in a0
00A00906  2748 0CD6               1984      MOVE.l  a0,Lvarpl(a3)       * save variable address as GET variable
00A0090A  4A2B 0E19               1985      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A0090E                          1986                              * $00=float
00A0090E  6B0C                    1987      BMI.s       LAB_GETS            * go get string character
00A00910                          1988  
00A00910                          1989                              * was numeric get
00A00910  6100 1DE4               1990      BSR     INGET               * get input byte
00A00914  6100 09BA               1991      BSR     LAB_1FD0            * convert d0 to unsigned byte in FAC1
00A00918  6000 1276               1992      BRA     LAB_PFAC            * pack FAC1 into variable (Lvarpl) & return
00A0091C                          1993  
00A0091C                          1994  LAB_GETS
00A0091C  7200                    1995      MOVEQ       #$00,d1         * assume no byte
00A0091E  2041                    1996      MOVE.l  d1,a0               * assume null string
00A00920  6100 1DD4               1997      BSR     INGET               * get input byte
00A00924  6408                    1998      BCC.s       LAB_NoSt            * branch if no byte received
00A00926                          1999  
00A00926  7201                    2000      MOVEQ       #$01,d1         * string is single byte
00A00928  6100 0AFC               2001      BSR     LAB_2115            * make string space d1 bytes long
00A0092C                          2002                              * return a0 = pointer, other registers unchanged
00A0092C                          2003  
00A0092C  1080                    2004      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00A0092E                          2005  LAB_NoSt
00A0092E  6100 0ADC               2006      BSR     LAB_RTST            * push string on descriptor stack
00A00932                          2007                              * a0 = pointer, d1 = length
00A00932                          2008  
00A00932  609C                    2009      BRA.s       LAB_17D5            * do string LET & return
00A00934                          2010  
00A00934                          2011  
00A00934                          2012  *************************************************************************************
00A00934                          2013  *
00A00934                          2014  * PRINT
00A00934                          2015  
00A00934                          2016  LAB_1829
00A00934  6100 00B4               2017      BSR     LAB_18C6            * print string from stack
00A00938                          2018  LAB_182C
00A00938  6100 0478               2019      BSR     LAB_GBYT            * scan memory
00A0093C                          2020  
00A0093C                          2021  * perform PRINT
00A0093C                          2022  
00A0093C                          2023  LAB_PRINT
00A0093C  674A                    2024      BEQ.s       LAB_CRLF            * if nothing following just print CR/LF
00A0093E                          2025  
00A0093E                          2026  LAB_1831
00A0093E  B03C 00A8               2027      CMP.b       #TK_TAB,d0          * compare with TAB( token
00A00942  6764                    2028      BEQ.s       LAB_18A2            * go do TAB/SPC
00A00944                          2029  
00A00944  B03C 00AC               2030      CMP.b       #TK_SPC,d0          * compare with SPC( token
00A00948  675E                    2031      BEQ.s       LAB_18A2            * go do TAB/SPC
00A0094A                          2032  
00A0094A  B03C 002C               2033      CMP.b       #',',d0         * compare with ","
00A0094E  6740                    2034      BEQ.s       LAB_188B            * go do move to next TAB mark
00A00950                          2035  
00A00950  B03C 003B               2036      CMP.b       #';',d0         * compare with ";"
00A00954  6700 0086               2037      BEQ     LAB_18BD            * if ";" continue with PRINT processing
00A00958                          2038  
00A00958  6100 02F6               2039      BSR     LAB_EVEX            * evaluate expression
00A0095C  4A2B 0E19               2040      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A00960                          2041                              * $00=float
00A00960  6BD2                    2042      BMI.s       LAB_1829            * branch if string
00A00962                          2043  
00A00962                          2044  ** replace the two lines above with this code
00A00962                          2045  
00A00962                          2046  **  MOVE.b  Dtypef(a3),d0       * get data type flag, $80=string, $00=numeric
00A00962                          2047  **  BMI.s       LAB_1829            * branch if string
00A00962                          2048  
00A00962  6100 13AA               2049      BSR     LAB_2970            * convert FAC1 to string
00A00966  6100 0A5E               2050      BSR     LAB_20AE            * print " terminated string to FAC1 stack
00A0096A                          2051  
00A0096A                          2052  * don't check fit if terminal width byte is zero
00A0096A                          2053  
00A0096A  7000                    2054      MOVEQ       #0,d0               * clear d0
00A0096C  102B 0E4A               2055      MOVE.b  TWidth(a3),d0       * get terminal width byte
00A00970  670C                    2056      BEQ.s       LAB_185E            * skip check if zero
00A00972                          2057  
00A00972  902C 0007               2058      SUB.b       7(a4),d0            * subtract string length
00A00976  902B 0E49               2059      SUB.b       TPos(a3),d0         * subtract terminal position
00A0097A  6402                    2060      BCC.s       LAB_185E            * branch if less than terminal width
00A0097C                          2061  
00A0097C  610A                    2062      BSR.s       LAB_CRLF            * else print CR/LF
00A0097E                          2063  LAB_185E
00A0097E  616A                    2064      BSR.s       LAB_18C6            * print string from stack
00A00980  60B6                    2065      BRA.s       LAB_182C            * always go continue processing line
00A00982                          2066  
00A00982                          2067  
00A00982                          2068  *************************************************************************************
00A00982                          2069  *
00A00982                          2070  * CR/LF return to BASIC from BASIC input handler
00A00982                          2071  * leaves a0 pointing to the buffer start
00A00982                          2072  
00A00982                          2073  LAB_1866
00A00982  11BC 0000 1000          2074      MOVE.b  #$00,(a0,d1.w)      * null terminate input
00A00988                          2075  
00A00988                          2076  * print CR/LF
00A00988                          2077  
00A00988                          2078  LAB_CRLF
00A00988  700D                    2079      MOVEQ       #$0D,d0         * load [CR]
00A0098A  6174                    2080      BSR.s       LAB_PRNA            * go print the character
00A0098C  700A                    2081      MOVEQ       #$0A,d0         * load [LF]
00A0098E  6070                    2082      BRA.s       LAB_PRNA            * go print the character & return
00A00990                          2083  
00A00990                          2084  LAB_188B
00A00990  142B 0E49               2085      MOVE.b  TPos(a3),d2         * get terminal position
00A00994  B42B 0E4B               2086      CMP.b       Iclim(a3),d2        * compare with input column limit
00A00998  6504                    2087      BCS.s       LAB_1898            * branch if less than Iclim
00A0099A                          2088  
00A0099A  61EC                    2089      BSR.s       LAB_CRLF            * else print CR/LF (next line)
00A0099C  603E                    2090      BRA.s       LAB_18BD            * continue with PRINT processing
00A0099E                          2091  
00A0099E                          2092  LAB_1898
00A0099E  942B 0E46               2093      SUB.b       TabSiz(a3),d2       * subtract TAB size
00A009A2  64FA                    2094      BCC.s       LAB_1898            * loop if result was >= 0
00A009A4                          2095  
00A009A4  4402                    2096      NEG.b       d2              * twos complement it
00A009A6  6022                    2097      BRA.s       LAB_18B7            * print d2 spaces
00A009A8                          2098  
00A009A8                          2099                              * do TAB/SPC
00A009A8                          2100  LAB_18A2
00A009A8  3F00                    2101      MOVE.w  d0,-(sp)            * save token
00A009AA  6100 0D6A               2102      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00A009AE  3400                    2103      MOVE.w  d0,d2               * copy byte
00A009B0  6100 0400               2104      BSR     LAB_GBYT            * get basic byte back
00A009B4  B03C 0029               2105      CMP.b       #$29,d0         * is next character ")"
00A009B8  6600 F7B8               2106      BNE     LAB_SNER            * if not do syntax error, then warm start
00A009BC                          2107  
00A009BC  301F                    2108      MOVE.w  (sp)+,d0            * get token back
00A009BE  B03C 00A8               2109      CMP.b       #TK_TAB,d0          * was it TAB ?
00A009C2  6606                    2110      BNE.s       LAB_18B7            * branch if not (was SPC)
00A009C4                          2111  
00A009C4                          2112                              * calculate TAB offset
00A009C4  942B 0E49               2113      SUB.b       TPos(a3),d2         * subtract terminal position
00A009C8  6312                    2114      BLS.s       LAB_18BD            * branch if result was <= 0
00A009CA                          2115                              * can't TAB backwards or already there
00A009CA                          2116  
00A009CA                          2117                              * print d2.b spaces
00A009CA                          2118  LAB_18B7
00A009CA  7000                    2119      MOVEQ       #0,d0               * clear longword
00A009CC  5300                    2120      SUBQ.b  #1,d0               * make d0 = $FF
00A009CE  C480                    2121      AND.l       d0,d2               * mask for byte only
00A009D0  670A                    2122      BEQ.s       LAB_18BD            * branch if zero
00A009D2                          2123  
00A009D2  7020                    2124      MOVEQ       #$20,d0         * load " "
00A009D4  5302                    2125      SUBQ.b  #1,d2               * adjust for DBF loop
00A009D6                          2126  LAB_18B8
00A009D6  6128                    2127      BSR.s       LAB_PRNA            * go print
00A009D8  51CA FFFC               2128      DBF     d2,LAB_18B8         * decrement count and loop if not all done
00A009DC                          2129  
00A009DC                          2130                              * continue with PRINT processing
00A009DC                          2131  LAB_18BD
00A009DC  6100 03D2               2132      BSR     LAB_IGBY            * increment & scan memory
00A009E0  6600 FF5C               2133      BNE     LAB_1831            * if byte continue executing PRINT
00A009E4                          2134  
00A009E4  4E75                    2135      RTS                     * exit if nothing more to print
00A009E6                          2136  
00A009E6                          2137  
00A009E6                          2138  *************************************************************************************
00A009E6                          2139  *
00A009E6                          2140  * print null terminated string from a0
00A009E6                          2141  
00A009E6                          2142  LAB_18C3
00A009E6  6100 09DE               2143      BSR     LAB_20AE            * print terminated string to FAC1/stack
00A009EA                          2144  
00A009EA                          2145  * print string from stack
00A009EA                          2146  
00A009EA                          2147  LAB_18C6
00A009EA  6100 0BCE               2148      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00A009EE                          2149                              * returns with d0 = length, a0 = pointer
00A009EE  670C                    2150      BEQ.s       RTS_009         * exit (RTS) if null string
00A009F0                          2151  
00A009F0  3200                    2152      MOVE.w  d0,d1               * copy length & set Z flag
00A009F2  5341                    2153      SUBQ.w  #1,d1               * -1 for BF loop
00A009F4                          2154  LAB_18CD
00A009F4  1018                    2155      MOVE.b  (a0)+,d0            * get byte from string
00A009F6  6108                    2156      BSR.s       LAB_PRNA            * go print the character
00A009F8  51C9 FFFA               2157      DBF     d1,LAB_18CD         * decrement count and loop if not done yet
00A009FC                          2158  
00A009FC                          2159  RTS_009
00A009FC  4E75                    2160      RTS
00A009FE                          2161  
00A009FE                          2162  
00A009FE                          2163  *************************************************************************************
00A009FE                          2164  *
00A009FE                          2165  * print "?" character
00A009FE                          2166  
00A009FE                          2167  LAB_18E3
00A009FE  703F                    2168      MOVEQ       #$3F,d0         * load "?" character
00A00A00                          2169  
00A00A00                          2170  
00A00A00                          2171  *************************************************************************************
00A00A00                          2172  *
00A00A00                          2173  * print character in d0, includes the null handler and infinite line length code
00A00A00                          2174  * changes no registers
00A00A00                          2175  
00A00A00                          2176  LAB_PRNA
00A00A00  2F01                    2177      MOVE.l  d1,-(sp)            * save d1
00A00A02  B03C 0020               2178      CMP.b       #$20,d0         * compare with " "
00A00A06  6528                    2179      BCS.s       LAB_18F9            * branch if less, non printing character
00A00A08                          2180  
00A00A08                          2181                              * don't check fit if terminal width byte is zero
00A00A08  122B 0E4A               2182      MOVE.b  TWidth(a3),d1       * get terminal width
00A00A0C  6610                    2183      BNE.s       LAB_18F0            * branch if not zero (not infinite length)
00A00A0E                          2184  
00A00A0E                          2185                              * is "infinite line" so check TAB position
00A00A0E  122B 0E49               2186      MOVE.b  TPos(a3),d1         * get position
00A00A12  922B 0E46               2187      SUB.b       TabSiz(a3),d1       * subtract TAB size
00A00A16  6614                    2188      BNE.s       LAB_18F7            * skip reset if different
00A00A18                          2189  
00A00A18  1741 0E49               2190      MOVE.b  d1,TPos(a3)         * else reset position
00A00A1C  600E                    2191      BRA.s       LAB_18F7            * go print character
00A00A1E                          2192  
00A00A1E                          2193  LAB_18F0
00A00A1E  B22B 0E49               2194      CMP.b       TPos(a3),d1         * compare with terminal character position
00A00A22  6608                    2195      BNE.s       LAB_18F7            * branch if not at end of line
00A00A24                          2196  
00A00A24  2F00                    2197      MOVE.l  d0,-(sp)            * save d0
00A00A26  6100 FF60               2198      BSR     LAB_CRLF            * else print CR/LF
00A00A2A  201F                    2199      MOVE.l  (sp)+,d0            * restore d0
00A00A2C                          2200  LAB_18F7
00A00A2C  522B 0E49               2201      ADDQ.b  #$01,TPos(a3)       * increment terminal position
00A00A30                          2202  LAB_18F9
00A00A30  4EAB 0C76               2203      JSR     V_OUTP(a3)          * output byte via output vector
00A00A34  B03C 000D               2204      CMP.b       #$0D,d0         * compare with [CR]
00A00A38  6618                    2205      BNE.s       LAB_188A            * branch if not [CR]
00A00A3A                          2206  
00A00A3A                          2207                              * else print nullct nulls after the [CR]
00A00A3A  7200                    2208      MOVEQ       #$00,d1         * clear d1
00A00A3C  122B 0E48               2209      MOVE.b  Nullct(a3),d1       * get null count
00A00A40  670C                    2210      BEQ.s       LAB_1886            * branch if no nulls
00A00A42                          2211  
00A00A42  7000                    2212      MOVEQ       #$00,d0         * load [NULL]
00A00A44                          2213  LAB_1880
00A00A44  4EAB 0C76               2214      JSR     V_OUTP(a3)          * go print the character
00A00A48  51C9 FFFA               2215      DBF     d1,LAB_1880         * decrement count and loop if not all done
00A00A4C                          2216  
00A00A4C  700D                    2217      MOVEQ       #$0D,d0         * restore the character
00A00A4E                          2218  LAB_1886
00A00A4E  1741 0E49               2219      MOVE.b  d1,TPos(a3)         * clear terminal position
00A00A52                          2220  LAB_188A
00A00A52  221F                    2221      MOVE.l  (sp)+,d1            * restore d1
00A00A54  4E75                    2222      RTS
00A00A56                          2223  
00A00A56                          2224  
00A00A56                          2225  *************************************************************************************
00A00A56                          2226  *
00A00A56                          2227  * handle bad input data
00A00A56                          2228  
00A00A56                          2229  LAB_1904
00A00A56  2A5F                    2230      MOVEA.l (sp)+,a5            * restore execute pointer
00A00A58  4A2B 0E44               2231      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00A00A5C  6A0A                    2232      BPL.s       LAB_1913            * branch if INPUT (go do redo)
00A00A5E                          2233  
00A00A5E  276B 0CC2 0CB6          2234      MOVE.l  Dlinel(a3),Clinel(a3)   * save DATA line as current line
00A00A64  6000 F6E0               2235      BRA     LAB_TMER            * do type mismatch error, then warm start
00A00A68                          2236  
00A00A68                          2237                              * mode was INPUT
00A00A68                          2238  LAB_1913
00A00A68  41FA 2A68               2239      LEA     LAB_REDO(pc),a0     * point to redo message
00A00A6C  6100 FF78               2240      BSR     LAB_18C3            * print null terminated string from memory
00A00A70  2A6B 0CBE               2241      MOVEA.l Cpntrl(a3),a5       * save continue pointer as BASIC execute pointer
00A00A74  4E75                    2242      RTS
00A00A76                          2243  
00A00A76                          2244  
00A00A76                          2245  *************************************************************************************
00A00A76                          2246  *
00A00A76                          2247  * perform INPUT
00A00A76                          2248  
00A00A76                          2249  LAB_INPUT
00A00A76  6100 0860               2250      BSR     LAB_CKRN            * check not direct (back here if ok)
00A00A7A  B03C 0022               2251      CMP.b       #'"',d0         * compare the next byte with open quote
00A00A7E  660E                    2252      BNE.s       LAB_1934            * if no prompt string just go get the input
00A00A80                          2253  
00A00A80  6100 0306               2254      BSR     LAB_1BC1            * print "..." string
00A00A84  703B                    2255      MOVEQ       #';',d0         * set the search character to ";"
00A00A86  6100 0320               2256      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00A00A8A                          2257                              * start
00A00A8A  6100 FF5E               2258      BSR     LAB_18C6            * print string from Sutill/Sutilh
00A00A8E                          2259                              * finished the prompt, now read the data
00A00A8E                          2260  LAB_1934
00A00A8E  6100 F80C               2261      BSR     LAB_INLN            * print "? " and get BASIC input
00A00A92                          2262                              * return a0 pointing to the buffer start
00A00A92  7000                    2263      MOVEQ       #0,d0               * flag INPUT
00A00A94                          2264  
00A00A94                          2265  * if you don't want a null response to INPUT to break the program then set the nobrk
00A00A94                          2266  * value at the top of this file to some non zero value
00A00A94                          2267  
00A00A94                 FALSE    2268   ifne   nobrk
00A00A94                          2269   endc
00A00A94                          2270  
00A00A94                          2271  * if you do want a null response to INPUT to break the program then leave the nobrk
00A00A94                          2272  * value at the top of this file set to zero
00A00A94                          2273  
00A00A94                 TRUE     2274   ifeq   nobrk
00A00A94                          2275  
00A00A94  4A10                    2276      TST.b       (a0)                * test first byte from buffer
00A00A96  660A                    2277      BNE.s       LAB_1953            * branch if not null input
00A00A98                          2278  
00A00A98  6000 FB5E               2279      BRA     LAB_1647            * go do BREAK exit
00A00A9C                          2280  
00A00A9C                          2281   endc
00A00A9C                          2282  
00A00A9C                          2283  
00A00A9C                          2284  *************************************************************************************
00A00A9C                          2285  *
00A00A9C                          2286  * perform READ
00A00A9C                          2287  
00A00A9C                          2288  LAB_READ
00A00A9C  206B 0CC6               2289      MOVEA.l Dptrl(a3),a0        * get the DATA pointer
00A00AA0  7098                    2290      MOVEQ       #$98-$100,d0        * flag READ
00A00AA2                          2291  LAB_1953
00A00AA2  1740 0E44               2292      MOVE.b  d0,Imode(a3)        * set input mode flag, $00=INPUT, $98=READ
00A00AA6  2748 0CCA               2293      MOVE.l  a0,Rdptrl(a3)       * save READ pointer
00A00AAA                          2294  
00A00AAA                          2295                              * READ or INPUT the next variable from list
00A00AAA                          2296  LAB_195B
00A00AAA  6100 0510               2297      BSR     LAB_SVAR            * search for or create a variable
00A00AAE                          2298                              * return the variable address in a0
00A00AAE  2748 0CD6               2299      MOVE.l  a0,Lvarpl(a3)       * save variable address as LET variable
00A00AB2  2F0D                    2300      MOVE.l  a5,-(sp)            * save BASIC execute pointer
00A00AB4                          2301  LAB_1961
00A00AB4  2A6B 0CCA               2302      MOVEA.l Rdptrl(a3),a5       * set READ pointer as BASIC execute pointer
00A00AB8  6100 02F8               2303      BSR     LAB_GBYT            * scan memory
00A00ABC  661E                    2304      BNE.s       LAB_1986            * if not null go get the value
00A00ABE                          2305  
00A00ABE                          2306                              * the pointer was to a null entry
00A00ABE  4A2B 0E44               2307      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00A00AC2  6B72                    2308      BMI.s       LAB_19DD            * branch if READ (go find the next statement)
00A00AC4                          2309  
00A00AC4                          2310                              * else the mode was INPUT so get more
00A00AC4  6100 FF38               2311      BSR     LAB_18E3            * print a "?" character
00A00AC8  6100 F7D2               2312      BSR     LAB_INLN            * print "? " and get BASIC input
00A00ACC                          2313                              * return a0 pointing to the buffer start
00A00ACC                          2314  
00A00ACC                          2315  * if you don't want a null response to INPUT to break the program then set the nobrk
00A00ACC                          2316  * value at the top of this file to some non zero value
00A00ACC                          2317  
00A00ACC                 FALSE    2318   ifne   nobrk
00A00ACC                          2319   endc
00A00ACC                          2320  
00A00ACC                          2321  * if you do want a null response to INPUT to break the program then leave the nobrk
00A00ACC                          2322  * value at the top of this file set to zero
00A00ACC                          2323  
00A00ACC                 TRUE     2324   ifeq   nobrk
00A00ACC                          2325  
00A00ACC  4A10                    2326      TST.b       (a0)                * test the first byte from the buffer
00A00ACE  6604                    2327      BNE.s       LAB_1984            * if not null input go handle it
00A00AD0                          2328  
00A00AD0  6000 FB26               2329      BRA     LAB_1647            * else go do the BREAK exit
00A00AD4                          2330  
00A00AD4                          2331  LAB_1984
00A00AD4  2A48                    2332      MOVEA.l a0,a5               * set the execute pointer to the buffer
00A00AD6  534D                    2333      SUBQ.w  #1,a5               * decrement the execute pointer
00A00AD8                          2334  
00A00AD8                          2335   endc
00A00AD8                          2336  
00A00AD8                          2337  LAB_1985
00A00AD8  6100 02D6               2338      BSR     LAB_IGBY            * increment & scan memory
00A00ADC                          2339  LAB_1986
00A00ADC  4A2B 0E19               2340      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A00AE0                          2341                              * $00=float
00A00AE0  6A20                    2342      BPL.s       LAB_19B0            * branch if numeric
00A00AE2                          2343  
00A00AE2                          2344                              * else get string
00A00AE2  1400                    2345      MOVE.b  d0,d2               * save search character
00A00AE4  B03C 0022               2346      CMP.b       #$22,d0         * was it " ?
00A00AE8  6706                    2347      BEQ.s       LAB_1999            * branch if so
00A00AEA                          2348  
00A00AEA  743A                    2349      MOVEQ       #':',d2         * set new search character
00A00AEC  702C                    2350      MOVEQ       #',',d0         * other search character is ","
00A00AEE  534D                    2351      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00A00AF0                          2352  LAB_1999
00A00AF0  524D                    2353      ADDQ.w  #1,a5               * increment BASIC execute pointer
00A00AF2  1600                    2354      MOVE.b  d0,d3               * set second search character
00A00AF4  204D                    2355      MOVEA.l a5,a0               * BASIC execute pointer is source
00A00AF6                          2356  
00A00AF6  6100 08D2               2357      BSR     LAB_20B4            * print d2/d3 terminated string to FAC1 stack
00A00AFA                          2358                              * d2 = Srchc, d3 = Asrch, a0 is source
00A00AFA  2A4A                    2359      MOVEA.l a2,a5               * copy end of string to BASIC execute pointer
00A00AFC  6100 FDD2               2360      BSR     LAB_17D5            * go do string LET
00A00B00  6010                    2361      BRA.s       LAB_19B6            * go check string terminator
00A00B02                          2362  
00A00B02                          2363                              * get numeric INPUT
00A00B02                          2364  LAB_19B0
00A00B02  1F2B 0E19               2365      MOVE.b  Dtypef(a3),-(sp)        * save variable data type
00A00B06  6100 1D98               2366      BSR     LAB_2887            * get FAC1 from string
00A00B0A  175F 0E19               2367      MOVE.b  (sp)+,Dtypef(a3)        * restore variable data type
00A00B0E  6100 1080               2368      BSR     LAB_PFAC            * pack FAC1 into (Lvarpl)
00A00B12                          2369  LAB_19B6
00A00B12  6100 029E               2370      BSR     LAB_GBYT            * scan memory
00A00B16  670A                    2371      BEQ.s       LAB_19C2            * branch if null (last entry)
00A00B18                          2372  
00A00B18  B03C 002C               2373      CMP.b       #',',d0         * else compare with ","
00A00B1C  6600 FF38               2374      BNE     LAB_1904            * if not "," go handle bad input data
00A00B20                          2375  
00A00B20  524D                    2376      ADDQ.w  #1,a5               * else was "," so point to next chr
00A00B22                          2377                              * got good input data
00A00B22                          2378  LAB_19C2
00A00B22  274D 0CCA               2379      MOVE.l  a5,Rdptrl(a3)       * save the read pointer for now
00A00B26  2A5F                    2380      MOVEA.l (sp)+,a5            * restore the execute pointer
00A00B28  6100 0288               2381      BSR     LAB_GBYT            * scan the memory
00A00B2C  6736                    2382      BEQ.s       LAB_1A03            * if null go do extra ignored message
00A00B2E                          2383  
00A00B2E  487A FF7A               2384      PEA     LAB_195B(pc)        * set return address
00A00B32  6000 0272               2385      BRA     LAB_1C01            * scan for "," else do syntax error/warm start
00A00B36                          2386                              * then go INPUT next variable from list
00A00B36                          2387  
00A00B36                          2388                              * find next DATA statement or do "Out of Data"
00A00B36                          2389                              * error
00A00B36                          2390  LAB_19DD
00A00B36  6100 FC04               2391      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00A00B3A                          2392                              * returns a0 as pointer to [:] or [EOL]
00A00B3A  2A48                    2393      MOVEA.l a0,a5               * add index, now = pointer to [EOL]/[EOS]
00A00B3C  524D                    2394      ADDQ.w  #1,a5               * pointer to next character
00A00B3E  B03C 003A               2395      CMP.b       #':',d0         * was it statement end?
00A00B42  6712                    2396      BEQ.s       LAB_19F6            * branch if [:]
00A00B44                          2397  
00A00B44                          2398                              * was [EOL] so find next line
00A00B44                          2399  
00A00B44  320D                    2400      MOVE.w  a5,d1               * past pad byte(s)
00A00B46  C27C 0001               2401      AND.w       #1,d1               * mask odd bit
00A00B4A  DAC1                    2402      ADD.w       d1,a5               * add pointer
00A00B4C  241D                    2403      MOVE.l  (a5)+,d2            * get next line pointer
00A00B4E  6700 F61A               2404      BEQ     LAB_ODER            * branch if end of program
00A00B52                          2405  
00A00B52  275D 0CC2               2406      MOVE.l  (a5)+,Dlinel(a3)        * save current DATA line
00A00B56                          2407  LAB_19F6
00A00B56  6100 025A               2408      BSR     LAB_GBYT            * scan memory
00A00B5A  B03C 0083               2409      CMP.b       #TK_DATA,d0         * compare with "DATA" token
00A00B5E  6700 FF78               2410      BEQ     LAB_1985            * was "DATA" so go do next READ
00A00B62                          2411  
00A00B62  60D2                    2412      BRA.s       LAB_19DD            * go find next statement if not "DATA"
00A00B64                          2413  
00A00B64                          2414  * end of INPUT/READ routine
00A00B64                          2415  
00A00B64                          2416  LAB_1A03
00A00B64  206B 0CCA               2417      MOVEA.l Rdptrl(a3),a0       * get temp READ pointer
00A00B68  4A2B 0E44               2418      TST.b       Imode(a3)           * get input mode flag, $00=INPUT, $98=READ
00A00B6C  6A06                    2419      BPL.s       LAB_1A0E            * branch if INPUT
00A00B6E                          2420  
00A00B6E  2748 0CC6               2421      MOVE.l  a0,Dptrl(a3)        * else save temp READ pointer as DATA pointer
00A00B72  4E75                    2422      RTS
00A00B74                          2423  
00A00B74                          2424                              * we were getting INPUT
00A00B74                          2425  LAB_1A0E
00A00B74  4A10                    2426      TST.b       (a0)                * test next byte
00A00B76  6602                    2427      BNE.s       LAB_1A1B            * error if not end of INPUT
00A00B78                          2428  
00A00B78  4E75                    2429      RTS
00A00B7A                          2430                              * user typed too much
00A00B7A                          2431  LAB_1A1B
00A00B7A  41FA 2946               2432      LEA     LAB_IMSG(pc),a0     * point to extra ignored message
00A00B7E  6000 FE66               2433      BRA     LAB_18C3            * print null terminated string from memory & RTS
00A00B82                          2434  
00A00B82                          2435  
00A00B82                          2436  *************************************************************************************
00A00B82                          2437  *
00A00B82                          2438  * perform NEXT
00A00B82                          2439  
00A00B82                          2440  LAB_NEXT
00A00B82  6610                    2441      BNE.s       LAB_1A46            * branch if NEXT var
00A00B84                          2442  
00A00B84  584F                    2443      ADDQ.w  #4,sp               * back past return address
00A00B86  0C57 0081               2444      CMP.w       #TK_FOR,(sp)        * is FOR token on stack?
00A00B8A  6600 F5EA               2445      BNE     LAB_NFER            * if not do NEXT without FOR err/warm start
00A00B8E                          2446  
00A00B8E  206F 0002               2447      MOVEA.l 2(sp),a0            * get stacked FOR variable pointer
00A00B92  601C                    2448      BRA.s       LAB_11BD            * branch always (no variable to search for)
00A00B94                          2449  
00A00B94                          2450  * NEXT var
00A00B94                          2451  
00A00B94                          2452  LAB_1A46
00A00B94  6100 042A               2453      BSR     LAB_GVAR            * get variable address in a0
00A00B98  584F                    2454      ADDQ.w  #4,sp               * back past return address
00A00B9A  303C 0081               2455      MOVE.w  #TK_FOR,d0          * set for FOR token
00A00B9E  721C                    2456      MOVEQ       #$1C,d1         * set for FOR use size
00A00BA0  6002                    2457      BRA.s       LAB_11A6            * enter loop for next variable search
00A00BA2                          2458  
00A00BA2                          2459  LAB_11A5
00A00BA2  DFC1                    2460      ADDA.l  d1,sp               * add FOR stack use size
00A00BA4                          2461  LAB_11A6
00A00BA4  B057                    2462      CMP.w       (sp),d0         * is FOR token on stack?
00A00BA6  6600 F5CE               2463      BNE     LAB_NFER            * if not found do NEXT without FOR error and
00A00BAA                          2464                              * warm start
00A00BAA                          2465  
00A00BAA                          2466                              * was FOR token
00A00BAA  B1EF 0002               2467      CMPA.l  2(sp),a0            * compare var pointer with stacked var pointer
00A00BAE  66F2                    2468      BNE.s       LAB_11A5            * loop if no match found
00A00BB0                          2469  
00A00BB0                          2470  LAB_11BD
00A00BB0  376F 0006 0E00          2471      MOVE.w  6(sp),FAC2_e(a3)        * get STEP value exponent and sign
00A00BB6  276F 0008 0DFC          2472      MOVE.l  8(sp),FAC2_m(a3)        * get STEP value mantissa
00A00BBC                          2473  
00A00BBC  176F 0012 0E19          2474      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type
00A00BC2  6100 021C               2475      BSR     LAB_1C19            * check type and unpack (a0)
00A00BC6                          2476  
00A00BC6  176B 0E01 0E02          2477      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00A00BCC  102B 0DF9               2478      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00A00BD0  B12B 0E02               2479      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00A00BD4                          2480  
00A00BD4  2748 0CD6               2481      MOVE.l  a0,Lvarpl(a3)       * save variable pointer
00A00BD8  6100 0CB6               2482      BSR     LAB_ADD         * add STEP value to FOR variable
00A00BDC  176F 0012 0E19          2483      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type (again)
00A00BE2  6100 0FAC               2484      BSR     LAB_PFAC            * pack FAC1 into FOR variable (Lvarpl)
00A00BE6                          2485  
00A00BE6  376F 000C 0E00          2486      MOVE.w  12(sp),FAC2_e(a3)       * get TO value exponent and sign
00A00BEC  276F 000E 0DFC          2487      MOVE.l  14(sp),FAC2_m(a3)       * get TO value mantissa
00A00BF2                          2488  
00A00BF2  176B 0E01 0E02          2489      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00A00BF8  102B 0DF9               2490      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00A00BFC  B12B 0E02               2491      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00A00C00                          2492  
00A00C00  6100 1038               2493      BSR     LAB_27FA            * compare FAC1 with FAC2 (TO value)
00A00C04                          2494                              * returns d0=+1 if FAC1 > FAC2
00A00C04                          2495                              * returns d0= 0 if FAC1 = FAC2
00A00C04                          2496                              * returns d0=-1 if FAC1 < FAC2
00A00C04                          2497  
00A00C04  322F 0006               2498      MOVE.w  6(sp),d1            * get STEP value exponent and sign
00A00C08  B141                    2499      EOR.w       d0,d1               * EOR compare result with STEP exponent and sign
00A00C0A                          2500  
00A00C0A  4A00                    2501      TST.b       d0              * test for =
00A00C0C  6704                    2502      BEQ.s       LAB_1A90            * branch if = (loop INcomplete)
00A00C0E                          2503  
00A00C0E  4A01                    2504      TST.b       d1              * test result
00A00C10  6A0E                    2505      BPL.s       LAB_1A9B            * branch if > (loop complete)
00A00C12                          2506  
00A00C12                          2507                              * loop back and do it all again
00A00C12                          2508  LAB_1A90
00A00C12  276F 0014 0CB6          2509      MOVE.l  20(sp),Clinel(a3)       * reset current line
00A00C18  2A6F 0018               2510      MOVE.l  24(sp),a5           * reset BASIC execute pointer
00A00C1C  6000 F976               2511      BRA     LAB_15C2            * go do interpreter inner loop
00A00C20                          2512  
00A00C20                          2513                              * loop complete so carry on
00A00C20                          2514  LAB_1A9B
00A00C20  DEFC 001C               2515      ADDA.w  #28,sp          * add 28 to dump FOR structure
00A00C24  6100 018C               2516      BSR     LAB_GBYT            * scan memory
00A00C28  B03C 002C               2517      CMP.b       #$2C,d0         * compare with ","
00A00C2C  6600 F966               2518      BNE     LAB_15C2            * if not "," go do interpreter inner loop
00A00C30                          2519  
00A00C30                          2520                              * was "," so another NEXT variable to do
00A00C30  6100 017E               2521      BSR     LAB_IGBY            * else increment & scan memory
00A00C34  6100 FF5E               2522      BSR     LAB_1A46            * do NEXT (var)
00A00C38                          2523  
00A00C38                          2524  
00A00C38                          2525  *************************************************************************************
00A00C38                          2526  *
00A00C38                          2527  * evaluate expression & check is numeric, else do type mismatch
00A00C38                          2528  
00A00C38                          2529  LAB_EVNM
00A00C38  6116                    2530      BSR.s       LAB_EVEX            * evaluate expression
00A00C3A                          2531  
00A00C3A                          2532  
00A00C3A                          2533  *************************************************************************************
00A00C3A                          2534  *
00A00C3A                          2535  * check if source is numeric, else do type mismatch
00A00C3A                          2536  
00A00C3A                          2537  LAB_CTNM
00A00C3A  B040                    2538      CMP.w       d0,d0               * required type is numeric so clear carry
00A00C3C                          2539  
00A00C3C                          2540  
00A00C3C                          2541  *************************************************************************************
00A00C3C                          2542  *
00A00C3C                          2543  * type match check, set C for string, clear C for numeric
00A00C3C                          2544  
00A00C3C                          2545  LAB_CKTM
00A00C3C  082B 0007 0E19          2546      BTST.b  #7,Dtypef(a3)       * test data type flag, don't change carry
00A00C42  6606                    2547      BNE.s       LAB_1ABA            * branch if data type is string
00A00C44                          2548  
00A00C44                          2549                              * else data type was numeric
00A00C44  6500 F500               2550      BCS     LAB_TMER            * if required type is string do type mismatch
00A00C48                          2551                              * error
00A00C48                          2552  
00A00C48  4E75                    2553      RTS
00A00C4A                          2554                              * data type was string, now check required type
00A00C4A                          2555  LAB_1ABA
00A00C4A  6400 F4FA               2556      BCC     LAB_TMER            * if required type is numeric do type mismatch
00A00C4E                          2557                              * error
00A00C4E  4E75                    2558      RTS
00A00C50                          2559  
00A00C50                          2560  
00A00C50                          2561  *************************************************************************************
00A00C50                          2562  *
00A00C50                          2563  * this routine evaluates any type of expression. first it pushes an end marker so
00A00C50                          2564  * it knows when the expression has been evaluated, this is a precedence value of zero.
00A00C50                          2565  * next the first value is evaluated, this can be an in line value, either numeric or
00A00C50                          2566  * string, a variable or array element of any type, a function or even an expression
00A00C50                          2567  * in parenthesis. this value is kept in FAC_1
00A00C50                          2568  * after the value is evaluated a test is made on the next BASIC program byte, if it
00A00C50                          2569  * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
00A00C50                          2570  * in the comparison evaluation flag. this test loops until no more comparrison operators
00A00C50                          2571  * are found or more than one of any type is found. in the last case an error is generated
00A00C50                          2572  
00A00C50                          2573  * evaluate expression
00A00C50                          2574  
00A00C50                          2575  LAB_EVEX
00A00C50  534D                    2576      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00A00C52                          2577  LAB_EVEZ
00A00C52  7200                    2578      MOVEQ       #0,d1               * clear precedence word
00A00C54  1741 0E19               2579      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
00A00C58                          2580                              * $00=float
00A00C58  601C                    2581      BRA.s       LAB_1ACD            * enter loop
00A00C5A                          2582  
00A00C5A                          2583  * get vector, set up operator then continue evaluation
00A00C5A                          2584  
00A00C5A                          2585  LAB_1B43                        *
00A00C5A  41FA 22BC               2586      LEA     LAB_OPPT(pc),a0     * point to operator vector table
00A00C5E  3030 1002               2587      MOVE.w  2(a0,d1.w),d0       * get vector offset
00A00C62  4870 0000               2588      PEA     (a0,d0.w)           * push vector
00A00C66                          2589  
00A00C66  2F2B 0DF4               2590      MOVE.l  FAC1_m(a3),-(sp)        * push FAC1 mantissa
00A00C6A  3F2B 0DF8               2591      MOVE.w  FAC1_e(a3),-(sp)        * push sign and exponent
00A00C6E  1F2B 0E47               2592      MOVE.b  comp_f(a3),-(sp)        * push comparison evaluation flag
00A00C72                          2593  
00A00C72  3230 1000               2594      MOVE.w  (a0,d1.w),d1        * get precedence value
00A00C76                          2595  LAB_1ACD
00A00C76  3F01                    2596      MOVE.w  d1,-(sp)            * push precedence value
00A00C78  6100 00E4               2597      BSR     LAB_GVAL            * get value from line
00A00C7C  177C 0000 0E47          2598      MOVE.b  #$00,comp_f(a3)     * clear compare function flag
00A00C82                          2599  LAB_1ADB
00A00C82  6100 012E               2600      BSR     LAB_GBYT            * scan memory
00A00C86                          2601  LAB_1ADE
00A00C86  0400 00BC               2602      SUB.b       #TK_GT,d0           * subtract token for > (lowest compare function)
00A00C8A  652A                    2603      BCS.s       LAB_1AFA            * branch if < TK_GT
00A00C8C                          2604  
00A00C8C  B03C 0003               2605      CMP.b       #$03,d0         * compare with ">" to "<" tokens
00A00C90  650A                    2606      BCS.s       LAB_1AE0            * branch if <= TK_SGN (is compare function)
00A00C92                          2607  
00A00C92  4A2B 0E47               2608      TST.b       comp_f(a3)          * test compare function flag
00A00C96  6660                    2609      BNE.s       LAB_1B2A            * branch if compare function
00A00C98                          2610  
00A00C98  6000 0086               2611      BRA     LAB_1B78            * go do functions
00A00C9C                          2612  
00A00C9C                          2613                              * was token for > = or < (d0 = 0, 1 or 2)
00A00C9C                          2614  LAB_1AE0
00A00C9C  7201                    2615      MOVEQ       #1,d1               * set to 0000 0001
00A00C9E  E121                    2616      ASL.b       d0,d1               * 1 if >, 2 if =, 4 if <
00A00CA0  102B 0E47               2617      MOVE.b  comp_f(a3),d0       * copy old compare function flag
00A00CA4  B32B 0E47               2618      EOR.b       d1,comp_f(a3)       * EOR in this compare function bit
00A00CA8  B02B 0E47               2619      CMP.b       comp_f(a3),d0       * compare old with new compare function flag
00A00CAC  6400 F4C4               2620      BCC     LAB_SNER            * if new <= old comp_f do syntax error and warm
00A00CB0                          2621                              * start, there was more than one <, = or >
00A00CB0  6100 00FE               2622      BSR     LAB_IGBY            * increment & scan memory
00A00CB4  60D0                    2623      BRA.s       LAB_1ADE            * go do next character
00A00CB6                          2624  
00A00CB6                          2625                              * token is < ">" or > "<" tokens
00A00CB6                          2626  LAB_1AFA
00A00CB6  4A2B 0E47               2627      TST.b       comp_f(a3)          * test compare function flag
00A00CBA  663C                    2628      BNE.s       LAB_1B2A            * branch if compare function
00A00CBC                          2629  
00A00CBC                          2630                              * was < TK_GT so is operator or lower
00A00CBC  0600 000A               2631      ADD.b   #(TK_GT-TK_PLUS),d0     * add # of operators (+ - * / ^ AND OR EOR)
00A00CC0  645E                    2632      BCC.s       LAB_1B78            * branch if < + operator
00A00CC2                          2633  
00A00CC2  6608                    2634      BNE.s       LAB_1B0B            * branch if not + token
00A00CC4                          2635  
00A00CC4  4A2B 0E19               2636      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A00CC8                          2637                              * $00=float
00A00CC8  6B00 087C               2638      BMI     LAB_224D            * type is string & token was +
00A00CCC                          2639  
00A00CCC                          2640  LAB_1B0B
00A00CCC  7200                    2641      MOVEQ       #0,d1               * clear longword
00A00CCE  D000                    2642      ADD.b       d0,d0               * *2
00A00CD0  D000                    2643      ADD.b       d0,d0               * *4
00A00CD2  1200                    2644      MOVE.b  d0,d1               * copy to index
00A00CD4                          2645  LAB_1B13
00A00CD4  301F                    2646      MOVE.w  (sp)+,d0            * pull previous precedence
00A00CD6  41FA 2240               2647      LEA     LAB_OPPT(pc),a0     * set pointer to operator table
00A00CDA  B070 1000               2648      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00A00CDE  6446                    2649      BCC.s       LAB_1B7D            * branch if previous precedence (d0) >=
00A00CE0                          2650  
00A00CE0  6100 FF58               2651      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00A00CE4                          2652  LAB_1B1C
00A00CE4  3F00                    2653      MOVE.w  d0,-(sp)            * save precedence
00A00CE6                          2654  LAB_1B1D
00A00CE6  6100 FF72               2655      BSR     LAB_1B43            * get vector, set-up operator and continue
00A00CEA                          2656                              * evaluation
00A00CEA  301F                    2657      MOVE.w  (sp)+,d0            * restore precedence
00A00CEC  222B 0E3C               2658      MOVE.l  prstk(a3),d1        * get stacked function pointer
00A00CF0  6A22                    2659      BPL.s       LAB_1B3C            * branch if stacked values
00A00CF2                          2660  
00A00CF2  3000                    2661      MOVE.w  d0,d0               * copy precedence (set flags)
00A00CF4  672E                    2662      BEQ.s       LAB_1B7B            * exit if done
00A00CF6                          2663  
00A00CF6  603C                    2664      BRA.s       LAB_1B86            * else pop FAC2 & return (do function)
00A00CF8                          2665  
00A00CF8                          2666                              * was compare function (< = >)
00A00CF8                          2667  LAB_1B2A
00A00CF8  102B 0E19               2668      MOVE.b  Dtypef(a3),d0       * get data type flag
00A00CFC  122B 0E47               2669      MOVE.b  comp_f(a3),d1       * get compare function flag
00A00D00  D000                    2670      ADD.b       d0,d0               * string bit flag into X bit
00A00D02  D301                    2671      ADDX.b  d1,d1               * shift compare function flag
00A00D04                          2672  
00A00D04  177C 0000 0E19          2673      MOVE.b  #0,Dtypef(a3)       * clear data type flag, $00=float
00A00D0A  1741 0E47               2674      MOVE.b  d1,comp_f(a3)       * save new compare function flag
00A00D0E  534D                    2675      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00A00D10  7230                    2676      MOVEQ       #(TK_LT-TK_PLUS)*4,d1   * set offset to last operator entry
00A00D12  60C0                    2677      BRA.s       LAB_1B13            * branch always
00A00D14                          2678  
00A00D14                          2679  LAB_1B3C
00A00D14  41FA 2202               2680      LEA     LAB_OPPT(pc),a0     * point to function vector table
00A00D18  B070 1000               2681      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00A00D1C  6416                    2682      BCC.s       LAB_1B86            * branch if d0 >=, pop FAC2 & return
00A00D1E                          2683  
00A00D1E  60C4                    2684      BRA.s       LAB_1B1C            * branch always
00A00D20                          2685  
00A00D20                          2686  * do functions
00A00D20                          2687  
00A00D20                          2688  LAB_1B78
00A00D20  72FF                    2689      MOVEQ       #-1,d1          * flag all done
00A00D22  301F                    2690      MOVE.w  (sp)+,d0            * pull precedence word
00A00D24                          2691  LAB_1B7B
00A00D24  6732                    2692      BEQ.s       LAB_1B9D            * exit if done
00A00D26                          2693  
00A00D26                          2694  LAB_1B7D
00A00D26  B07C 0064               2695      CMP.w       #$64,d0         * compare previous precedence with $64
00A00D2A  6704                    2696      BEQ.s       LAB_1B84            * branch if was $64 (< function can be string)
00A00D2C                          2697  
00A00D2C  6100 FF0C               2698      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00A00D30                          2699  LAB_1B84
00A00D30  2741 0E3C               2700      MOVE.l  d1,prstk(a3)        * save current operator index
00A00D34                          2701  
00A00D34                          2702                              * pop FAC2 & return
00A00D34                          2703  LAB_1B86
00A00D34  101F                    2704      MOVE.b  (sp)+,d0            * pop comparison evaluation flag
00A00D36  1200                    2705      MOVE.b  d0,d1               * copy comparison evaluation flag
00A00D38  E208                    2706      LSR.b       #1,d0               * shift out comparison evaluation lowest bit
00A00D3A  1740 0E45               2707      MOVE.b  d0,Cflag(a3)        * save comparison evaluation flag
00A00D3E  375F 0E00               2708      MOVE.w  (sp)+,FAC2_e(a3)        * pop exponent and sign
00A00D42  275F 0DFC               2709      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00A00D46  176B 0E01 0E02          2710      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign
00A00D4C  102B 0DF9               2711      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00A00D50  B12B 0E02               2712      EOR.b       d0,FAC_sc(a3)       * EOR FAC1 sign and set sign compare
00A00D54                          2713  
00A00D54  E209                    2714      LSR.b       #1,d1               * type bit into X and C
00A00D56  4E75                    2715      RTS
00A00D58                          2716  
00A00D58                          2717  LAB_1B9D
00A00D58  102B 0DF8               2718      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A00D5C  4E75                    2719      RTS
00A00D5E                          2720  
00A00D5E                          2721  
00A00D5E                          2722  *************************************************************************************
00A00D5E                          2723  *
00A00D5E                          2724  * get a value from the BASIC line
00A00D5E                          2725  
00A00D5E                          2726  LAB_GVAL
00A00D5E  6150                    2727      BSR.s       LAB_IGBY            * increment & scan memory
00A00D60  6500 1B3E               2728      BCS     LAB_2887            * if numeric get FAC1 from string & return
00A00D64                          2729  
00A00D64  4A00                    2730      TST.b       d0              * test byte
00A00D66  6B00 008E               2731      BMI     LAB_1BD0            * if -ve go test token values
00A00D6A                          2732  
00A00D6A                          2733                              * else it is either a string, number, variable
00A00D6A                          2734                              * or (<expr>)
00A00D6A  B03C 0024               2735      CMP.b       #'$',d0         * compare with "$"
00A00D6E  6700 1B30               2736      BEQ     LAB_2887            * if "$" get hex number from string & return
00A00D72                          2737  
00A00D72  B03C 0025               2738      CMP.b       #'%',d0         * else compare with "%"
00A00D76  6700 1B28               2739      BEQ     LAB_2887            * if "%" get binary number from string & return
00A00D7A                          2740  
00A00D7A  B03C 002E               2741      CMP.b       #$2E,d0         * compare with "."
00A00D7E  6700 1B20               2742      BEQ     LAB_2887            * if so get FAC1 from string and return
00A00D82                          2743                              * (e.g. .123)
00A00D82                          2744  
00A00D82                          2745                              * wasn't a number so ...
00A00D82  B03C 0022               2746      CMP.b       #$22,d0         * compare with "
00A00D86  660C                    2747      BNE.s       LAB_1BF3            * if not open quote it must be a variable or
00A00D88                          2748                              * open bracket
00A00D88                          2749  
00A00D88                          2750                              * was open quote so get the enclosed string
00A00D88                          2751  
00A00D88                          2752  * print "..." string to string stack
00A00D88                          2753  
00A00D88                          2754  LAB_1BC1
00A00D88  101D                    2755      MOVE.b  (a5)+,d0            * increment BASIC execute pointer (past ")
00A00D8A                          2756                              * fastest/shortest method
00A00D8A  204D                    2757      MOVEA.l a5,a0               * copy basic execute pointer (string start)
00A00D8C  6100 0638               2758      BSR     LAB_20AE            * print " terminated string to stack
00A00D90  2A4A                    2759      MOVEA.l a2,a5               * restore BASIC execute pointer from temp
00A00D92  4E75                    2760      RTS
00A00D94                          2761  
00A00D94                          2762  * get value from line .. continued
00A00D94                          2763                              * wasn't any sort of number so ...
00A00D94                          2764  LAB_1BF3
00A00D94  B03C 0028               2765      CMP.b       #'(',d0         * compare with "("
00A00D98  6642                    2766      BNE.s       LAB_1C18            * if not "(" get (var) and return value in FAC1
00A00D9A                          2767                              * and $ flag
00A00D9A                          2768  
00A00D9A                          2769  
00A00D9A                          2770  *************************************************************************************
00A00D9A                          2771  *
00A00D9A                          2772  * evaluate expression within parentheses
00A00D9A                          2773  
00A00D9A                          2774  LAB_1BF7
00A00D9A  6100 FEB6               2775      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00A00D9E                          2776  
00A00D9E                          2777  
00A00D9E                          2778  *************************************************************************************
00A00D9E                          2779  *
00A00D9E                          2780  * all the 'scan for' routines return the character after the sought character
00A00D9E                          2781  
00A00D9E                          2782  * scan for ")", else do syntax error, then warm start
00A00D9E                          2783  
00A00D9E                          2784  LAB_1BFB
00A00D9E  7029                    2785      MOVEQ       #$29,d0         * load d0 with ")"
00A00DA0  6006                    2786      BRA.s       LAB_SCCA
00A00DA2                          2787  
00A00DA2                          2788  
00A00DA2                          2789  *************************************************************************************
00A00DA2                          2790  *
00A00DA2                          2791  * scan for "," and get byte, else do Syntax error then warm start
00A00DA2                          2792  
00A00DA2                          2793  LAB_SCGB
00A00DA2  487A 0976               2794      PEA     LAB_GTBY(pc)        * return address is to get byte parameter
00A00DA6                          2795  
00A00DA6                          2796  
00A00DA6                          2797  *************************************************************************************
00A00DA6                          2798  *
00A00DA6                          2799  * scan for ",", else do syntax error, then warm start
00A00DA6                          2800  
00A00DA6                          2801  LAB_1C01
00A00DA6  702C                    2802      MOVEQ       #$2C,d0         * load d0 with ","
00A00DA8                          2803  
00A00DA8                          2804  
00A00DA8                          2805  *************************************************************************************
00A00DA8                          2806  *
00A00DA8                          2807  * scan for CHR$(d0) , else do syntax error, then warm start
00A00DA8                          2808  
00A00DA8                          2809  LAB_SCCA
00A00DA8  B01D                    2810      CMP.b       (a5)+,d0            * check next byte is = d0
00A00DAA  6706                    2811      BEQ.s       LAB_GBYT            * if so go get next
00A00DAC                          2812  
00A00DAC  6000 F3C4               2813      BRA     LAB_SNER            * else do syntax error/warm start
00A00DB0                          2814  
00A00DB0                          2815  
00A00DB0                          2816  *************************************************************************************
00A00DB0                          2817  *
00A00DB0                          2818  * BASIC increment and scan memory routine
00A00DB0                          2819  
00A00DB0                          2820  LAB_IGBY
00A00DB0  101D                    2821      MOVE.b  (a5)+,d0            * get byte & increment pointer
00A00DB2                          2822  
00A00DB2                          2823  * scan memory routine, exit with Cb = 1 if numeric character
00A00DB2                          2824  * also skips any spaces encountered
00A00DB2                          2825  
00A00DB2                          2826  LAB_GBYT
00A00DB2  1015                    2827      MOVE.b  (a5),d0         * get byte
00A00DB4                          2828  
00A00DB4  B03C 0020               2829      CMP.b       #$20,d0         * compare with " "
00A00DB8  67F6                    2830      BEQ.s       LAB_IGBY            * if " " go do next
00A00DBA                          2831  
00A00DBA                          2832  * test current BASIC byte, exit with Cb = 1 if numeric character
00A00DBA                          2833  
00A00DBA  B03C 00A9               2834      CMP.b       #TK_ELSE,d0         * compare with the token for ELSE
00A00DBE  640C                    2835      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00A00DC0                          2836  
00A00DC0  B03C 003A               2837      CMP.b       #$3A,d0         * compare with ":"
00A00DC4  6406                    2838      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00A00DC6                          2839  
00A00DC6  7CD0                    2840      MOVEQ       #$D0,d6         * set -"0"
00A00DC8  D006                    2841      ADD.b       d6,d0               * add -"0"
00A00DCA  9006                    2842      SUB.b       d6,d0               * subtract -"0"
00A00DCC                          2843  RTS_001                     * carry set if byte = "0"-"9"
00A00DCC  4E75                    2844      RTS
00A00DCE                          2845  
00A00DCE                          2846  
00A00DCE                          2847  *************************************************************************************
00A00DCE                          2848  *
00A00DCE                          2849  * set-up for - operator
00A00DCE                          2850  
00A00DCE                          2851  LAB_1C11
00A00DCE  6100 FE6A               2852      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00A00DD2  7228                    2853      MOVEQ   #(TK_GT-TK_PLUS)*4,d1       * set offset from base to - operator
00A00DD4                          2854  LAB_1C13
00A00DD4  4FEF 0004               2855      LEA     4(sp),sp            * dump GVAL return address
00A00DD8  6000 FF0C               2856      BRA     LAB_1B1D            * continue evaluating expression
00A00DDC                          2857  
00A00DDC                          2858  
00A00DDC                          2859  *************************************************************************************
00A00DDC                          2860  *
00A00DDC                          2861  * variable name set-up
00A00DDC                          2862  * get (var), return value in FAC_1 & data type flag
00A00DDC                          2863  
00A00DDC                          2864  LAB_1C18
00A00DDC  6100 01E2               2865      BSR     LAB_GVAR            * get variable address in a0
00A00DE0                          2866  
00A00DE0                          2867  * if you want a non existant variable to return a null value then set the novar
00A00DE0                          2868  * value at the top of this file to some non zero value
00A00DE0                          2869  
00A00DE0                 FALSE    2870   ifne   novar
00A00DE0                          2871   endc
00A00DE0                          2872  
00A00DE0                          2873  * return existing variable value
00A00DE0                          2874  
00A00DE0                          2875  LAB_1C19
00A00DE0  4A2B 0E19               2876      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A00DE4                          2877                              * $00=float
00A00DE4  6700 0D8E               2878      BEQ     LAB_UFAC            * if float unpack memory (a0) into FAC1 and
00A00DE8                          2879                              * return
00A00DE8                          2880  
00A00DE8  6A06                    2881      BPL.s       LAB_1C1A            * if integer unpack memory (a0) into FAC1
00A00DEA                          2882                              * and return
00A00DEA                          2883  
00A00DEA  2748 0DF4               2884      MOVE.l  a0,FAC1_m(a3)       * else save descriptor pointer in FAC1
00A00DEE  4E75                    2885      RTS
00A00DF0                          2886  
00A00DF0                          2887  LAB_1C1A
00A00DF0  2010                    2888      MOVE.l  (a0),d0         * get integer value
00A00DF2  6000 04BC               2889      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A00DF6                          2890  
00A00DF6                          2891  
00A00DF6                          2892  *************************************************************************************
00A00DF6                          2893  *
00A00DF6                          2894  * get value from line .. continued
00A00DF6                          2895  * do tokens
00A00DF6                          2896  
00A00DF6                          2897  LAB_1BD0
00A00DF6  B03C 00B3               2898      CMP.b       #TK_MINUS,d0        * compare with token for -
00A00DFA  67D2                    2899      BEQ.s       LAB_1C11            * branch if - token (do set-up for - operator)
00A00DFC                          2900  
00A00DFC                          2901                              * wasn't -123 so ...
00A00DFC  B03C 00B2               2902      CMP.b       #TK_PLUS,d0         * compare with token for +
00A00E00  6700 FF5C               2903      BEQ     LAB_GVAL            * branch if + token (+n = n so ignore leading +)
00A00E04                          2904  
00A00E04  B03C 00AE               2905      CMP.b       #TK_NOT,d0          * compare with token for NOT
00A00E08  6606                    2906      BNE.s       LAB_1BE7            * branch if not token for NOT
00A00E0A                          2907  
00A00E0A                          2908                              * was NOT token
00A00E0A  323C 002C               2909      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1    * offset to NOT function
00A00E0E  60C4                    2910      BRA.s       LAB_1C13            * do set-up for function then execute
00A00E10                          2911  
00A00E10                          2912                              * wasn't +, - or NOT so ...
00A00E10                          2913  LAB_1BE7
00A00E10  B03C 00AB               2914      CMP.b       #TK_FN,d0           * compare with token for FN
00A00E14  6700 0514               2915      BEQ     LAB_201E            * if FN go evaluate FNx
00A00E18                          2916  
00A00E18                          2917                              * wasn't +, -, NOT or FN so ...
00A00E18  0400 00BF               2918      SUB.b       #TK_SGN,d0          * compare with token for SGN & normalise
00A00E1C  6500 F354               2919      BCS     LAB_SNER            * if < SGN token then do syntax error
00A00E20                          2920  
00A00E20                          2921  * get value from line .. continued
00A00E20                          2922  * only functions left so set up function references
00A00E20                          2923  
00A00E20                          2924  * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00A00E20                          2925  * to process function calls. now the function vector is computed and pushed on the stack
00A00E20                          2926  * and the preprocess offset is read. if the preprocess offset is non zero then the vector
00A00E20                          2927  * is calculated and the routine called, if not this routine just does RTS. whichever
00A00E20                          2928  * happens the RTS at the end of this routine, or the preprocess routine calls, the
00A00E20                          2929  * function code
00A00E20                          2930  
00A00E20                          2931  * this also removes some less than elegant code that was used to bypass type checking
00A00E20                          2932  * for functions that returned strings
00A00E20                          2933  
00A00E20  C07C 007F               2934      AND.w       #$7F,d0         * mask byte
00A00E24  D040                    2935      ADD.w       d0,d0               * *2 (2 bytes per function offset)
00A00E26                          2936  
00A00E26  41FA 20A4               2937      LEA     LAB_FTBL(pc),a0     * pointer to functions vector table
00A00E2A  3230 0000               2938      MOVE.w  (a0,d0.w),d1        * get function vector offset
00A00E2E  4870 1000               2939      PEA     (a0,d1.w)           * push function vector
00A00E32                          2940  
00A00E32  41FA 204C               2941      LEA     LAB_FTPP(pc),a0     * pointer to functions preprocess vector table
00A00E36  3030 0000               2942      MOVE.w  (a0,d0.w),d0        * get function preprocess vector offset
00A00E3A  6712                    2943      BEQ.s       LAB_1C2A            * no preprocess vector so go do function
00A00E3C                          2944  
00A00E3C  41F0 0000               2945      LEA     (a0,d0.w),a0        * get function preprocess vector
00A00E40  4ED0                    2946      JMP     (a0)                * go do preprocess routine then function
00A00E42                          2947  
00A00E42                          2948  
00A00E42                          2949  *************************************************************************************
00A00E42                          2950  *
00A00E42                          2951  * process string expression in parenthesis
00A00E42                          2952  
00A00E42                          2953  LAB_PPFS
00A00E42  6100 FF56               2954      BSR     LAB_1BF7            * process expression in parenthesis
00A00E46  4A2B 0E19               2955      TST.b       Dtypef(a3)          * test data type
00A00E4A  6A00 F2FA               2956      BPL     LAB_TMER            * if numeric do Type missmatch Error/warm start
00A00E4E                          2957  
00A00E4E                          2958  LAB_1C2A
00A00E4E  4E75                    2959      RTS                     * else do function
00A00E50                          2960  
00A00E50                          2961  
00A00E50                          2962  *************************************************************************************
00A00E50                          2963  *
00A00E50                          2964  * process numeric expression in parenthesis
00A00E50                          2965  
00A00E50                          2966  LAB_PPFN
00A00E50  6100 FF48               2967      BSR     LAB_1BF7            * process expression in parenthesis
00A00E54  4A2B 0E19               2968      TST.b       Dtypef(a3)          * test data type
00A00E58  6B00 F2EC               2969      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00A00E5C                          2970  
00A00E5C  4E75                    2971      RTS                     * else do function
00A00E5E                          2972  
00A00E5E                          2973  
00A00E5E                          2974  *************************************************************************************
00A00E5E                          2975  *
00A00E5E                          2976  * set numeric data type and increment BASIC execute pointer
00A00E5E                          2977  
00A00E5E                          2978  LAB_PPBI
00A00E5E  177C 0000 0E19          2979      MOVE.b  #$00,Dtypef(a3)     * clear data type flag, $00=float
00A00E64  101D                    2980      MOVE.b  (a5)+,d0            * get next BASIC byte
00A00E66  4E75                    2981      RTS                     * do function
00A00E68                          2982  
00A00E68                          2983  
00A00E68                          2984  *************************************************************************************
00A00E68                          2985  *
00A00E68                          2986  * process string for LEFT$, RIGHT$ or MID$
00A00E68                          2987  
00A00E68                          2988  LAB_LRMS
00A00E68  6100 FDE8               2989      BSR     LAB_EVEZ            * evaluate (should be string) expression
00A00E6C  4A2B 0E19               2990      TST.b       Dtypef(a3)          * test data type flag
00A00E70  6A00 F2D4               2991      BPL     LAB_TMER            * if type is not string do type mismatch error
00A00E74                          2992  
00A00E74  141D                    2993      MOVE.b  (a5)+,d2            * get BASIC byte
00A00E76  B43C 002C               2994      CMP.b       #',',d2         * compare with comma
00A00E7A  6600 F2F6               2995      BNE     LAB_SNER            * if not "," go do syntax error/warm start
00A00E7E                          2996  
00A00E7E  2F2B 0DF4               2997      MOVE.l  FAC1_m(a3),-(sp)        * save descriptor pointer
00A00E82  6100 08AA               2998      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00A00E86  205F                    2999      MOVEA.l (sp)+,a0            * restore descriptor pointer
00A00E88  4E75                    3000      RTS                     * do function
00A00E8A                          3001  
00A00E8A                          3002  
00A00E8A                          3003  *************************************************************************************
00A00E8A                          3004  *
00A00E8A                          3005  * process numeric expression(s) for BIN$ or HEX$
00A00E8A                          3006  
00A00E8A                          3007  LAB_BHSS
00A00E8A  6100 FDC6               3008      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00A00E8E  4A2B 0E19               3009      TST.b       Dtypef(a3)          * test data type
00A00E92  6B00 F2B2               3010      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00A00E96                          3011  
00A00E96  6100 0DCE               3012      BSR     LAB_2831            * convert FAC1 floating to fixed
00A00E9A                          3013                              * result in d0 and Itemp
00A00E9A  7200                    3014      MOVEQ       #0,d1               * set default to no leading "0"s
00A00E9C  141D                    3015      MOVE.b  (a5)+,d2            * get BASIC byte
00A00E9E  B43C 002C               3016      CMP.b       #',',d2         * compare with comma
00A00EA2  660C                    3017      BNE.s       LAB_BHCB            * if not "," go check close bracket
00A00EA4                          3018  
00A00EA4  2F00                    3019      MOVE.l  d0,-(sp)            * copy number to stack
00A00EA6  6100 0872               3020      BSR     LAB_GTBY            * get byte value
00A00EAA  2200                    3021      MOVE.l  d0,d1               * copy leading 0s #
00A00EAC  201F                    3022      MOVE.l  (sp)+,d0            * restore number from stack
00A00EAE  141D                    3023      MOVE.b  (a5)+,d2            * get BASIC byte
00A00EB0                          3024  LAB_BHCB
00A00EB0  B43C 0029               3025      CMP.b       #')',d2         * compare with close bracket
00A00EB4  6600 F2BC               3026      BNE     LAB_SNER            * if not ")" do Syntax Error/warm start
00A00EB8                          3027  
00A00EB8  4E75                    3028      RTS                     * go do function
00A00EBA                          3029  
00A00EBA                          3030  
00A00EBA                          3031  *************************************************************************************
00A00EBA                          3032  *
00A00EBA                          3033  * perform EOR
00A00EBA                          3034  
00A00EBA                          3035  LAB_EOR
00A00EBA  6116                    3036      BSR.s       GetFirst            * get two values for OR, AND or EOR
00A00EBC                          3037                              * first in d0, and Itemp, second in d2
00A00EBC  B580                    3038      EOR.l       d2,d0               * EOR values
00A00EBE  6000 03F0               3039      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A00EC2                          3040  
00A00EC2                          3041  
00A00EC2                          3042  *************************************************************************************
00A00EC2                          3043  *
00A00EC2                          3044  * perform OR
00A00EC2                          3045  
00A00EC2                          3046  LAB_OR
00A00EC2  610E                    3047      BSR.s       GetFirst            * get two values for OR, AND or EOR
00A00EC4                          3048                              * first in d0, and Itemp, second in d2
00A00EC4  8082                    3049      OR.l        d2,d0               * do OR
00A00EC6  6000 03E8               3050      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A00ECA                          3051  
00A00ECA                          3052  
00A00ECA                          3053  *************************************************************************************
00A00ECA                          3054  *
00A00ECA                          3055  * perform AND
00A00ECA                          3056  
00A00ECA                          3057  LAB_AND
00A00ECA  6106                    3058      BSR.s       GetFirst            * get two values for OR, AND or EOR
00A00ECC                          3059                              * first in d0, and Itemp, second in d2
00A00ECC  C082                    3060      AND.l       d2,d0               * do AND
00A00ECE  6000 03E0               3061      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A00ED2                          3062  
00A00ED2                          3063  
00A00ED2                          3064  *************************************************************************************
00A00ED2                          3065  *
00A00ED2                          3066  * get two values for OR, AND, EOR
00A00ED2                          3067  * first in d0, second in d2
00A00ED2                          3068  
00A00ED2                          3069  GetFirst
00A00ED2  6100 0228               3070      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00A00ED6                          3071                              * result in d0 and Itemp
00A00ED6  2400                    3072      MOVE.l  d0,d2               * copy second value
00A00ED8  6100 0CF4               3073      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00A00EDC                          3074                              * expression
00A00EDC  6000 021E               3075      BRA     LAB_EVIR            * evaluate integer expression (no sign check)
00A00EE0                          3076                              * result in d0 and Itemp & return
00A00EE0                          3077  
00A00EE0                          3078  
00A00EE0                          3079  *************************************************************************************
00A00EE0                          3080  *
00A00EE0                          3081  * perform NOT
00A00EE0                          3082  
00A00EE0                          3083  LAB_EQUAL
00A00EE0  6100 021A               3084      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00A00EE4                          3085                              * result in d0 and Itemp
00A00EE4  4680                    3086      NOT.l       d0              * bitwise invert
00A00EE6  6000 03C8               3087      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A00EEA                          3088  
00A00EEA                          3089  
00A00EEA                          3090  *************************************************************************************
00A00EEA                          3091  *
00A00EEA                          3092  * perform comparisons
00A00EEA                          3093  * do < compare
00A00EEA                          3094  
00A00EEA                          3095  LAB_LTHAN
00A00EEA  6100 FD50               3096      BSR     LAB_CKTM            * type match check, set C for string
00A00EEE  6506                    3097      BCS.s       LAB_1CAE            * branch if string
00A00EF0                          3098  
00A00EF0                          3099                              * do numeric < compare
00A00EF0  6100 0D48               3100      BSR     LAB_27FA            * compare FAC1 with FAC2
00A00EF4                          3101                              * returns d0=+1 if FAC1 > FAC2
00A00EF4                          3102                              * returns d0= 0 if FAC1 = FAC2
00A00EF4                          3103                              * returns d0=-1 if FAC1 < FAC2
00A00EF4  6042                    3104      BRA.s       LAB_1CF2            * process result
00A00EF6                          3105  
00A00EF6                          3106                              * do string < compare
00A00EF6                          3107  LAB_1CAE
00A00EF6  177C 0000 0E19          3108      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00A00EFC                          3109                              * $00=float
00A00EFC  6100 06BC               3110      BSR     LAB_22B6            * pop string off descriptor stack, or from top
00A00F00                          3111                              * of string space returns d0 = length,
00A00F00                          3112                              * a0 = pointer
00A00F00  2248                    3113      MOVEA.l a0,a1               * copy string 2 pointer
00A00F02  2200                    3114      MOVE.l  d0,d1               * copy string 2 length
00A00F04  206B 0DFC               3115      MOVEA.l FAC2_m(a3),a0       * get string 1 descriptor pointer
00A00F08  6100 06B4               3116      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00A00F0C                          3117                              * d0 = length, a0 = pointer
00A00F0C  2400                    3118      MOVE.l  d0,d2               * copy length
00A00F0E  6604                    3119      BNE.s       LAB_1CB5            * branch if not null string
00A00F10                          3120  
00A00F10  4A81                    3121      TST.l       d1              * test if string 2 is null also
00A00F12  6724                    3122      BEQ.s       LAB_1CF2            * if so do string 1 = string 2
00A00F14                          3123  
00A00F14                          3124  LAB_1CB5
00A00F14  9481                    3125      SUB.l       d1,d2               * subtract string 2 length
00A00F16  670C                    3126      BEQ.s       LAB_1CD5            * branch if strings = length
00A00F18                          3127  
00A00F18  6504                    3128      BCS.s       LAB_1CD4            * branch if string 1 < string 2
00A00F1A                          3129  
00A00F1A  70FF                    3130      MOVEQ       #-1,d0          * set for string 1 > string 2
00A00F1C  6008                    3131      BRA.s       LAB_1CD6            * go do character comapare
00A00F1E                          3132  
00A00F1E                          3133  LAB_1CD4
00A00F1E  2200                    3134      MOVE.l  d0,d1               * string 1 length is compare length
00A00F20  7001                    3135      MOVEQ       #1,d0               * and set for string 1 < string 2
00A00F22  6002                    3136      BRA.s       LAB_1CD6            * go do character comapare
00A00F24                          3137  
00A00F24                          3138  LAB_1CD5
00A00F24  2002                    3139      MOVE.l  d2,d0               * set for string 1 = string 2
00A00F26                          3140  LAB_1CD6
00A00F26  5381                    3141      SUBQ.l  #1,d1               * adjust length for DBcc loop
00A00F28                          3142  
00A00F28                          3143                              * d1 is length to compare, d0 is <=> for length
00A00F28                          3144                              * a0 is string 1 pointer, a1 is string 2 pointer
00A00F28                          3145  LAB_1CE6
00A00F28  B308                    3146      CMPM.b  (a0)+,(a1)+         * compare string bytes (1 with 2)
00A00F2A  56C9 FFFC               3147      DBNE        d1,LAB_1CE6         * loop if same and not end yet
00A00F2E                          3148  
00A00F2E  6708                    3149      BEQ.s       LAB_1CF2            * if = to here, then go use length compare
00A00F30                          3150  
00A00F30  6404                    3151      BCC.s       LAB_1CDB            * else branch if string 1 > string 2
00A00F32                          3152  
00A00F32  70FF                    3153      MOVEQ       #-1,d0          * else set for string 1 < string 2
00A00F34  6002                    3154      BRA.s       LAB_1CF2            * go set result
00A00F36                          3155  
00A00F36                          3156  LAB_1CDB
00A00F36  7001                    3157      MOVEQ       #1,d0               * and set for string 1 > string 2
00A00F38                          3158  
00A00F38                          3159  LAB_1CF2
00A00F38  5200                    3160      ADDQ.b  #1,d0               * make result 0, 1 or 2
00A00F3A  1200                    3161      MOVE.b  d0,d1               * copy to d1
00A00F3C  7001                    3162      MOVEQ       #1,d0               * set d0 longword
00A00F3E  E338                    3163      ROL.b       d1,d0               * make 1, 2 or 4 (result = flag bit)
00A00F40  C02B 0E45               3164      AND.b       Cflag(a3),d0        * AND with comparison evaluation flag
00A00F44  6700 0CDC               3165      BEQ     LAB_27DB            * exit if not a wanted result (i.e. false)
00A00F48                          3166  
00A00F48  70FF                    3167      MOVEQ       #-1,d0          * else set -1 (true)
00A00F4A  6000 0CD6               3168      BRA     LAB_27DB            * save d0 as integer & return
00A00F4E                          3169  
00A00F4E                          3170  
00A00F4E                          3171  LAB_1CFE
00A00F4E  6100 FE56               3172      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00A00F52                          3173  
00A00F52                          3174  
00A00F52                          3175  *************************************************************************************
00A00F52                          3176  *
00A00F52                          3177  * perform DIM
00A00F52                          3178  
00A00F52                          3179  LAB_DIM
00A00F52  72FF                    3180      MOVEQ       #-1,d1          * set "DIM" flag
00A00F54  6170                    3181      BSR.s       LAB_1D10            * search for or dimension a variable
00A00F56  6100 FE5A               3182      BSR     LAB_GBYT            * scan memory
00A00F5A  66F2                    3183      BNE.s       LAB_1CFE            * loop and scan for "," if not null
00A00F5C                          3184  
00A00F5C  4E75                    3185      RTS
00A00F5E                          3186  
00A00F5E                          3187  
00A00F5E                          3188  *************************************************************************************
00A00F5E                          3189  *
00A00F5E                          3190  * perform << (left shift)
00A00F5E                          3191  
00A00F5E                          3192  LAB_LSHIFT
00A00F5E  612E                    3193      BSR.s       GetPair         * get an integer and byte pair
00A00F60                          3194                              * byte is in d2, integer is in d0 and Itemp
00A00F60  6708                    3195      BEQ.s       NoShift         * branch if byte zero
00A00F62                          3196  
00A00F62  B43C 0020               3197      CMP.b       #$20,d2         * compare bit count with 32d
00A00F66  6420                    3198      BCC.s       TooBig          * branch if >=
00A00F68                          3199  
00A00F68  E5A0                    3200      ASL.l       d2,d0               * shift longword
00A00F6A                          3201  NoShift
00A00F6A  6000 0344               3202      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A00F6E                          3203  
00A00F6E                          3204  
00A00F6E                          3205  *************************************************************************************
00A00F6E                          3206  *
00A00F6E                          3207  * perform >> (right shift)
00A00F6E                          3208  
00A00F6E                          3209  LAB_RSHIFT
00A00F6E  611E                    3210      BSR.s       GetPair         * get an integer and byte pair
00A00F70                          3211                              * byte is in d2, integer is in d0 and Itemp
00A00F70  67F8                    3212      BEQ.s       NoShift         * branch if byte zero
00A00F72                          3213  
00A00F72  B43C 0020               3214      CMP.b       #$20,d2         * compare bit count with 32d
00A00F76  650A                    3215      BCS.s       Not2Big         * branch if >= (return shift)
00A00F78                          3216  
00A00F78  4A80                    3217      TST.l       d0              * test sign bit
00A00F7A  6A0C                    3218      BPL.s       TooBig          * branch if +ve
00A00F7C                          3219  
00A00F7C  70FF                    3220      MOVEQ       #-1,d0          * set longword
00A00F7E  6000 0330               3221      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00A00F82                          3222  
00A00F82                          3223  Not2Big
00A00F82  E4A0                    3224      ASR.l       d2,d0               * shift longword
00A00F84  6000 032A               3225      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00A00F88                          3226  
00A00F88                          3227  TooBig
00A00F88  7000                    3228      MOVEQ       #0,d0               * clear longword
00A00F8A  6000 0324               3229      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00A00F8E                          3230  
00A00F8E                          3231  
00A00F8E                          3232  *************************************************************************************
00A00F8E                          3233  *
00A00F8E                          3234  * get an integer and byte pair
00A00F8E                          3235  * byte is in d2, integer is in d0 and Itemp
00A00F8E                          3236  
00A00F8E                          3237  GetPair
00A00F8E  6100 078E               3238      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00A00F92                          3239                              * Itemp
00A00F92  1400                    3240      MOVE.b  d0,d2               * save it
00A00F94  6100 0C38               3241      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00A00F98                          3242                              * expression
00A00F98  6100 0162               3243      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00A00F9C                          3244                              * result in d0 and Itemp
00A00F9C  4A02                    3245      TST.b       d2              * test byte value
00A00F9E  4E75                    3246      RTS
00A00FA0                          3247  
00A00FA0                          3248  
00A00FA0                          3249  *************************************************************************************
00A00FA0                          3250  *
00A00FA0                          3251  * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
00A00FA0                          3252  
00A00FA0                          3253  LAB_CASC
00A00FA0  B03C 0061               3254      CMP.b       #$61,d0         * compare with "a"
00A00FA4  6410                    3255      BCC.s       LAB_1D83            * if >="a" go check =<"z"
00A00FA6                          3256  
00A00FA6                          3257  
00A00FA6                          3258  *************************************************************************************
00A00FA6                          3259  *
00A00FA6                          3260  * check alpha upper case, return C=0 if<"A" or >"Z"
00A00FA6                          3261  
00A00FA6                          3262  LAB_CAUC
00A00FA6  B03C 0041               3263      CMP.b       #$41,d0         * compare with "A"
00A00FAA  6404                    3264      BCC.s       LAB_1D8A            * if >="A" go check =<"Z"
00A00FAC                          3265  
00A00FAC  8040                    3266      OR      d0,d0               * make C=0
00A00FAE  4E75                    3267      RTS
00A00FB0                          3268  
00A00FB0                          3269  LAB_1D8A
00A00FB0  B03C 005B               3270      CMP.b       #$5B,d0         * compare with "Z"+1
00A00FB4                          3271                              * carry set if byte<="Z"
00A00FB4  4E75                    3272      RTS
00A00FB6                          3273  
00A00FB6                          3274  LAB_1D83
00A00FB6  B03C 007B               3275      CMP.b       #$7B,d0         * compare with "z"+1
00A00FBA                          3276                              * carry set if byte<="z"
00A00FBA  4E75                    3277      RTS
00A00FBC                          3278  
00A00FBC                          3279  
00A00FBC                          3280  *************************************************************************************
00A00FBC                          3281  *
00A00FBC                          3282  * search for or create variable. this is used to automatically create a variable if
00A00FBC                          3283  * it is not found. any routines that need to create the variable call LAB_GVAR via
00A00FBC                          3284  * this point and error generation is supressed and the variable will be created
00A00FBC                          3285  *
00A00FBC                          3286  * return pointer to variable in Cvaral and a0
00A00FBC                          3287  * set data type to variable type
00A00FBC                          3288  
00A00FBC                          3289  LAB_SVAR
00A00FBC  6102                    3290      BSR.s       LAB_GVAR            * search for variable
00A00FBE                          3291  LAB_FVAR
00A00FBE  4E75                    3292      RTS
00A00FC0                          3293  
00A00FC0                          3294  
00A00FC0                          3295  *************************************************************************************
00A00FC0                          3296  *
00A00FC0                          3297  * search for variable. if this routine is called from anywhere but the above call and
00A00FC0                          3298  * the variable searched for does not exist then an error will be returned
00A00FC0                          3299  *
00A00FC0                          3300  * DIM flag is in d1.b
00A00FC0                          3301  * return pointer to variable in Cvaral and a0
00A00FC0                          3302  * set data type to variable type
00A00FC0                          3303  
00A00FC0                          3304  LAB_GVAR
00A00FC0  7200                    3305      MOVEQ       #$00,d1         * set DIM flag = $00
00A00FC2  6100 FDEE               3306      BSR     LAB_GBYT            * scan memory (1st character)
00A00FC6                          3307  LAB_1D10
00A00FC6  1741 0E18               3308      MOVE.b  d1,Defdim(a3)       * save DIM flag
00A00FCA                          3309  
00A00FCA                          3310  * search for FN name entry point
00A00FCA                          3311  
00A00FCA                          3312  LAB_1D12
00A00FCA  61D4                    3313      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00A00FCC  6400 F1A4               3314      BCC     LAB_SNER            * if not, syntax error then warm start
00A00FD0                          3315  
00A00FD0                          3316                              * it is a variable name so ...
00A00FD0  7200                    3317      MOVEQ       #$0,d1          * set index for name byte
00A00FD2  41EB 0CCE               3318      LEA     Varname(a3),a0      * pointer to variable name
00A00FD6  2081                    3319      MOVE.l  d1,(a0)         * clear the variable name
00A00FD8  1741 0E19               3320      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
00A00FDC                          3321                              * $00=float
00A00FDC                          3322  
00A00FDC                          3323  LAB_1D2D
00A00FDC  B27C 0004               3324      CMP.w       #$04,d1         * done all significant characters?
00A00FE0  6406                    3325      BCC.s       LAB_1D2E            * if so go ignore any more
00A00FE2                          3326  
00A00FE2  1180 1000               3327      MOVE.b  d0,(a0,d1.w)        * save the character
00A00FE6  5241                    3328      ADDQ.w  #1,d1               * increment index
00A00FE8                          3329  LAB_1D2E
00A00FE8  6100 FDC6               3330      BSR     LAB_IGBY            * increment & scan memory (next character)
00A00FEC  65EE                    3331      BCS.s       LAB_1D2D            * branch if character = "0"-"9" (ok)
00A00FEE                          3332  
00A00FEE                          3333                              * character wasn't "0" to "9" so ...
00A00FEE  61B0                    3334      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00A00FF0  65EA                    3335      BCS.s       LAB_1D2D            * branch if = "A"-"Z" (ok)
00A00FF2                          3336  
00A00FF2                          3337                              * check if string variable
00A00FF2  B03C 0024               3338      CMP.b       #'$',d0         * compare with "$"
00A00FF6  660C                    3339      BNE.s       LAB_1D44            * branch if not string
00A00FF8                          3340  
00A00FF8                          3341                              * type is string
00A00FF8  002B 0080 0CCF          3342      OR.b        #$80,Varname+1(a3)  * set top bit of 2nd character, indicate string
00A00FFE  6100 FDB0               3343      BSR     LAB_IGBY            * increment & scan memory
00A01002  6010                    3344      BRA.s       LAB_1D45            * skip integer check
00A01004                          3345  
00A01004                          3346                              * check if integer variable
00A01004                          3347  LAB_1D44
00A01004  B03C 0026               3348      CMP.b       #'&',d0         * compare with "&"
00A01008  660A                    3349      BNE.s       LAB_1D45            * branch if not integer
00A0100A                          3350  
00A0100A                          3351                              * type is integer
00A0100A  002B 0080 0CD0          3352      OR.b        #$80,Varname+2(a3)  * set top bit of 3rd character, indicate integer
00A01010  6100 FD9E               3353      BSR     LAB_IGBY            * increment & scan memory
00A01014                          3354  
00A01014                          3355  * after we have determined the variable type we need to determine
00A01014                          3356  * if it's an array of type
00A01014                          3357  
00A01014                          3358                              * gets here with character after var name in d0
00A01014                          3359  LAB_1D45
00A01014  4A2B 0E43               3360      TST.b       Sufnxf(a3)          * test function name flag
00A01018  670E                    3361      BEQ.s       LAB_1D48            * if not FN or FN variable continue
00A0101A                          3362  
00A0101A  6A14                    3363      BPL.s       LAB_1D49            * if FN variable go find or create it
00A0101C                          3364  
00A0101C                          3365                              * else was FN name
00A0101C  202B 0CCE               3366      MOVE.l  Varname(a3),d0      * get whole function name
00A01020  7208                    3367      MOVEQ       #8,d1               * set step to next function size -4
00A01022  41EB 0C96               3368      LEA     Sfncl(a3),a0        * get pointer to start of functions
00A01026  601C                    3369      BRA.s       LAB_1D4B            * go find function
00A01028                          3370  
00A01028                          3371  LAB_1D48
00A01028  0400 0028               3372      SUB.b       #'(',d0         * subtract "("
00A0102C  6700 00F4               3373      BEQ     LAB_1E17            * if "(" go find, or make, array
00A01030                          3374  
00A01030                          3375  * either find or create var
00A01030                          3376  * var name (1st four characters only!) is in Varname
00A01030                          3377  
00A01030                          3378                              * variable name wasn't var( .. so look for
00A01030                          3379                              * plain variable
00A01030                          3380  LAB_1D49
00A01030  202B 0CCE               3381      MOVE.l  Varname(a3),d0      * get whole variable name
00A01034                          3382  LAB_1D4A
00A01034  7204                    3383      MOVEQ       #4,d1               * set step to next variable size -4
00A01036  41EB 0C9A               3384      LEA     Svarl(a3),a0        * get pointer to start of variables
00A0103A                          3385  
00A0103A  0800 0017               3386      BTST.l  #23,d0          * test if string name
00A0103E  6704                    3387      BEQ.s       LAB_1D4B            * branch if not
00A01040                          3388  
00A01040  5441                    3389      ADDQ.w  #2,d1               * 6 bytes per string entry
00A01042  5848                    3390      ADDQ.w  #(Sstrl-Svarl),a0       * move to string area
00A01044                          3391  
00A01044                          3392  LAB_1D4B
00A01044  2268 0004               3393      MOVEA.l 4(a0),a1            * get end address
00A01048  2050                    3394      MOVEA.l (a0),a0         * get start address
00A0104A  6006                    3395      BRA.s       LAB_1D5E            * enter loop at exit check
00A0104C                          3396  
00A0104C                          3397  LAB_1D5D
00A0104C  B098                    3398      CMP.l       (a0)+,d0            * compare this variable with name
00A0104E  6776                    3399      BEQ.s       LAB_1DD7            * branch if match (found var)
00A01050                          3400  
00A01050  D1C1                    3401      ADDA.l  d1,a0               * add offset to next variable
00A01052                          3402  LAB_1D5E
00A01052  B1C9                    3403      CMPA.l  a1,a0               * compare address with variable space end
00A01054  66F6                    3404      BNE.s       LAB_1D5D            * if not end go check next
00A01056                          3405  
00A01056  4A2B 0E43               3406      TST.b       Sufnxf(a3)          * is it a function or function variable
00A0105A  660A                    3407      BNE.s       LAB_1D94            * if was go do DEF or function variable
00A0105C                          3408  
00A0105C                          3409                              * reached end of variable mem without match
00A0105C                          3410                              * ... so create new variable, possibly
00A0105C                          3411  
00A0105C  45FA FF60               3412      LEA     LAB_FVAR(pc),a2     * get the address of the create if doesn't
00A01060                          3413                              * exist call to LAB_GVAR
00A01060  B5D7                    3414      CMPA.l  (sp),a2         * compare the return address with expected
00A01062  6600 F0CA               3415      BNE     LAB_UVER            * if not create go do error or return null
00A01066                          3416  
00A01066                          3417  * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
00A01066                          3418  
00A01066                          3419  LAB_1D94
00A01066  082B 0000 0E43          3420      BTST.b  #0,Sufnxf(a3)       * test function search flag
00A0106C  6600 F0C8               3421      BNE     LAB_UFER            * if not doing DEF then go do undefined
00A01070                          3422                              * function error
00A01070                          3423  
00A01070                          3424                              * else create new variable/function
00A01070                          3425  LAB_1D98
00A01070  246B 0CA6               3426      MOVEA.l Earryl(a3),a2       * get end of block to move
00A01074  240A                    3427      MOVE.l  a2,d2               * copy end of block to move
00A01076  9489                    3428      SUB.l       a1,d2               * calculate block to move size
00A01078                          3429  
00A01078  204A                    3430      MOVEA.l a2,a0               * copy end of block to move
00A0107A  5881                    3431      ADDQ.l  #4,d1               * space for one variable/function + name
00A0107C  D5C1                    3432      ADDA.l  d1,a2               * add space for one variable/function
00A0107E  274A 0CA6               3433      MOVE.l  a2,Earryl(a3)       * set new array mem end
00A01082  E28A                    3434      LSR.l       #1,d2               * /2 for word copy
00A01084  6712                    3435      BEQ.s       LAB_1DAF            * skip move if zero length block
00A01086                          3436  
00A01086  5382                    3437      SUBQ.l  #1,d2               * -1 for DFB loop
00A01088  4842                    3438      SWAP        d2              * swap high word to low word
00A0108A                          3439  LAB_1DAC
00A0108A  4842                    3440      SWAP        d2              * swap high word to low word
00A0108C                          3441  LAB_1DAE
00A0108C  3520                    3442      MOVE.w  -(a0),-(a2)         * copy word
00A0108E  51CA FFFC               3443      DBF     d2,LAB_1DAE         * loop until done
00A01092                          3444  
00A01092  4842                    3445      SWAP        d2              * swap high word to low word
00A01094  51CA FFF4               3446      DBF     d2,LAB_1DAC         * decrement high count and loop until done
00A01098                          3447  
00A01098                          3448  * get here after creating either a function, variable or string
00A01098                          3449  * if function set variables start, string start, array start
00A01098                          3450  * if variable set string start, array start
00A01098                          3451  * if string set array start
00A01098                          3452  
00A01098                          3453  LAB_1DAF
00A01098  4A2B 0E43               3454      TST.b       Sufnxf(a3)          * was it function
00A0109C  6B08                    3455      BMI.s       LAB_1DB0            * branch if was FN
00A0109E                          3456  
00A0109E  0800 0017               3457      BTST.l  #23,d0          * was it string
00A010A2  660A                    3458      BNE.s       LAB_1DB2            * branch if string
00A010A4                          3459  
00A010A4  6004                    3460      BRA.s       LAB_1DB1            * branch if was plain variable
00A010A6                          3461  
00A010A6                          3462  LAB_1DB0
00A010A6  D3AB 0C9A               3463      ADD.l       d1,Svarl(a3)        * set new variable memory start
00A010AA                          3464  LAB_1DB1
00A010AA  D3AB 0C9E               3465      ADD.l       d1,Sstrl(a3)        * set new start of strings
00A010AE                          3466  LAB_1DB2
00A010AE  D3AB 0CA2               3467      ADD.l       d1,Sarryl(a3)       * set new array memory start
00A010B2  20C0                    3468      MOVE.l  d0,(a0)+            * save variable/function name
00A010B4  20BC 00000000           3469      MOVE.l  #$00,(a0)           * initialise variable
00A010BA  0800 0017               3470      BTST.l  #23,d0          * was it string
00A010BE  6706                    3471      BEQ.s       LAB_1DD7            * branch if not string
00A010C0                          3472  
00A010C0  317C 0000 0004          3473      MOVE.w  #$00,4(a0)          * else initialise string length
00A010C6                          3474  
00A010C6                          3475                              * found a match for var ((Vrschl) = ptr)
00A010C6                          3476  LAB_1DD7
00A010C6  2200                    3477      MOVE.l  d0,d1               * ........ $....... &....... ........
00A010C8  D281                    3478      ADD.l       d1,d1               * .......$ .......& ........ .......0
00A010CA  4841                    3479      SWAP        d1              * ........ .......0 .......$ .......&
00A010CC  E219                    3480      ROR.b       #1,d1               * ........ .......0 .......$ &.......
00A010CE  E249                    3481      LSR.w       #1,d1               * ........ .......0 0....... $&......
00A010D0  C23C 00C0               3482      AND.b       #$C0,d1         * mask the type bits
00A010D4  1741 0E19               3483      MOVE.b  d1,Dtypef(a3)       * save the data type
00A010D8                          3484  
00A010D8  177C 0000 0E43          3485      MOVE.b  #$00,Sufnxf(a3)     * clear FN flag byte
00A010DE                          3486  
00A010DE                          3487  * if you want a non existant variable to return a null value then set the novar
00A010DE                          3488  * value at the top of this file to some non zero value
00A010DE                          3489  
00A010DE                 FALSE    3490   ifne   novar
00A010DE                          3491   endc
00A010DE                          3492  
00A010DE  4E75                    3493      RTS
00A010E0                          3494  
00A010E0                          3495  
00A010E0                          3496  *************************************************************************************
00A010E0                          3497  *
00A010E0                          3498  * set-up array pointer, d0, to first element in array
00A010E0                          3499  * set d0 to (a0)+2*(Dimcnt)+$0A
00A010E0                          3500  
00A010E0                          3501  LAB_1DE6
00A010E0  7005                    3502      MOVEQ       #5,d0               * set d0 to 5 (*2 = 10, later)
00A010E2  D02B 0E3F               3503      ADD.b       Dimcnt(a3),d0       * add # of dimensions (1, 2 or 3)
00A010E6  D080                    3504      ADD.l       d0,d0               * *2 (bytes per dimension size)
00A010E8  D088                    3505      ADD.l       a0,d0               * add array start pointer
00A010EA  4E75                    3506      RTS
00A010EC                          3507  
00A010EC                          3508  
00A010EC                          3509  *************************************************************************************
00A010EC                          3510  *
00A010EC                          3511  * evaluate unsigned integer expression
00A010EC                          3512  
00A010EC                          3513  LAB_EVIN
00A010EC  6100 FCC2               3514      BSR     LAB_IGBY            * increment & scan memory
00A010F0  6100 FB46               3515      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A010F4                          3516                              * else do type mismatch
00A010F4                          3517  
00A010F4                          3518  
00A010F4                          3519  *************************************************************************************
00A010F4                          3520  *
00A010F4                          3521  * evaluate positive integer expression, result in d0 and Itemp
00A010F4                          3522  
00A010F4                          3523  LAB_EVPI
00A010F4  4A2B 0DF9               3524      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00A010F8  6B00 F06C               3525      BMI     LAB_FCER            * do function call error if -ve
00A010FC                          3526  
00A010FC                          3527  
00A010FC                          3528  *************************************************************************************
00A010FC                          3529  *
00A010FC                          3530  * evaluate integer expression, no sign check
00A010FC                          3531  * result in d0 and Itemp, exit with flags set correctly
00A010FC                          3532  
00A010FC                          3533  LAB_EVIR
00A010FC  0C2B 00A0 0DF8          3534      CMPI.b  #$A0,FAC1_e(a3)     * compare exponent with exponent = 2^32 (n>2^31)
00A01102  6500 0B62               3535      BCS     LAB_2831            * convert FAC1 floating to fixed
00A01106                          3536                              * result in d0 and Itemp
00A01106  6600 F05E               3537      BNE     LAB_FCER            * if > do function call error, then warm start
00A0110A                          3538  
00A0110A  4A2B 0DF9               3539      TST.b       FAC1_s(a3)          * test sign of FAC1
00A0110E  6A00 0B56               3540      BPL     LAB_2831            * if +ve then ok
00A01112                          3541  
00A01112  202B 0DF4               3542      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A01116  4480                    3543      NEG.l       d0              * do -d0
00A01118  6800 F04C               3544      BVC     LAB_FCER            * if not $80000000 do FC error, then warm start
00A0111C                          3545  
00A0111C  2740 0C8E               3546      MOVE.l  d0,Itemp(a3)        * else just set it
00A01120  4E75                    3547      RTS
00A01122                          3548  
00A01122                          3549  
00A01122                          3550  *************************************************************************************
00A01122                          3551  *
00A01122                          3552  * find or make array
00A01122                          3553  
00A01122                          3554  LAB_1E17
00A01122  3F2B 0E18               3555      MOVE.w  Defdim(a3),-(sp)        * get DIM flag and data type flag (word in mem)
00A01126  7200                    3556      MOVEQ       #0,d1               * clear dimensions count
00A01128                          3557  
00A01128                          3558  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
00A01128                          3559  
00A01128                          3560  LAB_1E1F
00A01128  3F01                    3561      MOVE.w  d1,-(sp)            * save dimensions count
00A0112A  2F2B 0CCE               3562      MOVE.l  Varname(a3),-(sp)       * save variable name
00A0112E  61BC                    3563      BSR.s       LAB_EVIN            * evaluate integer expression
00A01130                          3564  
00A01130  4840                    3565      SWAP        d0              * swap high word to low word
00A01132  4A40                    3566      TST.w       d0              * test swapped high word
00A01134  6600 F020               3567      BNE     LAB_ABER            * if too big do array bounds error
00A01138                          3568  
00A01138  275F 0CCE               3569      MOVE.l  (sp)+,Varname(a3)       * restore variable name
00A0113C  321F                    3570      MOVE.w  (sp)+,d1            * restore dimensions count
00A0113E  301F                    3571      MOVE.w  (sp)+,d0            * restore DIM and data type flags
00A01140  3F2B 0C90               3572      MOVE.w  Itemp+2(a3),-(sp)       * stack this dimension size
00A01144  3F00                    3573      MOVE.w  d0,-(sp)            * save DIM and data type flags
00A01146  5241                    3574      ADDQ.w  #1,d1               * increment dimensions count
00A01148  6100 FC68               3575      BSR     LAB_GBYT            * scan memory
00A0114C  B03C 002C               3576      CMP.b       #$2C,d0         * compare with ","
00A01150  67D6                    3577      BEQ.s       LAB_1E1F            * if found go do next dimension
00A01152                          3578  
00A01152  1741 0E3F               3579      MOVE.b  d1,Dimcnt(a3)       * store dimensions count
00A01156  6100 FC46               3580      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A0115A  375F 0E18               3581      MOVE.w  (sp)+,Defdim(a3)        * restore DIM and data type flags (word in mem)
00A0115E  206B 0CA2               3582      MOVEA.l Sarryl(a3),a0       * get array mem start
00A01162                          3583  
00A01162                          3584  * now check to see if we are at the end of array memory (we would be if there were
00A01162                          3585  * no arrays).
00A01162                          3586  
00A01162                          3587  LAB_1E5C
00A01162  2748 0E10               3588      MOVE.l  a0,Astrtl(a3)       * save as array start pointer
00A01166  B1EB 0CA6               3589      CMPA.l  Earryl(a3),a0       * compare with array mem end
00A0116A  672E                    3590      BEQ.s       LAB_1EA1            * go build array if not found
00A0116C                          3591  
00A0116C                          3592                              * search for array
00A0116C  2010                    3593      MOVE.l  (a0),d0         * get this array name
00A0116E  B0AB 0CCE               3594      CMP.l       Varname(a3),d0      * compare with array name
00A01172  670A                    3595      BEQ.s       LAB_1E8D            * array found so branch
00A01174                          3596  
00A01174                          3597                              * no match
00A01174  2068 0004               3598      MOVEA.l 4(a0),a0            * get this array size
00A01178  D1EB 0E10               3599      ADDA.l  Astrtl(a3),a0       * add to array start pointer
00A0117C  60E4                    3600      BRA.s       LAB_1E5C            * go check next array
00A0117E                          3601  
00A0117E                          3602                              * found array, are we trying to dimension it?
00A0117E                          3603  LAB_1E8D
00A0117E  4A2B 0E18               3604      TST.b       Defdim(a3)          * are we trying to dimension it?
00A01182  6600 EFCE               3605      BNE     LAB_DDER            * if so do double dimension error/warm start
00A01186                          3606  
00A01186                          3607  * found the array and we're not dimensioning it so we must find an element in it
00A01186                          3608  
00A01186  6100 FF58               3609      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00A0118A                          3610                              * in the array
00A0118A  5048                    3611      ADDQ.w  #8,a0               * index to dimension count
00A0118C  3018                    3612      MOVE.w  (a0)+,d0            * get no of dimensions
00A0118E  B02B 0E3F               3613      CMP.b       Dimcnt(a3),d0       * compare with dimensions count
00A01192  6700 0094               3614      BEQ     LAB_1F28            * found array so go get element
00A01196                          3615  
00A01196  6000 EF8E               3616      BRA     LAB_WDER            * else wrong so do "Wrong dimensions" error
00A0119A                          3617  
00A0119A                          3618                              * array not found, so possibly build it
00A0119A                          3619  LAB_1EA1
00A0119A  4A2B 0E18               3620      TST.b       Defdim(a3)          * test the default DIM flag
00A0119E  6700 EF8A               3621      BEQ     LAB_UDER            * if default flag is clear then we are not
00A011A2                          3622                              * explicitly dimensioning an array so go
00A011A2                          3623                              * do an "Undimensioned array" error
00A011A2                          3624  
00A011A2  6100 FF3C               3625      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00A011A6                          3626                              * in the array
00A011A6  202B 0CCE               3627      MOVE.l  Varname(a3),d0      * get array name
00A011AA  20C0                    3628      MOVE.l  d0,(a0)+            * save array name
00A011AC  7204                    3629      MOVEQ       #4,d1               * set 4 bytes per element
00A011AE  0800 0017               3630      BTST.l  #23,d0          * test if string array
00A011B2  6702                    3631      BEQ.s       LAB_1EDF            * branch if not string
00A011B4                          3632  
00A011B4  7206                    3633      MOVEQ       #6,d1               * else 6 bytes per element
00A011B6                          3634  LAB_1EDF
00A011B6  2741 0E0C               3635      MOVE.l  d1,Asptl(a3)        * set array data size (bytes per element)
00A011BA  122B 0E3F               3636      MOVE.b  Dimcnt(a3),d1       * get dimensions count
00A011BE  5848                    3637      ADDQ.w  #4,a0               * skip the array size now (don't know it yet!)
00A011C0  30C1                    3638      MOVE.w  d1,(a0)+            * set array's dimensions count
00A011C2                          3639  
00A011C2                          3640  * now calculate the array data space size
00A011C2                          3641  
00A011C2                          3642  LAB_1EC0
00A011C2                          3643  
00A011C2                          3644  * If you want arrays to dimension themselves by default then comment out the test
00A011C2                          3645  * above and uncomment the next three code lines and the label LAB_1ED0
00A011C2                          3646  
00A011C2                          3647  *   MOVE.w  #$0A,d1         * set default dimension value, allow 0 to 9
00A011C2                          3648  *   TST.b       Defdim(a3)          * test default DIM flag
00A011C2                          3649  *   BNE.s       LAB_1ED0            * branch if b6 of Defdim is clear
00A011C2                          3650  
00A011C2  321F                    3651      MOVE.w  (sp)+,d1            * get dimension size
00A011C4                          3652  *LAB_1ED0
00A011C4  30C1                    3653      MOVE.w  d1,(a0)+            * save to array header
00A011C6  6100 00AE               3654      BSR     LAB_1F7C            * do this dimension size+1 * array size
00A011CA                          3655                              * (d1+1)*(Asptl), result in d0
00A011CA  2740 0E0C               3656      MOVE.l  d0,Asptl(a3)        * save array data size
00A011CE  532B 0E3F               3657      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00A011D2  66EE                    3658      BNE.s       LAB_1EC0            * loop while not = 0
00A011D4                          3659  
00A011D4  D1EB 0E0C               3660      ADDA.l  Asptl(a3),a0        * add size to first element address
00A011D8  6500 EF84               3661      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00A011DC                          3662  
00A011DC  B1EB 0CAA               3663      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00A011E0  650C                    3664      BCS.s       LAB_1ED6            * branch if less (is ok)
00A011E2                          3665  
00A011E2  6100 028E               3666      BSR     LAB_GARB            * do garbage collection routine
00A011E6  B1EB 0CAA               3667      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00A011EA  6400 EF72               3668      BCC     LAB_OMER            * if Sstorl <= a0 do "Out of memory"
00A011EE                          3669                              * error then warm start
00A011EE                          3670  
00A011EE                          3671  LAB_1ED6                        * ok exit, carry set
00A011EE  2748 0CA6               3672      MOVE.l  a0,Earryl(a3)       * save array mem end
00A011F2  7000                    3673      MOVEQ       #0,d0               * zero d0
00A011F4  222B 0E0C               3674      MOVE.l  Asptl(a3),d1        * get size in bytes
00A011F8  E289                    3675      LSR.l       #1,d1               * /2 for word fill (may be odd # words)
00A011FA  5341                    3676      SUBQ.w  #1,d1               * adjust for DBF loop
00A011FC                          3677  LAB_1ED8
00A011FC  3100                    3678      MOVE.w  d0,-(a0)            * decrement pointer and clear word
00A011FE  51C9 FFFC               3679      DBF     d1,LAB_1ED8         * decrement & loop until low word done
00A01202                          3680  
00A01202  4841                    3681      SWAP        d1              * swap words
00A01204  4A41                    3682      TST.w       d1              * test high word
00A01206  6706                    3683      BEQ.s       LAB_1F07            * exit if done
00A01208                          3684  
00A01208  5341                    3685      SUBQ.w  #1,d1               * decrement low (high) word
00A0120A  4841                    3686      SWAP        d1              * swap back
00A0120C  60EE                    3687      BRA.s       LAB_1ED8            * go do a whole block
00A0120E                          3688  
00A0120E                          3689  * now we need to calculate the array size by doing Earryl - Astrtl
00A0120E                          3690  
00A0120E                          3691  LAB_1F07
00A0120E  206B 0E10               3692      MOVEA.l Astrtl(a3),a0       * get for calculation and as pointer
00A01212  202B 0CA6               3693      MOVE.l  Earryl(a3),d0       * get array memory end
00A01216  9088                    3694      SUB.l       a0,d0               * calculate array size
00A01218  2140 0004               3695      MOVE.l  d0,4(a0)            * save size to array
00A0121C  4A2B 0E18               3696      TST.b       Defdim(a3)          * test default DIM flag
00A01220  6652                    3697      BNE.s       RTS_011         * exit (RET) if this was a DIM command
00A01222                          3698  
00A01222                          3699                              * else, find element
00A01222  5048                    3700      ADDQ.w  #8,a0               * index to dimension count
00A01224  3758 0E3F               3701      MOVE.w  (a0)+,Dimcnt(a3)        * get array's dimension count
00A01228                          3702  
00A01228                          3703  * we have found, or built, the array. now we need to find the element
00A01228                          3704  
00A01228                          3705  LAB_1F28
00A01228  7000                    3706      MOVEQ       #0,d0               * clear first result
00A0122A  2740 0E0C               3707      MOVE.l  d0,Asptl(a3)        * clear array data pointer
00A0122E                          3708  
00A0122E                          3709  * compare nth dimension bound (a0) with nth index (sp)+
00A0122E                          3710  * if greater do array bounds error
00A0122E                          3711  
00A0122E                          3712  LAB_1F2C
00A0122E  3218                    3713      MOVE.w  (a0)+,d1            * get nth dimension bound
00A01230  B257                    3714      CMP.w       (sp),d1         * compare nth index with nth dimension bound
00A01232  6500 EF22               3715      BCS     LAB_ABER            * if d1 less or = do array bounds error
00A01236                          3716  
00A01236                          3717  * now do pointer = pointer * nth dimension + nth index
00A01236                          3718  
00A01236  4A80                    3719      TST.l       d0              * test pointer
00A01238  6702                    3720      BEQ.s       LAB_1F5A            * skip multiply if last result = null
00A0123A                          3721  
00A0123A  613A                    3722      BSR.s       LAB_1F7C            * do this dimension size+1 * array size
00A0123C                          3723  LAB_1F5A
00A0123C  7200                    3724      MOVEQ       #0,d1               * clear longword
00A0123E  321F                    3725      MOVE.w  (sp)+,d1            * get nth dimension index
00A01240  D081                    3726      ADD.l       d1,d0               * add index to size
00A01242  2740 0E0C               3727      MOVE.l  d0,Asptl(a3)        * save array data pointer
00A01246                          3728  
00A01246  532B 0E3F               3729      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00A0124A  66E2                    3730      BNE.s       LAB_1F2C            * loop if dimensions still to do
00A0124C                          3731  
00A0124C  177C 0000 0E19          3732      MOVE.b  #0,Dtypef(a3)       * set data type to float
00A01252  7203                    3733      MOVEQ       #3,d1               * set for numeric array
00A01254  4A2B 0CCF               3734      TST.b       Varname+1(a3)       * test if string array
00A01258  6A0A                    3735      BPL.s       LAB_1F6A            * branch if not string
00A0125A                          3736  
00A0125A  7205                    3737      MOVEQ       #5,d1               * else set for string array
00A0125C  177C 0080 0E19          3738      MOVE.b  #$80,Dtypef(a3)     * and set data type to string
00A01262  600C                    3739      BRA.s       LAB_1F6B            * skip integer test
00A01264                          3740  
00A01264                          3741  LAB_1F6A
00A01264  4A2B 0CD0               3742      TST.b       Varname+2(a3)       * test if integer array
00A01268  6A06                    3743      BPL.s       LAB_1F6B            * branch if not integer
00A0126A                          3744  
00A0126A  177C 0040 0E19          3745      MOVE.b  #$40,Dtypef(a3)     * else set data type to integer
00A01270                          3746  LAB_1F6B
00A01270  6104                    3747      BSR.s       LAB_1F7C            * do element size (d1) * array size (Asptl)
00A01272  D1C0                    3748      ADDA.l  d0,a0               * add array data start pointer
00A01274                          3749  RTS_011
00A01274  4E75                    3750      RTS
00A01276                          3751  
00A01276                          3752  
00A01276                          3753  *************************************************************************************
00A01276                          3754  *
00A01276                          3755  * do this dimension size (d1) * array data size (Asptl)
00A01276                          3756  
00A01276                          3757  * do a 16 x 32 bit multiply
00A01276                          3758  * d1 holds the 16 bit multiplier
00A01276                          3759  * Asptl holds the 32 bit multiplicand
00A01276                          3760  
00A01276                          3761  * d0    bbbb  bbbb
00A01276                          3762  * d1    0000  aaaa
00A01276                          3763  *   ----------
00A01276                          3764  * d0    rrrr  rrrr
00A01276                          3765  
00A01276                          3766  LAB_1F7C
00A01276  202B 0E0C               3767      MOVE.l  Asptl(a3),d0        * get result
00A0127A  2400                    3768      MOVE.l  d0,d2               * copy it
00A0127C  4842                    3769      SWAP        d2              * shift high word to low word
00A0127E  C0C1                    3770      MULU.w  d1,d0               * d1 * low word = low result
00A01280  C4C1                    3771      MULU.w  d1,d2               * d1 * high word = high result
00A01282  4842                    3772      SWAP        d2              * align words for test
00A01284  4A42                    3773      TST.w       d2              * must be zero
00A01286  6600 EED6               3774      BNE     LAB_OMER            * if overflow go do "Out of memory" error
00A0128A                          3775  
00A0128A  D082                    3776      ADD.l       d2,d0               * calculate result
00A0128C  6500 EED0               3777      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00A01290                          3778  
00A01290  D0AB 0E0C               3779      ADD.l       Asptl(a3),d0        * add original
00A01294  6500 EEC8               3780      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00A01298                          3781  
00A01298  4E75                    3782      RTS
00A0129A                          3783  
00A0129A                          3784  
00A0129A                          3785  *************************************************************************************
00A0129A                          3786  *
00A0129A                          3787  * perform FRE()
00A0129A                          3788  
00A0129A                          3789  LAB_FRE
00A0129A  4A2B 0E19               3790      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00A0129E                          3791                              * $00=float
00A0129E  6A04                    3792      BPL.s       LAB_1FB4            * branch if numeric
00A012A0                          3793  
00A012A0  6100 0318               3794      BSR     LAB_22B6            * pop string off descriptor stack, or from
00A012A4                          3795                              * top of string space, returns d0 = length,
00A012A4                          3796                              * a0 = pointer
00A012A4                          3797  
00A012A4                          3798                              * FRE(n) was numeric so do this
00A012A4                          3799  LAB_1FB4
00A012A4  6100 01CC               3800      BSR     LAB_GARB            * go do garbage collection
00A012A8  202B 0CAA               3801      MOVE.l  Sstorl(a3),d0       * get bottom of string space
00A012AC  90AB 0CA6               3802      SUB.l       Earryl(a3),d0       * subtract array mem end
00A012B0                          3803  
00A012B0                          3804  
00A012B0                          3805  *************************************************************************************
00A012B0                          3806  *
00A012B0                          3807  * convert d0 to signed longword in FAC1
00A012B0                          3808  
00A012B0                          3809  LAB_AYFC
00A012B0  177C 0000 0E19          3810      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00A012B6                          3811                              * $00=float
00A012B6  377C A000 0DF8          3812      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent and clear sign (b7)
00A012BC  2740 0DF4               3813      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00A012C0  6A00 063E               3814      BPL     LAB_24D0            * convert if +ve
00A012C4                          3815  
00A012C4  003C 0001               3816      ORI.b       #1,CCR          * else set carry
00A012C8  6000 0636               3817      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00A012CC                          3818  
00A012CC                          3819  
00A012CC                          3820  *************************************************************************************
00A012CC                          3821  *
00A012CC                          3822  * remember if the line length is zero (infinite line) then POS(n) will return
00A012CC                          3823  * position MOD tabsize
00A012CC                          3824  
00A012CC                          3825  * perform POS()
00A012CC                          3826  
00A012CC                          3827  LAB_POS
00A012CC  102B 0E49               3828      MOVE.b  TPos(a3),d0         * get terminal position
00A012D0                          3829  
00A012D0                          3830  * convert d0 to unsigned byte in FAC1
00A012D0                          3831  
00A012D0                          3832  LAB_1FD0
00A012D0  C0BC 000000FF           3833      AND.l       #$FF,d0         * clear high bits
00A012D6  60D8                    3834      BRA.s       LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00A012D8                          3835  
00A012D8                          3836  * check not direct (used by DEF and INPUT)
00A012D8                          3837  
00A012D8                          3838  LAB_CKRN
00A012D8  4A2B 0CB6               3839      TST.b       Clinel(a3)          * test current line #
00A012DC  6B00 EE6C               3840      BMI     LAB_IDER            * if -ve go do illegal direct error then warm
00A012E0                          3841                              * start
00A012E0                          3842  
00A012E0  4E75                    3843      RTS                     * can continue so return
00A012E2                          3844  
00A012E2                          3845  
00A012E2                          3846  *************************************************************************************
00A012E2                          3847  *
00A012E2                          3848  * perform DEF
00A012E2                          3849  
00A012E2                          3850  LAB_DEF
00A012E2  70AB                    3851      MOVEQ       #TK_FN-$100,d0      * get FN token
00A012E4  6100 FAC2               3852      BSR     LAB_SCCA            * scan for CHR$(d0), else syntax error and
00A012E8                          3853                              * warm start
00A012E8                          3854                              * return character after d0
00A012E8  177C 0080 0E43          3855      MOVE.b  #$80,Sufnxf(a3)     * set FN flag bit
00A012EE  6100 FCDA               3856      BSR     LAB_1D12            * get FN name
00A012F2  2748 0E14               3857      MOVE.l  a0,func_l(a3)       * save function pointer
00A012F6                          3858  
00A012F6  61E0                    3859      BSR.s       LAB_CKRN            * check not direct (back here if ok)
00A012F8  0C1D 0028               3860      CMP.b       #$28,(a5)+          * check next byte is "(" and increment
00A012FC  6600 EE74               3861      BNE     LAB_SNER            * else do syntax error/warm start
00A01300                          3862  
00A01300  177C 007E 0E43          3863      MOVE.b  #$7E,Sufnxf(a3)     * set FN variable flag bits
00A01306  6100 FCB4               3864      BSR     LAB_SVAR            * search for or create a variable
00A0130A                          3865                              * return the variable address in a0
00A0130A  6100 FA92               3866      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A0130E  70BD                    3867      MOVEQ       #TK_EQUAL-$100,d0       * = token
00A01310  6100 FA96               3868      BSR     LAB_SCCA            * scan for CHR$(A), else syntax error/warm start
00A01314                          3869                              * return character after d0
00A01314  2F2B 0CCE               3870      MOVE.l  Varname(a3),-(sp)       * push current variable name
00A01318  2F0D                    3871      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00A0131A  6100 F41A               3872      BSR     LAB_DATA            * go perform DATA, find end of DEF FN statement
00A0131E  206B 0E14               3873      MOVEA.l func_l(a3),a0       * get the function pointer
00A01322  209F                    3874      MOVE.l  (sp)+,(a0)          * save BASIC execute pointer to function
00A01324  215F 0004               3875      MOVE.l  (sp)+,4(a0)         * save current variable name to function
00A01328  4E75                    3876      RTS
00A0132A                          3877  
00A0132A                          3878  
00A0132A                          3879  *************************************************************************************
00A0132A                          3880  *
00A0132A                          3881  * evaluate FNx
00A0132A                          3882  
00A0132A                          3883  LAB_201E
00A0132A  177C 0081 0E43          3884      MOVE.b  #$81,Sufnxf(a3)     * set FN flag (find not create)
00A01330  6100 FA7E               3885      BSR     LAB_IGBY            * increment & scan memory
00A01334  6100 FC94               3886      BSR     LAB_1D12            * get FN name
00A01338  1F2B 0E19               3887      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function type)
00A0133C  2F08                    3888      MOVE.l  a0,-(sp)            * push function pointer
00A0133E  0C15 0028               3889      CMP.b       #$28,(a5)           * check next byte is "(", no increment
00A01342  6600 EE2E               3890      BNE     LAB_SNER            * else do syntax error/warm start
00A01346                          3891  
00A01346  6100 FA52               3892      BSR     LAB_1BF7            * evaluate expression within parentheses
00A0134A  205F                    3893      MOVEA.l (sp)+,a0            * pop function pointer
00A0134C  2748 0E14               3894      MOVE.l  a0,func_l(a3)       * set function pointer
00A01350  1F2B 0E19               3895      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function expression type)
00A01354                          3896  
00A01354  2028 0004               3897      MOVE.l  4(a0),d0            * get function variable name
00A01358  6100 FCDA               3898      BSR     LAB_1D4A            * go find function variable (already created)
00A0135C                          3899  
00A0135C                          3900                              * now check type match for variable
00A0135C  101F                    3901      MOVE.b  (sp)+,d0            * pop data type flag (function expression type)
00A0135E  E318                    3902      ROL.b       #1,d0               * set carry if type = string
00A01360  6100 F8DA               3903      BSR     LAB_CKTM            * type match check, set C for string
00A01364                          3904  
00A01364                          3905                              * now stack the function variable value before
00A01364                          3906                              * use
00A01364  6712                    3907      BEQ.s       LAB_2043            * branch if not string
00A01366                          3908  
00A01366  43EB 0CDA               3909      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00A0136A  B9C9                    3910      CMPA.l  a1,a4               * compare string stack pointer with max+1
00A0136C  6700 EDD0               3911      BEQ     LAB_SCER            * if no space on the stack go do string too
00A01370                          3912                              * complex error
00A01370                          3913  
00A01370  3928 0004               3914      MOVE.w  4(a0),-(a4)         * string length on descriptor stack
00A01374  2910                    3915      MOVE.l  (a0),-(a4)          * string address on stack
00A01376  6002                    3916      BRA.s       LAB_204S            * skip var push
00A01378                          3917  
00A01378                          3918  LAB_2043
00A01378  2F10                    3919      MOVE.l  (a0),-(sp)          * push variable
00A0137A                          3920  LAB_204S
00A0137A  2F08                    3921      MOVE.l  a0,-(sp)            * push variable address
00A0137C  1F2B 0E19               3922      MOVE.b  Dtypef(a3),-(sp)        * push variable data type
00A01380                          3923  
00A01380  6132                    3924      BSR.s       LAB_2045            * pack function expression value into (a0)
00A01382                          3925                              * (function variable)
00A01382  2F0D                    3926      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00A01384  206B 0E14               3927      MOVEA.l func_l(a3),a0       * get function pointer
00A01388  2A50                    3928      MOVEA.l (a0),a5         * save function execute ptr as BASIC execute ptr
00A0138A  6100 F8C4               3929      BSR     LAB_EVEX            * evaluate expression
00A0138E  6100 FA22               3930      BSR     LAB_GBYT            * scan memory
00A01392  6600 EDDE               3931      BNE     LAB_SNER            * if not [EOL] or [EOS] do syntax error and
00A01396                          3932                              * warm start
00A01396                          3933  
00A01396  2A5F                    3934      MOVE.l  (sp)+,a5            * restore BASIC execute pointer
00A01398                          3935  
00A01398                          3936  * restore variable from stack and test data type
00A01398                          3937  
00A01398  101F                    3938      MOVE.b  (sp)+,d0            * pull variable data type
00A0139A  205F                    3939      MOVEA.l (sp)+,a0            * pull variable address
00A0139C  4A00                    3940      TST.b       d0              * test variable data type
00A0139E  6A08                    3941      BPL.s       LAB_204T            * branch if not string
00A013A0                          3942  
00A013A0  209C                    3943      MOVE.l  (a4)+,(a0)          * string address from descriptor stack
00A013A2  315C 0004               3944      MOVE.w  (a4)+,4(a0)         * string length from descriptor stack
00A013A6  6002                    3945      BRA.s       LAB_2044            * skip variable pull
00A013A8                          3946  
00A013A8                          3947  LAB_204T
00A013A8  209F                    3948      MOVE.l  (sp)+,(a0)          * restore variable from stack
00A013AA                          3949  LAB_2044
00A013AA  101F                    3950      MOVE.b  (sp)+,d0            * pop data type flag (function type)
00A013AC  E318                    3951      ROL.b       #1,d0               * set carry if type = string
00A013AE  6100 F88C               3952      BSR     LAB_CKTM            * type match check, set C for string
00A013B2  4E75                    3953      RTS
00A013B4                          3954  
00A013B4                          3955  LAB_2045
00A013B4  4A2B 0E19               3956      TST.b       Dtypef(a3)          * test data type
00A013B8  6A00 07EE               3957      BPL     LAB_2778            * if numeric pack FAC1 into variable (a0)
00A013BC                          3958                              * and return
00A013BC                          3959  
00A013BC  2448                    3960      MOVEA.l a0,a2               * copy variable pointer
00A013BE  6000 F514               3961      BRA     LAB_17D6            * go do string LET & return
00A013C2                          3962  
00A013C2                          3963  
00A013C2                          3964  
00A013C2                          3965  *************************************************************************************
00A013C2                          3966  *
00A013C2                          3967  * perform STR$()
00A013C2                          3968  
00A013C2                          3969  LAB_STRS
00A013C2  6100 094A               3970      BSR     LAB_2970            * convert FAC1 to string
00A013C6                          3971  
00A013C6                          3972  * scan, set up string
00A013C6                          3973  * print " terminated string to FAC1 stack
00A013C6                          3974  
00A013C6                          3975  LAB_20AE
00A013C6  7422                    3976      MOVEQ       #$22,d2         * set Srchc character (terminator 1)
00A013C8  3602                    3977      MOVE.w  d2,d3               * set Asrch character (terminator 2)
00A013CA                          3978  
00A013CA                          3979  * print d2/d3 terminated string to FAC1 stack
00A013CA                          3980  * d2 = Srchc, d3 = Asrch, a0 is source
00A013CA                          3981  * a6 is temp
00A013CA                          3982  
00A013CA                          3983  LAB_20B4
00A013CA  7200                    3984      MOVEQ       #0,d1               * clear longword
00A013CC  5341                    3985      SUBQ.w  #1,d1               * set length to -1
00A013CE  2448                    3986      MOVEA.l a0,a2               * copy start to calculate end
00A013D0                          3987  LAB_20BE
00A013D0  5241                    3988      ADDQ.w  #1,d1               * increment length
00A013D2  1030 1000               3989      MOVE.b  (a0,d1.w),d0        * get byte from string
00A013D6  6710                    3990      BEQ.s       LAB_20D0            * exit loop if null byte [EOS]
00A013D8                          3991  
00A013D8  B002                    3992      CMP.b       d2,d0               * compare with search character (terminator 1)
00A013DA  6704                    3993      BEQ.s       LAB_20CB            * branch if terminator
00A013DC                          3994  
00A013DC  B003                    3995      CMP.b       d3,d0               * compare with terminator 2
00A013DE  66F0                    3996      BNE.s       LAB_20BE            * loop if not terminator 2 (or null string)
00A013E0                          3997  
00A013E0                          3998  LAB_20CB
00A013E0  B03C 0022               3999      CMP.b       #$22,d0         * compare with "
00A013E4  6602                    4000      BNE.s       LAB_20D0            * branch if not "
00A013E6                          4001  
00A013E6  524A                    4002      ADDQ.w  #1,a2               * else increment string start (skip " at end)
00A013E8                          4003  LAB_20D0
00A013E8  D5C1                    4004      ADDA.l  d1,a2               * add longowrd length to make string end+1
00A013EA                          4005  
00A013EA  B1CB                    4006      CMPA.l  a3,a0               * is string in ram
00A013EC  651E                    4007      BCS.s       LAB_RTST            * if not go push descriptor on stack & exit
00A013EE                          4008                              * (could be message string from ROM)
00A013EE                          4009  
00A013EE  B1EB 0C92               4010      CMPA.l  Smeml(a3),a0        * is string in utility ram
00A013F2  6418                    4011      BCC.s       LAB_RTST            * if not go push descriptor on stack & exit
00A013F4                          4012                              * (is in string or program space)
00A013F4                          4013  
00A013F4                          4014                              * (else) copy string to string memory
00A013F4                          4015  LAB_20C9
00A013F4  2248                    4016      MOVEA.l a0,a1               * copy descriptor pointer
00A013F6  2001                    4017      MOVE.l  d1,d0               * copy longword length
00A013F8  6604                    4018      BNE.s       LAB_20D8            * branch if not null string
00A013FA                          4019  
00A013FA  2041                    4020      MOVEA.l d1,a0               * make null pointer
00A013FC  600E                    4021      BRA.s       LAB_RTST            * go push descriptor on stack & exit
00A013FE                          4022  
00A013FE                          4023  LAB_20D8
00A013FE  6126                    4024      BSR.s       LAB_2115            * make string space d1 bytes long
00A01400  D1C1                    4025      ADDA.l  d1,a0               * new string end
00A01402  D3C1                    4026      ADDA.l  d1,a1               * old string end
00A01404  5340                    4027      SUBQ.w  #1,d0               * -1 for DBF loop
00A01406                          4028  LAB_20E0
00A01406  1121                    4029      MOVE.b  -(a1),-(a0)         * copy byte (source can be odd aligned)
00A01408  51C8 FFFC               4030      DBF     d0,LAB_20E0         * loop until done
00A0140C                          4031  
00A0140C                          4032  
00A0140C                          4033  
00A0140C                          4034  *************************************************************************************
00A0140C                          4035  *
00A0140C                          4036  * check for space on descriptor stack then ...
00A0140C                          4037  * put string address and length on descriptor stack & update stack pointers
00A0140C                          4038  * start is in a0, length is in d1
00A0140C                          4039  
00A0140C                          4040  LAB_RTST
00A0140C  43EB 0CDA               4041      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00A01410  B9C9                    4042      CMPA.l  a1,a4               * compare string stack pointer with max+1
00A01412  6700 ED2A               4043      BEQ     LAB_SCER            * if no space on string stack ..
00A01416                          4044                              * .. go do 'string too complex' error
00A01416                          4045  
00A01416                          4046                              * push string & update pointers
00A01416  3901                    4047      MOVE.w  d1,-(a4)            * string length on descriptor stack
00A01418  2908                    4048      MOVE.l  a0,-(a4)            * string address on stack
00A0141A  274C 0DF4               4049      MOVE.l  a4,FAC1_m(a3)       * string descriptor pointer in FAC1
00A0141E  177C 0080 0E19          4050      MOVE.b  #$80,Dtypef(a3)     * save data type flag, $80=string
00A01424  4E75                    4051      RTS
00A01426                          4052  
00A01426                          4053  
00A01426                          4054  *************************************************************************************
00A01426                          4055  *
00A01426                          4056  * build descriptor a0/d1
00A01426                          4057  * make space in string memory for string d1.w long
00A01426                          4058  * return pointer in a0/Sutill
00A01426                          4059  
00A01426                          4060  LAB_2115
00A01426  4A41                    4061      TST.w       d1              * test length
00A01428  672E                    4062      BEQ.s       LAB_2128            * branch if user wants null string
00A0142A                          4063  
00A0142A                          4064                              * make space for string d1 long
00A0142A  2F00                    4065      MOVE.l  d0,-(sp)            * save d0
00A0142C  7000                    4066      MOVEQ       #0,d0               * clear longword
00A0142E  1740 0E42               4067      MOVE.b  d0,Gclctd(a3)       * clear garbage collected flag (b7)
00A01432  7001                    4068      MOVEQ       #1,d0               * +1 to possibly round up
00A01434  C041                    4069      AND.w       d1,d0               * mask odd bit
00A01436  D041                    4070      ADD.w       d1,d0               * ensure d0 is even length
00A01438  6404                    4071      BCC.s       LAB_2117            * branch if no overflow
00A0143A                          4072  
00A0143A  7001                    4073      MOVEQ       #1,d0               * set to allocate 65536 bytes
00A0143C  4840                    4074      SWAP        d0              * makes $00010000
00A0143E                          4075  LAB_2117
00A0143E  206B 0CAA               4076      MOVEA.l Sstorl(a3),a0       * get bottom of string space
00A01442  91C0                    4077      SUBA.l  d0,a0               * subtract string length
00A01444  B1EB 0CA6               4078      CMPA.l  Earryl(a3),a0       * compare with top of array space
00A01448  6512                    4079      BCS.s       LAB_2137            * if less do out of memory error
00A0144A                          4080  
00A0144A  2748 0CAA               4081      MOVE.l  a0,Sstorl(a3)       * save bottom of string space
00A0144E  2748 0CB2               4082      MOVE.l  a0,Sutill(a3)       * save string utility pointer
00A01452  201F                    4083      MOVE.l  (sp)+,d0            * restore d0
00A01454  4A41                    4084      TST.w       d1              * set flags on length
00A01456  4E75                    4085      RTS
00A01458                          4086  
00A01458                          4087  LAB_2128
00A01458  3041                    4088      MOVEA.w d1,a0               * make null pointer
00A0145A  4E75                    4089      RTS
00A0145C                          4090  
00A0145C                          4091  LAB_2137
00A0145C  4A2B 0E42               4092      TST.b       Gclctd(a3)          * get garbage collected flag
00A01460  6B00 ECFC               4093      BMI     LAB_OMER            * do "Out of memory" error, then warm start
00A01464                          4094  
00A01464  2F09                    4095      MOVE.l  a1,-(sp)            * save a1
00A01466  610A                    4096      BSR.s       LAB_GARB            * else go do garbage collection
00A01468  225F                    4097      MOVEA.l (sp)+,a1            * restore a1
00A0146A  177C 0080 0E42          4098      MOVE.b  #$80,Gclctd(a3)     * set garbage collected flag
00A01470  60CC                    4099      BRA.s       LAB_2117            * go try again
00A01472                          4100  
00A01472                          4101  
00A01472                          4102  *************************************************************************************
00A01472                          4103  *
00A01472                          4104  * garbage collection routine
00A01472                          4105  
00A01472                          4106  LAB_GARB
00A01472  48E7 E0E0               4107      MOVEM.l d0-d2/a0-a2,-(sp)       * save registers
00A01476  276B 0CAE 0CAA          4108      MOVE.l  Ememl(a3),Sstorl(a3)    * start with no strings
00A0147C                          4109  
00A0147C                          4110                              * re-run routine from last ending
00A0147C                          4111  LAB_214B
00A0147C  222B 0CA6               4112      MOVE.l  Earryl(a3),d1       * set highest uncollected string so far
00A01480  7000                    4113      MOVEQ       #0,d0               * clear longword
00A01482  2240                    4114      MOVEA.l d0,a1               * clear string to move pointer
00A01484  206B 0C9E               4115      MOVEA.l Sstrl(a3),a0        * set pointer to start of strings
00A01488  41E8 0004               4116      LEA     4(a0),a0            * index to string pointer
00A0148C  246B 0CA2               4117      MOVEA.l Sarryl(a3),a2       * set end pointer to start of arrays (end of
00A01490                          4118                              * strings)
00A01490  6008                    4119      BRA.s       LAB_2176            * branch into loop at end loop test
00A01492                          4120  
00A01492                          4121  LAB_2161
00A01492  6100 0084               4122      BSR     LAB_2206            * test and set if this is the highest string
00A01496  41E8 000A               4123      LEA     10(a0),a0           * increment to next string
00A0149A                          4124  LAB_2176
00A0149A  B1CA                    4125      CMPA.l  a2,a0               * compare end of area with pointer
00A0149C  65F4                    4126      BCS.s       LAB_2161            * go do next if not at end
00A0149E                          4127  
00A0149E                          4128  * done strings, now do arrays.
00A0149E                          4129  
00A0149E  41E8 FFFC               4130      LEA     -4(a0),a0           * decrement pointer to start of arrays
00A014A2  246B 0CA6               4131      MOVEA.l Earryl(a3),a2       * set end pointer to end of arrays
00A014A6  6024                    4132      BRA.s       LAB_218F            * branch into loop at end loop test
00A014A8                          4133  
00A014A8                          4134  LAB_217E
00A014A8  2428 0004               4135      MOVE.l  4(a0),d2            * get array size
00A014AC  D488                    4136      ADD.l       a0,d2               * makes start of next array
00A014AE                          4137  
00A014AE  2010                    4138      MOVE.l  (a0),d0         * get array name
00A014B0  0800 0017               4139      BTST        #23,d0          * test string flag
00A014B4  6714                    4140      BEQ.s       LAB_218B            * branch if not string
00A014B6                          4141  
00A014B6  3028 0008               4142      MOVE.w  8(a0),d0            * get # of dimensions
00A014BA  D040                    4143      ADD.w       d0,d0               * *2
00A014BC  D0C0                    4144      ADDA.w  d0,a0               * add to skip dimension size(s)
00A014BE  41E8 000A               4145      LEA     10(a0),a0           * increment to first element
00A014C2                          4146  LAB_2183
00A014C2  6154                    4147      BSR.s       LAB_2206            * test and set if this is the highest string
00A014C4  5C48                    4148      ADDQ.w  #6,a0               * increment to next element
00A014C6  B1C2                    4149      CMPA.l  d2,a0               * compare with start of next array
00A014C8  66F8                    4150      BNE.s       LAB_2183            * go do next if not at end of array
00A014CA                          4151  
00A014CA                          4152  LAB_218B
00A014CA  2042                    4153      MOVEA.l d2,a0               * pointer to next array
00A014CC                          4154  LAB_218F
00A014CC  B5C8                    4155      CMPA.l  a0,a2               * compare pointer with array end
00A014CE  66D8                    4156      BNE.s       LAB_217E            * go do next if not at end
00A014D0                          4157  
00A014D0                          4158  * done arrays and variables, now just the descriptor stack to do
00A014D0                          4159  
00A014D0  204C                    4160      MOVEA.l a4,a0               * get descriptor stack pointer
00A014D2  45EB 0CF2               4161      LEA     des_sk(a3),a2       * set end pointer to end of stack
00A014D6  6006                    4162      BRA.s       LAB_21C4            * branch into loop at end loop test
00A014D8                          4163  
00A014D8                          4164  LAB_21C2
00A014D8  613E                    4165      BSR.s       LAB_2206            * test and set if this is the highest string
00A014DA  41E8 0006               4166      LEA     6(a0),a0            * increment to next string
00A014DE                          4167  LAB_21C4
00A014DE  B5C8                    4168      CMPA.l  a0,a2               * compare pointer with stack end
00A014E0  66F6                    4169      BNE.s       LAB_21C2            * go do next if not at end
00A014E2                          4170  
00A014E2                          4171  * descriptor search complete, now either exit or set-up and move string
00A014E2                          4172  
00A014E2  2009                    4173      MOVE.l  a1,d0               * set the flags (a1 is move string)
00A014E4  672C                    4174      BEQ.s       LAB_21D1            * go tidy up and exit if no move
00A014E6                          4175  
00A014E6  2051                    4176      MOVEA.l (a1),a0         * a0 is now string start
00A014E8  7200                    4177      MOVEQ       #0,d1               * clear d1
00A014EA  3229 0004               4178      MOVE.w  4(a1),d1            * d1 is string length
00A014EE  5281                    4179      ADDQ.l  #1,d1               * +1
00A014F0  C23C 00FE               4180      AND.b       #$FE,d1         * make even length
00A014F4  D1C1                    4181      ADDA.l  d1,a0               * pointer is now to string end+1
00A014F6  246B 0CAA               4182      MOVEA.l Sstorl(a3),a2       * is destination end+1
00A014FA  B1CA                    4183      CMPA.l  a2,a0               * does the string need moving
00A014FC  670C                    4184      BEQ.s       LAB_2240            * branch if not
00A014FE                          4185  
00A014FE  E289                    4186      LSR.l       #1,d1               * word move so do /2
00A01500  5341                    4187      SUBQ.w  #1,d1               * -1 for DBF loop
00A01502                          4188  LAB_2216
00A01502  3520                    4189      MOVE.w  -(a0),-(a2)         * copy word
00A01504  51C9 FFFC               4190      DBF     d1,LAB_2216         * loop until done
00A01508                          4191  
00A01508  228A                    4192      MOVE.l  a2,(a1)         * save new string start
00A0150A                          4193  LAB_2240
00A0150A  2751 0CAA               4194      MOVE.l  (a1),Sstorl(a3)     * string start is new string mem start
00A0150E  6000 FF6C               4195      BRA     LAB_214B            * re-run routine from last ending
00A01512                          4196                              * (but don't collect this string)
00A01512                          4197  
00A01512                          4198  LAB_21D1
00A01512  4CDF 0707               4199      MOVEM.l (sp)+,d0-d2/a0-a2       * restore registers
00A01516  4E75                    4200      RTS
00A01518                          4201  
00A01518                          4202  * test and set if this is the highest string
00A01518                          4203  
00A01518                          4204  LAB_2206
00A01518  2010                    4205      MOVE.l  (a0),d0         * get this string pointer
00A0151A  6728                    4206      BEQ.s       RTS_012         * exit if null string
00A0151C                          4207  
00A0151C  B280                    4208      CMP.l       d0,d1               * compare with highest uncollected string so far
00A0151E  6424                    4209      BCC.s       RTS_012         * exit if <= with highest so far
00A01520                          4210  
00A01520  B0AB 0CAA               4211      CMP.l       Sstorl(a3),d0       * compare with bottom of string space
00A01524  641E                    4212      BCC.s       RTS_012         * exit if >= bottom of string space
00A01526                          4213  
00A01526  70FF                    4214      MOVEQ       #-1,d0          * d0 = $FFFFFFFF
00A01528  3028 0004               4215      MOVE.w  4(a0),d0            * d0 is string length
00A0152C  4440                    4216      NEG.w       d0              * make -ve
00A0152E  C03C 00FE               4217      AND.b       #$FE,d0         * make -ve even length
00A01532  D0AB 0CAA               4218      ADD.l       Sstorl(a3),d0       * add string store to -ve length
00A01536  B090                    4219      CMP.l       (a0),d0         * compare with string address
00A01538  6706                    4220      BEQ.s       LAB_2212            * if = go move string store pointer down
00A0153A                          4221  
00A0153A  2210                    4222      MOVE.l  (a0),d1         * highest = current
00A0153C  2248                    4223      MOVEA.l a0,a1               * string to move = current
00A0153E  4E75                    4224      RTS
00A01540                          4225  
00A01540                          4226  LAB_2212
00A01540  2740 0CAA               4227      MOVE.l  d0,Sstorl(a3)       * set new string store start
00A01544                          4228  RTS_012
00A01544  4E75                    4229      RTS
00A01546                          4230  
00A01546                          4231  
00A01546                          4232  *************************************************************************************
00A01546                          4233  *
00A01546                          4234  * concatenate - add strings
00A01546                          4235  * string descriptor 1 is in FAC1_m, string 2 is in line
00A01546                          4236  
00A01546                          4237  LAB_224D
00A01546  487A F73A               4238      PEA     LAB_1ADB(pc)        * continue evaluation after concatenate
00A0154A  2F2B 0DF4               4239      MOVE.l  FAC1_m(a3),-(sp)        * stack descriptor pointer for string 1
00A0154E                          4240  
00A0154E  6100 F80E               4241      BSR     LAB_GVAL            * get value from line
00A01552  4A2B 0E19               4242      TST.b       Dtypef(a3)          * test data type flag
00A01556  6A00 EBEE               4243      BPL     LAB_TMER            * if type is not string do type mismatch error
00A0155A                          4244  
00A0155A  205F                    4245      MOVEA.l (sp)+,a0            * restore descriptor pointer for string 1
00A0155C                          4246  
00A0155C                          4247  *************************************************************************************
00A0155C                          4248  *
00A0155C                          4249  * concatenate
00A0155C                          4250  * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
00A0155C                          4251  
00A0155C                          4252  LAB_224E
00A0155C  226B 0DF4               4253      MOVEA.l FAC1_m(a3),a1       * copy descriptor pointer 2
00A01560  3228 0004               4254      MOVE.w  4(a0),d1            * get length 1
00A01564  D269 0004               4255      ADD.w       4(a1),d1            * add length 2
00A01568  6500 EBD8               4256      BCS     LAB_SLER            * if overflow go do 'string too long' error
00A0156C                          4257  
00A0156C  2F08                    4258      MOVE.l  a0,-(sp)            * save descriptor pointer 1
00A0156E  6100 FEB6               4259      BSR     LAB_2115            * make space d1 bytes long
00A01572  2748 0DFC               4260      MOVE.l  a0,FAC2_m(a3)       * save new string start pointer
00A01576  2057                    4261      MOVEA.l (sp),a0         * copy descriptor pointer 1 from stack
00A01578  3028 0004               4262      MOVE.w  4(a0),d0            * get length
00A0157C  2050                    4263      MOVEA.l (a0),a0         * get string pointer
00A0157E  6120                    4264      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00A01580                          4265                              * return with a0 = pointer, d1 = length
00A01580                          4266  
00A01580  206B 0DF4               4267      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer for string 2
00A01584  6138                    4268      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00A01586                          4269                              * a0 = pointer, d0 = length
00A01586  6118                    4270      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00A01588                          4271                              * return with a0 = pointer, d1 = length
00A01588                          4272  
00A01588  205F                    4273      MOVEA.l (sp)+,a0            * get descriptor pointer for string 1
00A0158A  6132                    4274      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00A0158C                          4275                              * d0 = length, a0 = pointer
00A0158C                          4276  
00A0158C  206B 0DFC               4277      MOVEA.l FAC2_m(a3),a0       * retreive the result string pointer
00A01590  2208                    4278      MOVE.l  a0,d1               * copy the result string pointer
00A01592  6700 FE78               4279      BEQ     LAB_RTST            * if it is a null string just return it
00A01596                          4280                              * a0 = pointer, d1 = length
00A01596                          4281  
00A01596  4481                    4282      NEG.l       d1              * else make the start pointer negative
00A01598  D2AB 0CB2               4283      ADD.l       Sutill(a3),d1       * add the end pointert to give the length
00A0159C  6000 FE6E               4284      BRA     LAB_RTST            * push string on descriptor stack
00A015A0                          4285                              * a0 = pointer, d1 = length
00A015A0                          4286  
00A015A0                          4287  
00A015A0                          4288  *************************************************************************************
00A015A0                          4289  *
00A015A0                          4290  * copy string d0 bytes long from a0 to Sutill
00A015A0                          4291  * return with a0 = pointer, d1 = length
00A015A0                          4292  
00A015A0                          4293  LAB_229E
00A015A0  3200                    4294      MOVE.w  d0,d1               * copy and check length
00A015A2  6714                    4295      BEQ.s       RTS_013         * skip copy if null
00A015A4                          4296  
00A015A4  226B 0CB2               4297      MOVEA.l Sutill(a3),a1       * get destination pointer
00A015A8  2F09                    4298      MOVE.l  a1,-(sp)            * save destination string pointer
00A015AA  5340                    4299      SUBQ.w  #1,d0               * subtract for DBF loop
00A015AC                          4300  LAB_22A0
00A015AC  12D8                    4301      MOVE.b  (a0)+,(a1)+         * copy byte
00A015AE  51C8 FFFC               4302      DBF     d0,LAB_22A0         * loop if not done
00A015B2                          4303  
00A015B2  2749 0CB2               4304      MOVE.l  a1,Sutill(a3)       * update Sutill to end of copied string
00A015B6  205F                    4305      MOVEA.l (sp)+,a0            * restore destination string pointer
00A015B8                          4306  RTS_013
00A015B8  4E75                    4307      RTS
00A015BA                          4308  
00A015BA                          4309  
00A015BA                          4310  *************************************************************************************
00A015BA                          4311  *
00A015BA                          4312  * pop string off descriptor stack, or from top of string space
00A015BA                          4313  * returns with d0.l = length, a0 = pointer
00A015BA                          4314  
00A015BA                          4315  LAB_22B6
00A015BA  206B 0DF4               4316      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00A015BE                          4317  
00A015BE                          4318  
00A015BE                          4319  *************************************************************************************
00A015BE                          4320  *
00A015BE                          4321  * pop (a0) descriptor off stack or from string space
00A015BE                          4322  * returns with d0.l = length, a0 = pointer
00A015BE                          4323  
00A015BE                          4324  LAB_22BA
00A015BE  48E7 4040               4325      MOVEM.l a1/d1,-(sp)         * save other regs
00A015C2  B9C8                    4326      CMPA.l  a0,a4               * is string on the descriptor stack
00A015C4  6602                    4327      BNE.s       LAB_22BD            * skip pop if not
00A015C6                          4328  
00A015C6  5C4C                    4329      ADDQ.w  #$06,a4         * else update stack pointer
00A015C8                          4330  LAB_22BD
00A015C8  7000                    4331      MOVEQ       #0,d0               * clear string length longword
00A015CA  2258                    4332      MOVEA.l (a0)+,a1            * get string address
00A015CC  3018                    4333      MOVE.w  (a0)+,d0            * get string length
00A015CE                          4334  
00A015CE  B9C8                    4335      CMPA.l  a0,a4               * was it on the descriptor stack
00A015D0  6610                    4336      BNE.s       LAB_22E6            * branch if it wasn't
00A015D2                          4337  
00A015D2  B3EB 0CAA               4338      CMPA.l  Sstorl(a3),a1       * compare string address with bottom of string
00A015D6                          4339                              * space
00A015D6  660A                    4340      BNE.s       LAB_22E6            * branch if <>
00A015D8                          4341  
00A015D8  7201                    4342      MOVEQ       #1,d1               * mask for odd bit
00A015DA  C240                    4343      AND.w       d0,d1               * AND length
00A015DC  D280                    4344      ADD.l       d0,d1               * make it fit word aligned length
00A015DE                          4345  
00A015DE  D3AB 0CAA               4346      ADD.l       d1,Sstorl(a3)       * add to bottom of string space
00A015E2                          4347  LAB_22E6
00A015E2  2049                    4348      MOVEA.l a1,a0               * copy to a0
00A015E4  4CDF 0202               4349      MOVEM.l (sp)+,a1/d1         * restore other regs
00A015E8  4A80                    4350      TST.l       d0              * set flags on length
00A015EA  4E75                    4351      RTS
00A015EC                          4352  
00A015EC                          4353  
00A015EC                          4354  *************************************************************************************
00A015EC                          4355  *
00A015EC                          4356  * perform CHR$()
00A015EC                          4357  
00A015EC                          4358  LAB_CHRS
00A015EC  6100 0130               4359      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00A015F0                          4360                              * Itemp
00A015F0                          4361  LAB_MKCHR
00A015F0  7201                    4362      MOVEQ       #1,d1               * string is single byte
00A015F2  6100 FE32               4363      BSR     LAB_2115            * make string space d1 bytes long
00A015F6                          4364                              * return a0/Sutill = pointer, others unchanged
00A015F6  1080                    4365      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00A015F8  6000 FE12               4366      BRA     LAB_RTST            * push string on descriptor stack
00A015FC                          4367                              * a0 = pointer, d1 = length
00A015FC                          4368  
00A015FC                          4369  
00A015FC                          4370  *************************************************************************************
00A015FC                          4371  *
00A015FC                          4372  * perform LEFT$()
00A015FC                          4373  
00A015FC                          4374  * enter with a0 is descriptor, d0 & Itemp is word 1
00A015FC                          4375  
00A015FC                          4376  LAB_LEFT
00A015FC  C141                    4377      EXG     d0,d1               * word in d1
00A015FE  6100 F79E               4378      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A01602                          4379  
00A01602  4A81                    4380      TST.l       d1              * test returned length
00A01604  6722                    4381      BEQ.s       LAB_231C            * branch if null return
00A01606                          4382  
00A01606  7000                    4383      MOVEQ       #0,d0               * clear start offset
00A01608  B268 0004               4384      CMP.w       4(a0),d1            * compare word parameter with string length
00A0160C  651A                    4385      BCS.s       LAB_231C            * branch if string length > word parameter
00A0160E                          4386  
00A0160E  6014                    4387      BRA.s       LAB_2317            * go copy whole string
00A01610                          4388  
00A01610                          4389  
00A01610                          4390  *************************************************************************************
00A01610                          4391  *
00A01610                          4392  * perform RIGHT$()
00A01610                          4393  
00A01610                          4394  * enter with a0 is descriptor, d0 & Itemp is word 1
00A01610                          4395  
00A01610                          4396  LAB_RIGHT
00A01610  C141                    4397      EXG     d0,d1               * word in d1
00A01612  6100 F78A               4398      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A01616                          4399  
00A01616  4A81                    4400      TST.l       d1              * test returned length
00A01618  670E                    4401      BEQ.s       LAB_231C            * branch if null return
00A0161A                          4402  
00A0161A  3028 0004               4403      MOVE.w  4(a0),d0            * get string length
00A0161E  9081                    4404      SUB.l       d1,d0               * subtract word
00A01620  6406                    4405      BCC.s       LAB_231C            * branch if string length > word parameter
00A01622                          4406  
00A01622                          4407                              * else copy whole string
00A01622                          4408  LAB_2316
00A01622  7000                    4409      MOVEQ       #0,d0               * clear start offset
00A01624                          4410  LAB_2317
00A01624  3228 0004               4411      MOVE.w  4(a0),d1            * else make parameter = length
00A01628                          4412  
00A01628                          4413  * get here with ...
00A01628                          4414  *   a0 - points to descriptor
00A01628                          4415  *   d0 - is offset from string start
00A01628                          4416  *   d1 - is required string length
00A01628                          4417  
00A01628                          4418  LAB_231C
00A01628  2248                    4419      MOVEA.l a0,a1               * save string descriptor pointer
00A0162A  6100 FDFA               4420      BSR     LAB_2115            * make string space d1 bytes long
00A0162E                          4421                              * return a0/Sutill = pointer, others unchanged
00A0162E  2049                    4422      MOVEA.l a1,a0               * restore string descriptor pointer
00A01630  2F00                    4423      MOVE.l  d0,-(sp)            * save start offset (longword)
00A01632  618A                    4424      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00A01634                          4425                              * d0 = length, a0 = pointer
00A01634  D1DF                    4426      ADDA.l  (sp)+,a0            * adjust pointer to start of wanted string
00A01636  3001                    4427      MOVE.w  d1,d0               * length to d0
00A01638  6100 FF66               4428      BSR     LAB_229E            * store string d0 bytes long from (a0) to
00A0163C                          4429                              * (Sutill) return with a0 = pointer,
00A0163C                          4430                              * d1 = length
00A0163C  6000 FDCE               4431      BRA     LAB_RTST            * push string on descriptor stack
00A01640                          4432                              * a0 = pointer, d1 = length
00A01640                          4433  
00A01640                          4434  
00A01640                          4435  *************************************************************************************
00A01640                          4436  *
00A01640                          4437  * perform MID$()
00A01640                          4438  
00A01640                          4439  * enter with a0 is descriptor, d0 & Itemp is word 1
00A01640                          4440  
00A01640                          4441  LAB_MIDS
00A01640  7E00                    4442      MOVEQ       #0,d7               * clear longword
00A01642  5347                    4443      SUBQ.w  #1,d7               * set default length = 65535
00A01644  2F00                    4444      MOVE.l  d0,-(sp)            * save word 1
00A01646  6100 F76A               4445      BSR     LAB_GBYT            * scan memory
00A0164A  B03C 002C               4446      CMP.b       #',',d0         * was it ","
00A0164E  660C                    4447      BNE.s       LAB_2358            * branch if not "," (skip second byte get)
00A01650                          4448  
00A01650  101D                    4449      MOVE.b  (a5)+,d0            * increment pointer past ","
00A01652  2F08                    4450      MOVE.l  a0,-(sp)            * save descriptor pointer
00A01654  6100 00D8               4451      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00A01658  205F                    4452      MOVEA.l (sp)+,a0            * restore descriptor pointer
00A0165A  2E00                    4453      MOVE.l  d0,d7               * copy length
00A0165C                          4454  LAB_2358
00A0165C  6100 F740               4455      BSR     LAB_1BFB            * scan for ")", else do syntax error then warm
00A01660                          4456                              * start
00A01660  201F                    4457      MOVE.l  (sp)+,d0            * restore word 1
00A01662  7200                    4458      MOVEQ       #0,d1               * null length
00A01664  5380                    4459      SUBQ.l  #1,d0               * decrement start index (word 1)
00A01666  6B00 EAFE               4460      BMI     LAB_FCER            * if was null do function call error then warm
00A0166A                          4461                              * start
00A0166A                          4462  
00A0166A  B068 0004               4463      CMP.w       4(a0),d0            * compare string length with start index
00A0166E  64B8                    4464      BCC.s       LAB_231C            * if start not in string do null string (d1=0)
00A01670                          4465  
00A01670  2207                    4466      MOVE.l  d7,d1               * get length back
00A01672  DE40                    4467      ADD.w       d0,d7               * d7 now = MID$() end
00A01674  6506                    4468      BCS.s       LAB_2368            * already too long so do RIGHT$ equivalent
00A01676                          4469  
00A01676  BE68 0004               4470      CMP.w       4(a0),d7            * compare string length with start index+length
00A0167A  65AC                    4471      BCS.s       LAB_231C            * if end in string go do string
00A0167C                          4472  
00A0167C                          4473  LAB_2368
00A0167C  3228 0004               4474      MOVE.w  4(a0),d1            * get string length
00A01680  9240                    4475      SUB.w       d0,d1               * subtract start offset
00A01682  60A4                    4476      BRA.s       LAB_231C            * go do string (effectively RIGHT$)
00A01684                          4477  
00A01684                          4478  
00A01684                          4479  *************************************************************************************
00A01684                          4480  *
00A01684                          4481  * perform LCASE$()
00A01684                          4482  
00A01684                          4483  LAB_LCASE
00A01684  6100 FF34               4484      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00A01688                          4485                              * returns with d0 = length, a0 = pointer
00A01688  2200                    4486      MOVE.l  d0,d1               * copy the string length
00A0168A  6756                    4487      BEQ.s       NoString            * if null go return a null string
00A0168C                          4488  
00A0168C                          4489  * else copy and change the string
00A0168C                          4490  
00A0168C  2248                    4491      MOVEA.l a0,a1               * copy the string address
00A0168E  6100 FD96               4492      BSR     LAB_2115            * make a string space d1 bytes long
00A01692  D1C1                    4493      ADDA.l  d1,a0               * new string end
00A01694  D3C1                    4494      ADDA.l  d1,a1               * old string end
00A01696  3401                    4495      MOVE.w  d1,d2               * copy length for loop
00A01698  5342                    4496      SUBQ.w  #1,d2               * -1 for DBF loop
00A0169A                          4497  LC_loop
00A0169A  1021                    4498      MOVE.b  -(a1),d0            * get byte from string
00A0169C                          4499  
00A0169C  B03C 005B               4500      CMP.b       #$5B,d0         * compare with "Z"+1
00A016A0  640A                    4501      BCC.s       NoUcase         * if > "Z" skip change
00A016A2                          4502  
00A016A2  B03C 0041               4503      CMP.b       #$41,d0         * compare with "A"
00A016A6  6504                    4504      BCS.s       NoUcase         * if < "A" skip change
00A016A8                          4505  
00A016A8  0000 0020               4506      ORI.b       #$20,d0         * convert upper case to lower case
00A016AC                          4507  NoUcase
00A016AC  1100                    4508      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00A016AE  51CA FFEA               4509      DBF     d2,LC_loop          * decrement and loop if not all done
00A016B2                          4510  
00A016B2  602E                    4511      BRA.s       NoString            * tidy up & exit (branch always)
00A016B4                          4512  
00A016B4                          4513  
00A016B4                          4514  *************************************************************************************
00A016B4                          4515  *
00A016B4                          4516  * perform UCASE$()
00A016B4                          4517  
00A016B4                          4518  LAB_UCASE
00A016B4  6100 FF04               4519      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00A016B8                          4520                              * returns with d0 = length, a0 = pointer
00A016B8  2200                    4521      MOVE.l  d0,d1               * copy the string length
00A016BA  6726                    4522      BEQ.s       NoString            * if null go return a null string
00A016BC                          4523  
00A016BC                          4524  * else copy and change the string
00A016BC                          4525  
00A016BC  2248                    4526      MOVEA.l a0,a1               * copy the string address
00A016BE  6100 FD66               4527      BSR     LAB_2115            * make a string space d1 bytes long
00A016C2  D1C1                    4528      ADDA.l  d1,a0               * new string end
00A016C4  D3C1                    4529      ADDA.l  d1,a1               * old string end
00A016C6  3401                    4530      MOVE.w  d1,d2               * copy length for loop
00A016C8  5342                    4531      SUBQ.w  #1,d2               * -1 for DBF loop
00A016CA                          4532  UC_loop
00A016CA  1021                    4533      MOVE.b  -(a1),d0            * get a byte from the string
00A016CC                          4534  
00A016CC  B03C 0061               4535      CMP.b       #$61,d0         * compare with "a"
00A016D0  650A                    4536      BCS.s       NoLcase         * if < "a" skip change
00A016D2                          4537  
00A016D2  B03C 007B               4538      CMP.b       #$7B,d0         * compare with "z"+1
00A016D6  6404                    4539      BCC.s       NoLcase         * if > "z" skip change
00A016D8                          4540  
00A016D8  0200 00DF               4541      ANDI.b  #$DF,d0         * convert lower case to upper case
00A016DC                          4542  NoLcase
00A016DC  1100                    4543      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00A016DE  51CA FFEA               4544      DBF     d2,UC_loop          * decrement and loop if not all done
00A016E2                          4545  
00A016E2                          4546  NoString
00A016E2  6000 FD28               4547      BRA     LAB_RTST            * push string on descriptor stack
00A016E6                          4548                              * a0 = pointer, d1 = length
00A016E6                          4549  
00A016E6                          4550  
00A016E6                          4551  *************************************************************************************
00A016E6                          4552  *
00A016E6                          4553  * perform SADD()
00A016E6                          4554  
00A016E6                          4555  LAB_SADD
00A016E6  101D                    4556      MOVE.b  (a5)+,d0            * increment pointer
00A016E8  6100 F8D6               4557      BSR     LAB_GVAR            * get variable address in a0
00A016EC  6100 F6B0               4558      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A016F0  4A2B 0E19               4559      TST.b       Dtypef(a3)          * test data type flag
00A016F4  6A00 EA50               4560      BPL     LAB_TMER            * if numeric do Type missmatch Error
00A016F8                          4561  
00A016F8                          4562  * if you want a non existant variable to return a null value then set the novar
00A016F8                          4563  * value at the top of this file to some non zero value
00A016F8                          4564  
00A016F8                 FALSE    4565   ifne   novar
00A016F8                          4566   endc
00A016F8                          4567  
00A016F8  2010                    4568      MOVE.l  (a0),d0         * get string address
00A016FA  6000 FBB4               4569      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A016FE                          4570  
00A016FE                          4571  
00A016FE                          4572  *************************************************************************************
00A016FE                          4573  *
00A016FE                          4574  * perform LEN()
00A016FE                          4575  
00A016FE                          4576  LAB_LENS
00A016FE  487A FBB0               4577      PEA     LAB_AYFC(pc)        * set return address to convert d0 to signed
00A01702                          4578                              * longword in FAC1
00A01702  6000 FEB6               4579      BRA     LAB_22B6            * pop string off descriptor stack or from memory
00A01706                          4580                              * returns with d0 = length, a0 = pointer
00A01706                          4581  
00A01706                          4582  
00A01706                          4583  *************************************************************************************
00A01706                          4584  *
00A01706                          4585  * perform ASC()
00A01706                          4586  
00A01706                          4587  LAB_ASC
00A01706  6100 FEB2               4588      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00A0170A                          4589                              * returns with d0 = length, a0 = pointer
00A0170A  4A40                    4590      TST.w       d0              * test length
00A0170C  6700 EA58               4591      BEQ     LAB_FCER            * if null do function call error then warm start
00A01710                          4592  
00A01710  1010                    4593      MOVE.b  (a0),d0         * get first character byte
00A01712  6000 FBBC               4594      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00A01716                          4595  
00A01716                          4596  
00A01716                          4597  *************************************************************************************
00A01716                          4598  *
00A01716                          4599  * increment and get byte, result in d0 and Itemp
00A01716                          4600  
00A01716                          4601  LAB_SGBY
00A01716  6100 F698               4602      BSR     LAB_IGBY            * increment & scan memory
00A0171A                          4603  
00A0171A                          4604  
00A0171A                          4605  *************************************************************************************
00A0171A                          4606  *
00A0171A                          4607  * get byte parameter, result in d0 and Itemp
00A0171A                          4608  
00A0171A                          4609  LAB_GTBY
00A0171A  6100 F51C               4610      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A0171E                          4611                              * else do type mismatch
00A0171E                          4612  
00A0171E                          4613  
00A0171E                          4614  *************************************************************************************
00A0171E                          4615  *
00A0171E                          4616  * evaluate byte expression, result in d0 and Itemp
00A0171E                          4617  
00A0171E                          4618  LAB_EVBY
00A0171E  6100 F9D4               4619      BSR     LAB_EVPI            * evaluate positive integer expression
00A01722                          4620                              * result in d0 and Itemp
00A01722  7280                    4621      MOVEQ       #$80,d1         * set mask/2
00A01724  D281                    4622      ADD.l       d1,d1               * =$FFFFFF00
00A01726  C280                    4623      AND.l       d0,d1               * check top 24 bits
00A01728  6600 EA3C               4624      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00A0172C                          4625  
00A0172C  4E75                    4626      RTS
00A0172E                          4627  
00A0172E                          4628  
00A0172E                          4629  *************************************************************************************
00A0172E                          4630  *
00A0172E                          4631  * get word parameter, result in d0 and Itemp
00A0172E                          4632  
00A0172E                          4633  LAB_GTWO
00A0172E  6100 F508               4634      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A01732                          4635                              * else do type mismatch
00A01732  6100 F9C0               4636      BSR     LAB_EVPI            * evaluate positive integer expression
00A01736                          4637                              * result in d0 and Itemp
00A01736  4840                    4638      SWAP        d0              * copy high word to low word
00A01738  4A40                    4639      TST.w       d0              * set flags
00A0173A  6600 EA2A               4640      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00A0173E                          4641  
00A0173E  4840                    4642      SWAP        d0              * copy high word to low word
00A01740  4E75                    4643      RTS
00A01742                          4644  
00A01742                          4645  
00A01742                          4646  *************************************************************************************
00A01742                          4647  *
00A01742                          4648  * perform VAL()
00A01742                          4649  
00A01742                          4650  LAB_VAL
00A01742  6100 FE76               4651      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00A01746                          4652                              * returns with d0 = length, a0 = pointer
00A01746  6722                    4653      BEQ.s       LAB_VALZ            * string was null so set result = $00
00A01748                          4654                              * clear FAC1 exponent & sign & return
00A01748                          4655  
00A01748  2C4D                    4656      MOVEA.l a5,a6               * save BASIC execute pointer
00A0174A  2A48                    4657      MOVEA.l a0,a5               * copy string pointer to execute pointer
00A0174C  D1C0                    4658      ADDA.l  d0,a0               * string end+1
00A0174E  1010                    4659      MOVE.b  (a0),d0         * get byte from string+1
00A01750  3F00                    4660      MOVE.w  d0,-(sp)            * save it
00A01752  2F08                    4661      MOVE.l  a0,-(sp)            * save address
00A01754  10BC 0000               4662      MOVE.b  #0,(a0)         * null terminate string
00A01758  6100 F658               4663      BSR     LAB_GBYT            * scan memory
00A0175C  6100 1142               4664      BSR     LAB_2887            * get FAC1 from string
00A01760  205F                    4665      MOVEA.l (sp)+,a0            * restore pointer
00A01762  301F                    4666      MOVE.w  (sp)+,d0            * pop byte
00A01764  1080                    4667      MOVE.b  d0,(a0)         * restore to memory
00A01766  2A4E                    4668      MOVEA.l a6,a5               * restore BASIC execute pointer
00A01768  4E75                    4669      RTS
00A0176A                          4670  
00A0176A                          4671  LAB_VALZ
00A0176A  3740 0DF8               4672      MOVE.w  d0,FAC1_e(a3)       * clear FAC1 exponent & sign
00A0176E  4E75                    4673      RTS
00A01770                          4674  
00A01770                          4675  
00A01770                          4676  *************************************************************************************
00A01770                          4677  *
00A01770                          4678  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00A01770                          4679  
00A01770                          4680  LAB_GADB
00A01770  6100 F4C6               4681      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A01774                          4682                              * else do type mismatch
00A01774  6100 F986               4683      BSR     LAB_EVIR            * evaluate integer expression
00A01778                          4684                              * (does FC error not OF error if out of range)
00A01778  2F00                    4685      MOVE.l  d0,-(sp)            * copy to stack
00A0177A  6100 F62A               4686      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00A0177E  619A                    4687      BSR.s       LAB_GTBY            * get byte parameter, result in d0 and Itemp
00A01780  205F                    4688      MOVEA.l (sp)+,a0            * pull address
00A01782  4E75                    4689      RTS
00A01784                          4690  
00A01784                          4691  
00A01784                          4692  *************************************************************************************
00A01784                          4693  *
00A01784                          4694  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00A01784                          4695  
00A01784                          4696  LAB_GADW
00A01784  611E                    4697      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00A01786                          4698                              * address returned in d0 and on the stack
00A01786  6100 F61E               4699      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00A0178A  6100 F4AC               4700      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A0178E                          4701                              * else do type mismatch
00A0178E  6100 F96C               4702      BSR     LAB_EVIR            * evaluate integer expression
00A01792                          4703                              * result in d0 and Itemp
00A01792  4840                    4704      SWAP        d0              * swap words
00A01794  4A40                    4705      TST.w       d0              * test high word
00A01796  6706                    4706      BEQ.s       LAB_XGADW           * exit if null
00A01798                          4707  
00A01798  5240                    4708      ADDQ.w  #1,d0               * increment word
00A0179A  6600 E9CA               4709      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00A0179E                          4710  
00A0179E                          4711  LAB_XGADW
00A0179E  4840                    4712      SWAP        d0              * swap words back
00A017A0  205F                    4713      MOVEA.l (sp)+,a0            * pull address
00A017A2  4E75                    4714      RTS
00A017A4                          4715  
00A017A4                          4716  
00A017A4                          4717  *************************************************************************************
00A017A4                          4718  *
00A017A4                          4719  * get even address (for word or longword memory actions)
00A017A4                          4720  * address returned in d0 and on the stack
00A017A4                          4721  * does address error if the address is odd
00A017A4                          4722  
00A017A4                          4723  LAB_GEAD
00A017A4  6100 F492               4724      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A017A8                          4725                              * else do type mismatch
00A017A8  6100 F952               4726      BSR     LAB_EVIR            * evaluate integer expression
00A017AC                          4727                              * (does FC error not OF error if out of range)
00A017AC  0800 0000               4728      BTST        #0,d0               * test low bit of longword
00A017B0  6600 E970               4729      BNE     LAB_ADER            * if address is odd do address error/warm start
00A017B4                          4730  
00A017B4  2057                    4731      MOVEA.l (sp),a0         * copy return address
00A017B6  2E80                    4732      MOVE.l  d0,(sp)         * even address on stack
00A017B8  4ED0                    4733      JMP     (a0)                * effectively RTS
00A017BA                          4734  
00A017BA                          4735  
00A017BA                          4736  *************************************************************************************
00A017BA                          4737  *
00A017BA                          4738  * perform PEEK()
00A017BA                          4739  
00A017BA                          4740  LAB_PEEK
00A017BA  6100 F940               4741      BSR     LAB_EVIR            * evaluate integer expression
00A017BE                          4742                              * (does FC error not OF error if out of range)
00A017BE  2040                    4743      MOVEA.l d0,a0               * copy to address register
00A017C0  1010                    4744      MOVE.b  (a0),d0         * get byte
00A017C2  6000 FB0C               4745      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00A017C6                          4746  
00A017C6                          4747  
00A017C6                          4748  *************************************************************************************
00A017C6                          4749  *
00A017C6                          4750  * perform POKE
00A017C6                          4751  
00A017C6                          4752  LAB_POKE
00A017C6  61A8                    4753      BSR.s       LAB_GADB            * get two parameters for POKE or WAIT
00A017C8                          4754                              * first parameter in a0, second in d0
00A017C8  1080                    4755      MOVE.b  d0,(a0)         * put byte in memory
00A017CA  4E75                    4756      RTS
00A017CC                          4757  
00A017CC                          4758  
00A017CC                          4759  *************************************************************************************
00A017CC                          4760  *
00A017CC                          4761  * perform DEEK()
00A017CC                          4762  
00A017CC                          4763  LAB_DEEK
00A017CC  6100 F92E               4764      BSR     LAB_EVIR            * evaluate integer expression
00A017D0                          4765                              * (does FC error not OF error if out of range)
00A017D0  E208                    4766      LSR.b       #1,d0               * shift bit 0 to carry
00A017D2  6500 E94E               4767      BCS     LAB_ADER            * if address is odd do address error/warm start
00A017D6                          4768  
00A017D6  D000                    4769      ADD.b       d0,d0               * shift byte back
00A017D8  C188                    4770      EXG     d0,a0               * copy to address register
00A017DA  7000                    4771      MOVEQ       #0,d0               * clear top bits
00A017DC  3010                    4772      MOVE.w  (a0),d0         * get word
00A017DE  6000 FAD0               4773      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A017E2                          4774  
00A017E2                          4775  
00A017E2                          4776  *************************************************************************************
00A017E2                          4777  *
00A017E2                          4778  * perform LEEK()
00A017E2                          4779  
00A017E2                          4780  LAB_LEEK
00A017E2  6100 F918               4781      BSR     LAB_EVIR            * evaluate integer expression
00A017E6                          4782                              * (does FC error not OF error if out of range)
00A017E6  E208                    4783      LSR.b       #1,d0               * shift bit 0 to carry
00A017E8  6500 E938               4784      BCS     LAB_ADER            * if address is odd do address error/warm start
00A017EC                          4785  
00A017EC  D000                    4786      ADD.b       d0,d0               * shift byte back
00A017EE  C188                    4787      EXG     d0,a0               * copy to address register
00A017F0  2010                    4788      MOVE.l  (a0),d0         * get longword
00A017F2  6000 FABC               4789      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A017F6                          4790  
00A017F6                          4791  
00A017F6                          4792  *************************************************************************************
00A017F6                          4793  *
00A017F6                          4794  * perform DOKE
00A017F6                          4795  
00A017F6                          4796  LAB_DOKE
00A017F6  618C                    4797      BSR.s       LAB_GADW            * get two parameters for DOKE or WAIT
00A017F8                          4798                              * first parameter in a0, second in d0
00A017F8  3080                    4799      MOVE.w  d0,(a0)         * put word in memory
00A017FA  4E75                    4800      RTS
00A017FC                          4801  
00A017FC                          4802  
00A017FC                          4803  *************************************************************************************
00A017FC                          4804  *
00A017FC                          4805  * perform LOKE
00A017FC                          4806  
00A017FC                          4807  LAB_LOKE
00A017FC  61A6                    4808      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00A017FE                          4809                              * address returned in d0 and on the stack
00A017FE  6100 F5A6               4810      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00A01802  6100 F434               4811      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00A01806                          4812                              * else do type mismatch
00A01806  6100 F8F4               4813      BSR     LAB_EVIR            * evaluate integer value (no sign check)
00A0180A  205F                    4814      MOVEA.l (sp)+,a0            * pull address
00A0180C  2080                    4815      MOVE.l  d0,(a0)         * put longword in memory
00A0180E                          4816  RTS_015
00A0180E  4E75                    4817      RTS
00A01810                          4818  
00A01810                          4819  
00A01810                          4820  *************************************************************************************
00A01810                          4821  *
00A01810                          4822  * perform SWAP
00A01810                          4823  
00A01810                          4824  LAB_SWAP
00A01810  6100 F7AE               4825      BSR     LAB_GVAR            * get variable 1 address in a0
00A01814  2F08                    4826      MOVE.l  a0,-(sp)            * save variable 1 address
00A01816  182B 0E19               4827      MOVE.b  Dtypef(a3),d4       * copy variable 1 data type, $80=string,
00A0181A                          4828                              * $40=inetger, $00=float
00A0181A                          4829  
00A0181A  6100 F58A               4830      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00A0181E  6100 F7A0               4831      BSR     LAB_GVAR            * get variable 2 address in a0
00A01822  245F                    4832      MOVEA.l (sp)+,a2            * restore variable 1 address
00A01824  B82B 0E19               4833      CMP.b       Dtypef(a3),d4       * compare variable 1 data type with variable 2
00A01828                          4834                              * data type
00A01828  6600 E91C               4835      BNE     LAB_TMER            * if not both the same type do "Type mismatch"
00A0182C                          4836                              * error then warm start
00A0182C                          4837  
00A0182C                          4838  * if you do want a non existant variable to return an error then leave the novar
00A0182C                          4839  * value at the top of this file set to zero
00A0182C                          4840  
00A0182C                 TRUE     4841   ifeq   novar
00A0182C                          4842  
00A0182C  2010                    4843      MOVE.l  (a0),d0         * get variable 2
00A0182E  20D2                    4844      MOVE.l  (a2),(a0)+          * copy variable 1 to variable 2
00A01830  24C0                    4845      MOVE.l  d0,(a2)+            * save variable 2 to variable 1
00A01832                          4846  
00A01832  4A04                    4847      TST.b       d4              * check data type
00A01834  6AD8                    4848      BPL.s       RTS_015         * exit if not string
00A01836                          4849  
00A01836  3010                    4850      MOVE.w  (a0),d0         * get string 2 length
00A01838  3092                    4851      MOVE.w  (a2),(a0)           * copy string 1 length to string 2 length
00A0183A  3480                    4852      MOVE.w  d0,(a2)         * save string 2 length to string 1 length
00A0183C                          4853  
00A0183C                          4854   endc
00A0183C                          4855  
00A0183C                          4856  
00A0183C                          4857  * if you want a non existant variable to return a null value then set the novar
00A0183C                          4858  * value at the top of this file to some non zero value
00A0183C                          4859  
00A0183C                 FALSE    4860   ifne   novar
00A0183C                          4861                              * value get
00A0183C                          4862                              * value get and the new value save
00A0183C                          4863                              * new length save
00A0183C                          4864                              * new value save
00A0183C                          4865   endc
00A0183C                          4866  
00A0183C  4E75                    4867      RTS
00A0183E                          4868  
00A0183E                          4869  
00A0183E                          4870  *************************************************************************************
00A0183E                          4871  *
00A0183E                          4872  * perform USR
00A0183E                          4873  
00A0183E                          4874  LAB_USR
00A0183E  4EAB 0C6A               4875      JSR     Usrjmp(a3)          * do user vector
00A01842  6000 F55A               4876      BRA     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A01846                          4877  
00A01846                          4878  
00A01846                          4879  *************************************************************************************
00A01846                          4880  *
00A01846                          4881  * perform LOAD
00A01846                          4882  
00A01846                          4883  LAB_LOAD
00A01846  4EEB 0C7C               4884      JMP     V_LOAD(a3)          * do load vector
00A0184A                          4885  
00A0184A                          4886  
00A0184A                          4887  *************************************************************************************
00A0184A                          4888  *
00A0184A                          4889  * perform SAVE
00A0184A                          4890  
00A0184A                          4891  LAB_SAVE
00A0184A  4EEB 0C82               4892      JMP     V_SAVE(a3)          * do save vector
00A0184E                          4893  
00A0184E                          4894  
00A0184E                          4895  *************************************************************************************
00A0184E                          4896  *
00A0184E                          4897  * perform CALL
00A0184E                          4898  
00A0184E                          4899  LAB_CALL
00A0184E  487A F562               4900      PEA     LAB_GBYT(pc)        * put return address on stack
00A01852  6100 FF50               4901      BSR     LAB_GEAD            * get even address for word/long memory actions
00A01856                          4902                              * address returned in d0 and on the stack
00A01856  4E75                    4903      RTS                     * effectively calls the routine
00A01858                          4904  
00A01858                          4905  * if the called routine exits correctly then it will return via the get byte routine.
00A01858                          4906  * this will then get the next byte for the interpreter and return
00A01858                          4907  
00A01858                          4908  
00A01858                          4909  *************************************************************************************
00A01858                          4910  *
00A01858                          4911  * perform WAIT
00A01858                          4912  
00A01858                          4913  LAB_WAIT
00A01858  6100 FF16               4914      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00A0185C                          4915                              * first parameter in a0, second in d0
00A0185C  2F08                    4916      MOVE.l  a0,-(sp)            * save address
00A0185E  3F00                    4917      MOVE.w  d0,-(sp)            * save byte
00A01860  7400                    4918      MOVEQ       #0,d2               * clear mask
00A01862  6100 F54E               4919      BSR     LAB_GBYT            * scan memory
00A01866  6706                    4920      BEQ.s       LAB_2441            * skip if no third argument
00A01868                          4921  
00A01868  6100 F538               4922      BSR     LAB_SCGB            * scan for "," & get byte,
00A0186C                          4923                              * else do syntax error/warm start
00A0186C  2400                    4924      MOVE.l  d0,d2               * copy mask
00A0186E                          4925  LAB_2441
00A0186E  321F                    4926      MOVE.w  (sp)+,d1            * get byte
00A01870  205F                    4927      MOVEA.l (sp)+,a0            * get address
00A01872                          4928  LAB_2445
00A01872  1010                    4929      MOVE.b  (a0),d0         * read memory byte
00A01874  B500                    4930      EOR.b       d2,d0               * EOR with second argument (mask)
00A01876  C001                    4931      AND.b       d1,d0               * AND with first argument (byte)
00A01878  67F8                    4932      BEQ.s       LAB_2445            * loop if result is zero
00A0187A                          4933  
00A0187A  4E75                    4934      RTS
00A0187C                          4935  
00A0187C                          4936  
00A0187C                          4937  *************************************************************************************
00A0187C                          4938  *
00A0187C                          4939  * perform subtraction, FAC1 from FAC2
00A0187C                          4940  
00A0187C                          4941  LAB_SUBTRACT
00A0187C  0A2B 0080 0DF9          4942      EORI.b  #$80,FAC1_s(a3)     * complement FAC1 sign
00A01882  176B 0E01 0E02          4943      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign byte
00A01888                          4944  
00A01888  102B 0DF9               4945      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign byte
00A0188C  B12B 0E02               4946      EOR.b       d0,FAC_sc(a3)       * EOR with FAC2 sign
00A01890                          4947  
00A01890                          4948  
00A01890                          4949  *************************************************************************************
00A01890                          4950  *
00A01890                          4951  * add FAC2 to FAC1
00A01890                          4952  
00A01890                          4953  LAB_ADD
00A01890  102B 0DF8               4954      MOVE.b  FAC1_e(a3),d0       * get exponent
00A01894  6700 0338               4955      BEQ     LAB_279B            * FAC1 was zero so copy FAC2 to FAC1 & return
00A01898                          4956  
00A01898                          4957                              * FAC1 is non zero
00A01898  41EB 0DFC               4958      LEA     FAC2_m(a3),a0       * set pointer1 to FAC2 mantissa
00A0189C  102B 0E00               4959      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00A018A0  6746                    4960      BEQ.s       RTS_016         * exit if zero
00A018A2                          4961  
00A018A2  902B 0DF8               4962      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00A018A6  6722                    4963      BEQ.s       LAB_24A8            * branch if = (go add mantissa)
00A018A8                          4964  
00A018A8  650A                    4965      BCS.s       LAB_249C            * branch if FAC2 < FAC1
00A018AA                          4966  
00A018AA                          4967                              * FAC2 > FAC1
00A018AA  376B 0E00 0DF8          4968      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy sign and exponent of FAC2
00A018B0  4400                    4969      NEG.b       d0              * negate exponent difference (make diff -ve)
00A018B2  5148                    4970      SUBQ.w  #8,a0               * pointer1 to FAC1
00A018B4                          4971  
00A018B4                          4972  LAB_249C
00A018B4  4400                    4973      NEG.b       d0              * negate exponent difference (make diff +ve)
00A018B6  2F01                    4974      MOVE.l  d1,-(sp)            * save d1
00A018B8  B03C 0020               4975      CMP.b       #32,d0          * compare exponent diff with 32
00A018BC  6D04                    4976      BLT.s       LAB_2467            * branch if range >= 32
00A018BE                          4977  
00A018BE  7200                    4978      MOVEQ       #0,d1               * clear d1
00A018C0  6004                    4979      BRA.s       LAB_2468            * go clear smaller mantissa
00A018C2                          4980  
00A018C2                          4981  LAB_2467
00A018C2  2210                    4982      MOVE.l  (a0),d1         * get FACx mantissa
00A018C4  E0A9                    4983      LSR.l       d0,d1               * shift d0 times right
00A018C6                          4984  LAB_2468
00A018C6  2081                    4985      MOVE.l  d1,(a0)         * save it back
00A018C8  221F                    4986      MOVE.l  (sp)+,d1            * restore d1
00A018CA                          4987  
00A018CA                          4988                              * exponents are equal now do mantissa add or
00A018CA                          4989                              * subtract
00A018CA                          4990  LAB_24A8
00A018CA  4A2B 0E02               4991      TST.b       FAC_sc(a3)          * test sign compare (FAC1 EOR FAC2)
00A018CE  6B1A                    4992      BMI.s       LAB_24F8            * if <> go do subtract
00A018D0                          4993  
00A018D0  202B 0DFC               4994      MOVE.l  FAC2_m(a3),d0       * get FAC2 mantissa
00A018D4  D0AB 0DF4               4995      ADD.l       FAC1_m(a3),d0       * add FAC1 mantissa
00A018D8  640A                    4996      BCC.s       LAB_24F7            * save and exit if no carry (FAC1 is normal)
00A018DA                          4997  
00A018DA  E290                    4998      ROXR.l  #1,d0               * else shift carry back into mantissa
00A018DC  522B 0DF8               4999      ADDQ.b  #1,FAC1_e(a3)       * increment FAC1 exponent
00A018E0  6500 E880               5000      BCS     LAB_OFER            * if carry do overflow error & warm start
00A018E4                          5001  
00A018E4                          5002  LAB_24F7
00A018E4  2740 0DF4               5003      MOVE.l  d0,FAC1_m(a3)       * save mantissa
00A018E8                          5004  RTS_016
00A018E8  4E75                    5005      RTS
00A018EA                          5006                              * signs are different
00A018EA                          5007  LAB_24F8
00A018EA  43EB 0DF4               5008      LEA     FAC1_m(a3),a1       * pointer 2 to FAC1
00A018EE  B3C8                    5009      CMPA.l  a0,a1               * compare pointers
00A018F0  6602                    5010      BNE.s       LAB_24B4            * branch if <>
00A018F2                          5011  
00A018F2  5049                    5012      ADDQ.w  #8,a1               * else pointer2 to FAC2
00A018F4                          5013  
00A018F4                          5014                              * take smaller from bigger (take sign of bigger)
00A018F4                          5015  LAB_24B4
00A018F4  2011                    5016      MOVE.l  (a1),d0         * get larger mantissa
00A018F6  2210                    5017      MOVE.l  (a0),d1         * get smaller mantissa
00A018F8  2740 0DF4               5018      MOVE.l  d0,FAC1_m(a3)       * save larger mantissa
00A018FC  93AB 0DF4               5019      SUB.l       d1,FAC1_m(a3)       * subtract smaller
00A01900                          5020  
00A01900                          5021  
00A01900                          5022  *************************************************************************************
00A01900                          5023  *
00A01900                          5024  * do +/- (carry is sign) & normalise FAC1
00A01900                          5025  
00A01900                          5026  LAB_24D0
00A01900  640A                    5027      BCC.s       LAB_24D5            * branch if result is +ve
00A01902                          5028  
00A01902                          5029                              * erk! subtract is the wrong way round so
00A01902                          5030                              * negate everything
00A01902  0A2B 00FF 0DF9          5031      EORI.b  #$FF,FAC1_s(a3)     * complement FAC1 sign
00A01908  44AB 0DF4               5032      NEG.l       FAC1_m(a3)          * negate FAC1 mantissa
00A0190C                          5033  
00A0190C                          5034  
00A0190C                          5035  *************************************************************************************
00A0190C                          5036  *
00A0190C                          5037  * normalise FAC1
00A0190C                          5038  
00A0190C                          5039  LAB_24D5
00A0190C  202B 0DF4               5040      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A01910  6B2E                    5041      BMI.s       LAB_24DA            * mantissa is normal so just exit
00A01912                          5042  
00A01912  6606                    5043      BNE.s       LAB_24D9            * mantissa is not zero so go normalise FAC1
00A01914                          5044  
00A01914  3740 0DF8               5045      MOVE.w  d0,FAC1_e(a3)       * else make FAC1 = +zero
00A01918  4E75                    5046      RTS
00A0191A                          5047  
00A0191A                          5048  LAB_24D9
00A0191A  2F01                    5049      MOVE.l  d1,-(sp)            * save d1
00A0191C  2200                    5050      MOVE.l  d0,d1               * mantissa to d1
00A0191E  7000                    5051      MOVEQ       #0,d0               * clear d0
00A01920  102B 0DF8               5052      MOVE.b  FAC1_e(a3),d0       * get exponent byte
00A01924  6714                    5053      BEQ.s       LAB_24D8            * if exponent is zero then clean up and exit
00A01926                          5054  LAB_24D6
00A01926  D281                    5055      ADD.l       d1,d1               * shift mantissa, ADD is quicker for a single
00A01928                          5056                              * shift
00A01928  5BC8 FFFC               5057      DBMI        d0,LAB_24D6         * decrement exponent and loop if mantissa and
00A0192C                          5058                              * exponent +ve
00A0192C                          5059  
00A0192C  4A40                    5060      TST.w       d0              * test exponent
00A0192E  670A                    5061      BEQ.s       LAB_24D8            * if exponent is zero make FAC1 zero
00A01930                          5062  
00A01930  6A02                    5063      BPL.s       LAB_24D7            * if exponent is >zero go save FAC1
00A01932                          5064  
00A01932  7001                    5065      MOVEQ       #1,d0               * else set for zero after correction
00A01934                          5066  LAB_24D7
00A01934  5300                    5067      SUBQ.b  #1,d0               * adjust exponent for loop
00A01936  2741 0DF4               5068      MOVE.l  d1,FAC1_m(a3)       * save normalised mantissa
00A0193A                          5069  LAB_24D8
00A0193A  221F                    5070      MOVE.l  (sp)+,d1            * restore d1
00A0193C  1740 0DF8               5071      MOVE.b  d0,FAC1_e(a3)       * save corrected exponent
00A01940                          5072  LAB_24DA
00A01940  4E75                    5073      RTS
00A01942                          5074  
00A01942                          5075  
00A01942                          5076  *************************************************************************************
00A01942                          5077  *
00A01942                          5078  * perform LOG()
00A01942                          5079  
00A01942                          5080  LAB_LOG
00A01942  4A2B 0DF9               5081      TST.b       FAC1_s(a3)          * test sign
00A01946  6B00 E81E               5082      BMI     LAB_FCER            * if -ve do function call error/warm start
00A0194A                          5083  
00A0194A  7E00                    5084      MOVEQ       #0,d7               * clear d7
00A0194C  1747 0E02               5085      MOVE.b  d7,FAC_sc(a3)       * clear sign compare
00A01950  1E2B 0DF8               5086      MOVE.b  FAC1_e(a3),d7       * get exponent
00A01954  6700 E810               5087      BEQ     LAB_FCER            * if 0 do function call error/warm start
00A01958                          5088  
00A01958  0487 00000081           5089      SUB.l       #$81,d7         * normalise exponent
00A0195E  177C 0081 0DF8          5090      MOVE.b  #$81,FAC1_e(a3)     * force a value between 1 and 2
00A01964  2C2B 0DF4               5091      MOVE.l  FAC1_m(a3),d6       * copy mantissa
00A01968                          5092  
00A01968  277C 80000000 0DFC      5093      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00A01970  377C 8100 0E00          5094      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00A01976  6100 FF18               5095      BSR     LAB_ADD         * find arg+1
00A0197A  7000                    5096      MOVEQ       #0,d0               * setup for calc skip
00A0197C  3740 0E00               5097      MOVE.w  d0,FAC2_e(a3)       * set FAC1 for zero result
00A01980  DC86                    5098      ADD.l       d6,d6               * shift 1 bit out
00A01982  2746 0DFC               5099      MOVE.l  d6,FAC2_m(a3)       * put back FAC2
00A01986  6758                    5100      BEQ.s       LAB_LONN            * if 0 skip calculation
00A01988                          5101  
00A01988  377C 8000 0E00          5102      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for .5
00A0198E  6100 0130               5103      BSR     LAB_DIVIDE          * do (arg-1)/(arg+1)
00A01992  4A2B 0DF8               5104      TST.b       FAC1_e(a3)          * test exponent
00A01996  6748                    5105      BEQ.s       LAB_LONN            * if 0 skip calculation
00A01998                          5106  
00A01998  122B 0DF8               5107      MOVE.b  FAC1_e(a3),d1       * get exponent
00A0199C  0401 0082               5108      SUB.b       #$82,d1         * normalise and two integer bits
00A019A0  4401                    5109      NEG.b       d1              * negate for shift
00A019A2                          5110  **  CMP.b       #$1F,d1         * will mantissa vanish?
00A019A2                          5111  **  BGT.s       LAB_dunno           * if so do ???
00A019A2                          5112  
00A019A2  202B 0DF4               5113      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A019A6  E2A8                    5114      LSR.l       d1,d0               * shift in two integer bits
00A019A8                          5115  
00A019A8                          5116  * d0 = arg
00A019A8                          5117  * d0 = x, d1 = y
00A019A8                          5118  * d2 = x1, d3 = y1
00A019A8                          5119  * d4 = shift count
00A019A8                          5120  * d5 = loop count
00A019A8                          5121  * d6 = z
00A019A8                          5122  * a0 = table pointer
00A019A8                          5123  
00A019A8  7C00                    5124      MOVEQ       #0,d6               * z = 0
00A019AA  223C 40000000           5125      MOVE.l  #1<<30,d1           * y = 1
00A019B0  41FA 13FE               5126      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic tangent table
00A019B4  7A1E                    5127      MOVEQ       #30,d5          * loop 31 times
00A019B6  7801                    5128      MOVEQ       #1,d4               * set shift count
00A019B8  6006                    5129      BRA.s       LAB_LOCC            * entry point for loop
00A019BA                          5130  
00A019BA                          5131  LAB_LAAD
00A019BA  E8A2                    5132      ASR.l       d4,d2               * x1 >> i
00A019BC  9282                    5133      SUB.l       d2,d1               * y = y - x1
00A019BE  DC90                    5134      ADD.l       (a0),d6         * z = z + tanh(i)
00A019C0                          5135  LAB_LOCC
00A019C0  2400                    5136      MOVE.l  d0,d2               * x1 = x
00A019C2  2601                    5137      MOVE.l  d1,d3               * y1 = Y
00A019C4  E8A3                    5138      ASR.l       d4,d3               * y1 >> i
00A019C6  6402                    5139      BCC.s       LAB_LOLP
00A019C8                          5140  
00A019C8  5283                    5141      ADDQ.l  #1,d3
00A019CA                          5142  LAB_LOLP
00A019CA  9083                    5143      SUB.l       d3,d0               * x = x - y1
00A019CC  6AEC                    5144      BPL.s       LAB_LAAD            * branch if > 0
00A019CE                          5145  
00A019CE  2002                    5146      MOVE.l  d2,d0               * get x back
00A019D0  5848                    5147      ADDQ.w  #4,a0               * next entry
00A019D2  5284                    5148      ADDQ.l  #1,d4               * next i
00A019D4  E28B                    5149      LSR.l       #1,d3               * /2
00A019D6  6704                    5150      BEQ.s       LAB_LOCX            * branch y1 = 0
00A019D8                          5151  
00A019D8  51CD FFF0               5152      DBF     d5,LAB_LOLP         * decrement and loop if not done
00A019DC                          5153  
00A019DC                          5154                              * now sort out the result
00A019DC                          5155  LAB_LOCX
00A019DC  DC86                    5156      ADD.l       d6,d6               * *2
00A019DE  2006                    5157      MOVE.l  d6,d0               * setup for d7 = 0
00A019E0                          5158  LAB_LONN
00A019E0  2800                    5159      MOVE.l  d0,d4               * save cordic result
00A019E2  7A00                    5160      MOVEQ       #0,d5               * set default exponent sign
00A019E4  4A87                    5161      TST.l       d7              * check original exponent sign
00A019E6  6716                    5162      BEQ.s       LAB_LOXO            * branch if original was 0
00A019E8                          5163  
00A019E8  6A04                    5164      BPL.s       LAB_LOXP            * branch if was +ve
00A019EA                          5165  
00A019EA  4487                    5166      NEG.l       d7              * make original exponent +ve
00A019EC  7A80                    5167      MOVEQ       #$80-$100,d5        * make sign -ve
00A019EE                          5168  LAB_LOXP
00A019EE  1745 0DF9               5169      MOVE.b  d5,FAC1_s(a3)       * save original exponent sign
00A019F2  4847                    5170      SWAP        d7              * 16 bit shift
00A019F4  E18F                    5171      LSL.l       #8,d7               * easy first part
00A019F6  7A88                    5172      MOVEQ       #$88-$100,d5        * start with byte
00A019F8                          5173  LAB_LONE
00A019F8  5385                    5174      SUBQ.l  #1,d5               * decrement exponent
00A019FA  DE87                    5175      ADD.l       d7,d7               * shift mantissa
00A019FC  6AFA                    5176      BPL.s       LAB_LONE            * loop if not normal
00A019FE                          5177  
00A019FE                          5178  LAB_LOXO
00A019FE  2747 0DF4               5179      MOVE.l  d7,FAC1_m(a3)       * save original exponent as mantissa
00A01A02  1745 0DF8               5180      MOVE.b  d5,FAC1_e(a3)       * save exponent for this
00A01A06  277C B17217F8 0DFC      5181      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00A01A0E  377C 8000 0E00          5182      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00A01A14  176B 0DF9 0E02          5183      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00A01A1A  6118                    5184      BSR.s       LAB_MULTIPLY        * do multiply
00A01A1C  2744 0DFC               5185      MOVE.l  d4,FAC2_m(a3)       * save cordic result
00A01A20  6710                    5186      BEQ.s       LAB_LOWZ            * branch if zero
00A01A22                          5187  
00A01A22  377C 8200 0E00          5188      MOVE.w  #$8200,FAC2_e(a3)       * set exponent & sign
00A01A28  176B 0DF9 0E02          5189      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * clear sign compare
00A01A2E  6100 FE60               5190      BSR     LAB_ADD         * and add for final result
00A01A32                          5191  
00A01A32                          5192  LAB_LOWZ
00A01A32  4E75                    5193      RTS
00A01A34                          5194  
00A01A34                          5195  
00A01A34                          5196  *************************************************************************************
00A01A34                          5197  *
00A01A34                          5198  * multiply FAC1 by FAC2
00A01A34                          5199  
00A01A34                          5200  LAB_MULTIPLY
00A01A34  48E7 F800               5201      MOVEM.l d0-d4,-(sp)         * save registers
00A01A38  4A2B 0DF8               5202      TST.b       FAC1_e(a3)          * test FAC1 exponent
00A01A3C  6776                    5203      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00A01A3E                          5204  
00A01A3E  102B 0E00               5205      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00A01A42  6770                    5206      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00A01A44                          5207  
00A01A44  176B 0E02 0DF9          5208      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare becomes sign
00A01A4A                          5209  
00A01A4A  D02B 0DF8               5210      ADD.b       FAC1_e(a3),d0       * multiply exponents by adding
00A01A4E  640A                    5211      BCC.s       LAB_MNOC            * branch if no carry
00A01A50                          5212  
00A01A50  0400 0080               5213      SUB.b       #$80,d0         * normalise result
00A01A54  6400 E70C               5214      BCC     LAB_OFER            * if no carry do overflow
00A01A58                          5215  
00A01A58  6006                    5216      BRA.s       LAB_MADD            * branch
00A01A5A                          5217  
00A01A5A                          5218                              * no carry for exponent add
00A01A5A                          5219  LAB_MNOC
00A01A5A  0400 0080               5220      SUB.b       #$80,d0         * normalise result
00A01A5E  6554                    5221      BCS.s       LAB_MUUF            * return zero if underflow
00A01A60                          5222  
00A01A60                          5223  LAB_MADD
00A01A60  1740 0DF8               5224      MOVE.b  d0,FAC1_e(a3)       * save exponent
00A01A64                          5225  
00A01A64                          5226                              * d1 (FAC1) x d2 (FAC2)
00A01A64  222B 0DF4               5227      MOVE.l  FAC1_m(a3),d1       * get FAC1 mantissa
00A01A68  242B 0DFC               5228      MOVE.l  FAC2_m(a3),d2       * get FAC2 mantissa
00A01A6C                          5229  
00A01A6C  3801                    5230      MOVE.w  d1,d4               * copy low word FAC1
00A01A6E  2001                    5231      MOVE.l  d1,d0               * copy long word FAC1
00A01A70  4840                    5232      SWAP        d0              * high word FAC1 to low word FAC1
00A01A72  3600                    5233      MOVE.w  d0,d3               * copy high word FAC1
00A01A74                          5234  
00A01A74  C2C2                    5235      MULU        d2,d1               * low word FAC2 x low word FAC1
00A01A76  C0C2                    5236      MULU        d2,d0               * low word FAC2 x high word FAC1
00A01A78  4842                    5237      SWAP        d2              * high word FAC2 to low word FAC2
00A01A7A  C8C2                    5238      MULU        d2,d4               * high word FAC2 x low word FAC1
00A01A7C  C6C2                    5239      MULU        d2,d3               * high word FAC2 x high word FAC1
00A01A7E                          5240  
00A01A7E                          5241  * done multiply, now add partial products
00A01A7E                          5242  
00A01A7E                          5243  *           d1 =                    aaaa  ----  FAC2_L x FAC1_L
00A01A7E                          5244  *           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
00A01A7E                          5245  *           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
00A01A7E                          5246  *           d3 =            cccc  bbbb          FAC2_H x FAC1_H
00A01A7E                          5247  *           product =       mmmm  mmmm
00A01A7E                          5248  
00A01A7E  0681 00008000           5249      ADD.L       #$8000,d1           * round up lowest word
00A01A84  4241                    5250      CLR.w       d1              * clear low word, don't need it
00A01A86  4841                    5251      SWAP        d1              * align high word
00A01A88  D280                    5252      ADD.l       d0,d1               * add FAC2_L x FAC1_H (can't be carry)
00A01A8A                          5253  LAB_MUF1
00A01A8A  D284                    5254      ADD.l       d4,d1               * now add intermediate (FAC2_H x FAC1_L)
00A01A8C  6406                    5255      BCC.s       LAB_MUF2            * branch if no carry
00A01A8E                          5256  
00A01A8E  0683 00010000           5257      ADD.l       #$10000,d3          * else correct result
00A01A94                          5258  LAB_MUF2
00A01A94  0681 00008000           5259      ADD.l       #$8000,d1           * round up low word
00A01A9A  4241                    5260      CLR.w       d1              * clear low word
00A01A9C  4841                    5261      SWAP        d1              * align for final add
00A01A9E  D283                    5262      ADD.l       d3,d1               * add FAC2_H x FAC1_H, result
00A01AA0  6B08                    5263      BMI.s       LAB_MUF3            * branch if normalisation not needed
00A01AA2                          5264  
00A01AA2  D281                    5265      ADD.l       d1,d1               * shift mantissa
00A01AA4  532B 0DF8               5266      SUBQ.b  #1,FAC1_e(a3)       * adjust exponent
00A01AA8  670A                    5267      BEQ.s       LAB_MUUF            * branch if underflow
00A01AAA                          5268  
00A01AAA                          5269  LAB_MUF3
00A01AAA  2741 0DF4               5270      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00A01AAE                          5271  LAB_MUEX
00A01AAE  4CDF 001F               5272      MOVEM.l (sp)+,d0-d4         * restore registers
00A01AB2  4E75                    5273      RTS
00A01AB4                          5274                              * either zero or underflow result
00A01AB4                          5275  LAB_MUUF
00A01AB4  7000                    5276      MOVEQ       #0,d0               * quick clear
00A01AB6  2740 0DF4               5277      MOVE.l  d0,FAC1_m(a3)       * clear mantissa
00A01ABA  3740 0DF8               5278      MOVE.w  d0,FAC1_e(a3)       * clear sign and exponent
00A01ABE  60EE                    5279      BRA.s       LAB_MUEX            * restore regs & exit
00A01AC0                          5280  
00A01AC0                          5281  
00A01AC0                          5282  *************************************************************************************
00A01AC0                          5283  *
00A01AC0                          5284  * do FAC2/FAC1, result in FAC1
00A01AC0                          5285  * fast hardware divide version
00A01AC0                          5286  
00A01AC0                          5287  LAB_DIVIDE
00A01AC0  2F07                    5288      MOVE.l  d7,-(sp)            * save d7
00A01AC2  7000                    5289      MOVEQ       #0,d0               * clear FAC2 exponent
00A01AC4  2400                    5290      MOVE.l  d0,d2               * clear FAC1 exponent
00A01AC6                          5291  
00A01AC6  142B 0DF8               5292      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00A01ACA  6700 E682               5293      BEQ     LAB_DZER            * if zero go do /0 error
00A01ACE                          5294  
00A01ACE  102B 0E00               5295      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00A01AD2  6766                    5296      BEQ.s       LAB_DIV0            * if zero return zero
00A01AD4                          5297  
00A01AD4  9042                    5298      SUB.w       d2,d0               * get result exponent by subtracting
00A01AD6  0640 0080               5299      ADD.w       #$80,d0         * correct 16 bit exponent result
00A01ADA                          5300  
00A01ADA  176B 0E02 0DF9          5301      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare is result sign
00A01AE0                          5302  
00A01AE0                          5303  * now to do 32/32 bit mantissa divide
00A01AE0                          5304  
00A01AE0  422B 0E03               5305      CLR.b       flag(a3)            * clear 'flag' byte
00A01AE4  262B 0DF4               5306      MOVE.l  FAC1_m(a3),d3       * get FAC1 mantissa
00A01AE8  282B 0DFC               5307      MOVE.l  FAC2_m(a3),d4       * get FAC2 mantissa
00A01AEC  B883                    5308      CMP.l       d3,d4               * compare FAC2 with FAC1 mantissa
00A01AEE  6744                    5309      BEQ.s       LAB_MAN1            * set mantissa result = 1 if equal
00A01AF0                          5310  
00A01AF0  6506                    5311      BCS.s       AC1gtAC2            * branch if FAC1 > FAC2
00A01AF2                          5312  
00A01AF2  9883                    5313      SUB.l       d3,d4               * subtract FAC1 from FAC2, result now must be <1
00A01AF4  562B 0E03               5314      ADDQ.b  #3,flag(a3)         * FAC2>FAC1 so set 'flag' byte
00A01AF8                          5315  AC1gtAC2
00A01AF8  6146                    5316      BSR.s       LAB_32_16           * do 32/16 divide
00A01AFA  4841                    5317      SWAP        d1              * move 16 bit result to high word
00A01AFC  2802                    5318      MOVE.l  d2,d4               * copy remainder longword
00A01AFE  6142                    5319      BSR.s       LAB_3216            * do 32/16 divide again (skip copy d4 to d2)
00A01B00  84C5                    5320      DIVU.w  d5,d2               * now divide remainder to make guard word
00A01B02  1E2B 0E03               5321      MOVE.b  flag(a3),d7         * now normalise, get flag byte back
00A01B06  6708                    5322      BEQ.s       LAB_DIVX            * skip add if null
00A01B08                          5323  
00A01B08                          5324  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
00A01B08                          5325  
00A01B08  E20F                    5326      LSR.b       #1,d7               * shift 1 into eXtend
00A01B0A  E291                    5327      ROXR.l  #1,d1               * shift extend result >>
00A01B0C  E252                    5328      ROXR.w  #1,d2               * shift extend guard word >>
00A01B0E  5200                    5329      ADDQ.b  #1,d0               * adjust exponent
00A01B10                          5330  
00A01B10                          5331  * now round result to 32 bits
00A01B10                          5332  
00A01B10                          5333  LAB_DIVX
00A01B10  D442                    5334      ADD.w       d2,d2               * guard bit into eXtend bit
00A01B12  6408                    5335      BCC.s       L_DIVRND            * branch if guard=0
00A01B14                          5336  
00A01B14  5281                    5337      ADDQ.l  #1,d1               * add guard to mantissa
00A01B16  6404                    5338      BCC.s       L_DIVRND            * branch if no overflow
00A01B18                          5339  
00A01B18                          5340  LAB_SET1
00A01B18  E291                    5341      ROXR.l  #1,d1               * shift extend result >>
00A01B1A  5240                    5342      ADDQ.w  #1,d0               * adjust exponent
00A01B1C                          5343  
00A01B1C                          5344                              * test for over/under flow
00A01B1C                          5345  L_DIVRND
00A01B1C  3600                    5346      MOVE.w  d0,d3               * copy exponent
00A01B1E  6B1A                    5347      BMI.s       LAB_DIV0            * if -ve return zero
00A01B20                          5348  
00A01B20  0243 FF00               5349      ANDI.w  #$FF00,d3           * mask word high byte
00A01B24  6600 E63C               5350      BNE     LAB_OFER            * branch if overflow
00A01B28                          5351  
00A01B28                          5352                              * move result into FAC1
00A01B28                          5353  LAB_XDIV
00A01B28  2E1F                    5354      MOVE.l  (sp)+,d7            * restore d7
00A01B2A  1740 0DF8               5355      MOVE.b  d0,FAC1_e(a3)       * save result exponent
00A01B2E  2741 0DF4               5356      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00A01B32  4E75                    5357      RTS
00A01B34                          5358  
00A01B34                          5359  * FAC1 mantissa = FAC2 mantissa so set result mantissa
00A01B34                          5360  
00A01B34                          5361  LAB_MAN1
00A01B34  7201                    5362      MOVEQ       #1,d1               * set bit
00A01B36  E2A9                    5363      LSR.l       d1,d1               * bit into eXtend
00A01B38  60DE                    5364      BRA.s       LAB_SET1            * set mantissa, adjust exponent and exit
00A01B3A                          5365  
00A01B3A                          5366  * result is zero
00A01B3A                          5367  
00A01B3A                          5368  LAB_DIV0
00A01B3A  7000                    5369      MOVEQ       #0,d0               * zero exponent & sign
00A01B3C  2200                    5370      MOVE.l  d0,d1               * zero mantissa
00A01B3E  60E8                    5371      BRA     LAB_XDIV            * exit divide
00A01B40                          5372  
00A01B40                          5373  * divide 16 bits into 32, AB/Ex
00A01B40                          5374  *
00A01B40                          5375  * d4            AAAA    BBBB            * 32 bit numerator
00A01B40                          5376  * d3            EEEE    xxxx            * 16 bit denominator
00A01B40                          5377  *
00A01B40                          5378  * returns -
00A01B40                          5379  *
00A01B40                          5380  * d1            xxxx    DDDD            * 16 bit result
00A01B40                          5381  * d2                HHHH    IIII        * 32 bit remainder
00A01B40                          5382  
00A01B40                          5383  LAB_32_16
00A01B40  2404                    5384      MOVE.l  d4,d2               * copy FAC2 mantissa        (AB)
00A01B42                          5385  LAB_3216
00A01B42  2A03                    5386      MOVE.l  d3,d5               * copy FAC1 mantissa        (EF)
00A01B44  4245                    5387      CLR.w       d5              * clear low word d1     (Ex)
00A01B46  4845                    5388      SWAP        d5              * swap high word to low word    (xE)
00A01B48                          5389  
00A01B48                          5390  * d3            EEEE    FFFF            * denominator copy
00A01B48                          5391  * d5        0000    EEEE                * denominator high word
00A01B48                          5392  * d2            AAAA    BBBB            * numerator copy
00A01B48                          5393  * d4            AAAA    BBBB            * numerator
00A01B48                          5394  
00A01B48  88C5                    5395      DIVU.w  d5,d4               * do FAC2/FAC1 high word    (AB/E)
00A01B4A  6802                    5396      BVC.s       LAB_LT_1            * if no overflow DIV was ok
00A01B4C                          5397  
00A01B4C  78FF                    5398      MOVEQ       #-1,d4          * else set default value
00A01B4E                          5399  
00A01B4E                          5400  * done the divide, now check the result, we have ...
00A01B4E                          5401  
00A01B4E                          5402  * d3            EEEE    FFFF            * denominator copy
00A01B4E                          5403  * d5        0000    EEEE                * denominator high word
00A01B4E                          5404  * d2            AAAA    BBBB            * numerator copy
00A01B4E                          5405  * d4            MMMM    DDDD            * result MOD and DIV
00A01B4E                          5406  
00A01B4E                          5407  LAB_LT_1
00A01B4E  3C04                    5408      MOVE.w  d4,d6               * copy 16 bit result
00A01B50  3204                    5409      MOVE.w  d4,d1               * copy 16 bit result again
00A01B52                          5410  
00A01B52                          5411  * we now have ..
00A01B52                          5412  * d3            EEEE    FFFF            * denominator copy
00A01B52                          5413  * d5        0000    EEEE                * denominator high word
00A01B52                          5414  * d6            xxxx  DDDD          * result DIV copy
00A01B52                          5415  * d1            xxxx  DDDD          * result DIV copy
00A01B52                          5416  * d2            AAAA    BBBB            * numerator copy
00A01B52                          5417  * d4            MMMM    DDDD            * result MOD and DIV
00A01B52                          5418  
00A01B52                          5419  * now multiply out 32 bit denominator by 16 bit result
00A01B52                          5420  * QRS = AB*D
00A01B52                          5421  
00A01B52  CCC3                    5422      MULU.w  d3,d6               * FFFF * DDDD =       rrrr  SSSS
00A01B54  C8C5                    5423      MULU.w  d5,d4               * EEEE * DDDD = QQQQ  rrrr
00A01B56                          5424  
00A01B56                          5425  * we now have ..
00A01B56                          5426  * d3            EEEE    FFFF            * denominator copy
00A01B56                          5427  * d5        0000    EEEE                * denominator high word
00A01B56                          5428  * d6                rrrr  SSSS      * 48 bit result partial low
00A01B56                          5429  * d1            xxxx  DDDD          * result DIV copy
00A01B56                          5430  * d2            AAAA    BBBB            * numerator copy
00A01B56                          5431  * d4            QQQQ    rrrr            * 48 bit result partial
00A01B56                          5432  
00A01B56  3E06                    5433      MOVE.w  d6,d7               * copy low word of low multiply
00A01B58                          5434  
00A01B58                          5435  * d7                xxxx    SSSS        * 48 bit result partial low
00A01B58                          5436  
00A01B58  4246                    5437      CLR.w       d6              * clear low word of low multiply
00A01B5A  4846                    5438      SWAP        d6              * high word of low multiply to low word
00A01B5C                          5439  
00A01B5C                          5440  * d6            0000    rrrr            * high word of 48 bit result partial low
00A01B5C                          5441  
00A01B5C  D886                    5442      ADD.l       d6,d4
00A01B5E                          5443  
00A01B5E                          5444  * d4            QQQQ    RRRR            * 48 bit result partial high longword
00A01B5E                          5445  
00A01B5E  7C00                    5446      MOVEQ       #0,d6               * clear to extend numerator to 48 bits
00A01B60                          5447  
00A01B60                          5448  * now do GHI = AB0 - QRS (which is the remainder)
00A01B60                          5449  
00A01B60  9C47                    5450      SUB.w       d7,d6               * low word subtract
00A01B62                          5451  
00A01B62                          5452  * d6                xxxx    IIII        * remainder low word
00A01B62                          5453  
00A01B62  9584                    5454      SUBX.l  d4,d2               * high longword subtract
00A01B64                          5455  
00A01B64                          5456  * d2            GGGG    HHHH            * remainder high longword
00A01B64                          5457  
00A01B64                          5458  * now if we got the divide correct then the remainder high longword will be +ve
00A01B64                          5459  
00A01B64  6A08                    5460      BPL.s       L_DDIV          * branch if result is ok (<needed)
00A01B66                          5461  
00A01B66                          5462  * remainder was -ve so DDDD is too big
00A01B66                          5463  
00A01B66                          5464  LAB_REMM
00A01B66  5341                    5465      SUBQ.w  #1,d1               * adjust DDDD
00A01B68                          5466  
00A01B68                          5467  * d3                xxxx    FFFF        * denominator copy
00A01B68                          5468  * d6                xxxx    IIII        * remainder low word
00A01B68                          5469  
00A01B68  DC43                    5470      ADD.w       d3,d6               * add EF*1 low remainder low word
00A01B6A                          5471  
00A01B6A                          5472  * d5            0000    EEEE            * denominator high word
00A01B6A                          5473  * d2            GGGG    HHHH            * remainder high longword
00A01B6A                          5474  
00A01B6A  D585                    5475      ADDX.l  d5,d2               * add extend EF*1 to remainder high longword
00A01B6C  6BF8                    5476      BMI.s       LAB_REMM            * loop if result still too big
00A01B6E                          5477  
00A01B6E                          5478  * all done and result correct or <
00A01B6E                          5479  
00A01B6E                          5480  L_DDIV
00A01B6E  4842                    5481      SWAP        d2              * remainder mid word to high word
00A01B70                          5482  
00A01B70                          5483  * d2            HHHH    GGGG            * (high word /should/ be $0000)
00A01B70                          5484  
00A01B70  3406                    5485      MOVE.w  d6,d2               * remainder in high word
00A01B72                          5486  
00A01B72                          5487  * d2                HHHH    IIII        * now is 32 bit remainder
00A01B72                          5488  * d1            xxxx    DDDD            * 16 bit result
00A01B72                          5489  
00A01B72  4E75                    5490      RTS
00A01B74                          5491  
00A01B74                          5492  
00A01B74                          5493  *************************************************************************************
00A01B74                          5494  *
00A01B74                          5495  * unpack memory (a0) into FAC1
00A01B74                          5496  
00A01B74                          5497  LAB_UFAC
00A01B74  2010                    5498      MOVE.l  (a0),d0         * get packed value
00A01B76  4840                    5499      SWAP        d0              * exponent and sign into least significant word
00A01B78  3740 0DF8               5500      MOVE.w  d0,FAC1_e(a3)       * save exponent and sign
00A01B7C  6708                    5501      BEQ.s       LAB_NB1T            * branch if exponent (and the rest) zero
00A01B7E                          5502  
00A01B7E  807C 0080               5503      OR.w        #$80,d0         * set MSb
00A01B82  4840                    5504      SWAP        d0              * word order back to normal
00A01B84  E180                    5505      ASL.l       #8,d0               * shift exponent & clear guard byte
00A01B86                          5506  LAB_NB1T
00A01B86  2740 0DF4               5507      MOVE.l  d0,FAC1_m(a3)       * move into FAC1
00A01B8A                          5508  
00A01B8A  102B 0DF8               5509      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A01B8E  4E75                    5510      RTS
00A01B90                          5511  
00A01B90                          5512  
00A01B90                          5513  *************************************************************************************
00A01B90                          5514  *
00A01B90                          5515  * set numeric variable, pack FAC1 into Lvarpl
00A01B90                          5516  
00A01B90                          5517  LAB_PFAC
00A01B90  2F08                    5518      MOVE.l  a0,-(sp)            * save pointer
00A01B92  206B 0CD6               5519      MOVEA.l Lvarpl(a3),a0       * get destination pointer
00A01B96  082B 0006 0E19          5520      BTST        #6,Dtypef(a3)       * test data type
00A01B9C  670C                    5521      BEQ.s       LAB_277C            * branch if floating
00A01B9E                          5522  
00A01B9E  6100 00C6               5523      BSR     LAB_2831            * convert FAC1 floating to fixed
00A01BA2                          5524                              * result in d0 and Itemp
00A01BA2  2080                    5525      MOVE.l  d0,(a0)         * save in var
00A01BA4  205F                    5526      MOVE.l  (sp)+,a0            * restore pointer
00A01BA6  4E75                    5527      RTS
00A01BA8                          5528  
00A01BA8                          5529  
00A01BA8                          5530  *************************************************************************************
00A01BA8                          5531  *
00A01BA8                          5532  * normalise round and pack FAC1 into (a0)
00A01BA8                          5533  
00A01BA8                          5534  LAB_2778
00A01BA8  2F08                    5535      MOVE.l  a0,-(sp)            * save pointer
00A01BAA                          5536  LAB_277C
00A01BAA  6100 FD60               5537      BSR     LAB_24D5            * normalise FAC1
00A01BAE  612C                    5538      BSR.s       LAB_27BA            * round FAC1
00A01BB0  202B 0DF4               5539      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00A01BB4  E098                    5540      ROR.l       #8,d0               * align 24/32 bit mantissa
00A01BB6  4840                    5541      SWAP        d0              * exponent/sign into 0-15
00A01BB8  C07C 007F               5542      AND.w       #$7F,d0         * clear exponent and sign bit
00A01BBC  022B 0080 0DF9          5543      ANDI.b  #$80,FAC1_s(a3)     * clear non sign bits in sign
00A01BC2  806B 0DF8               5544      OR.w        FAC1_e(a3),d0       * OR in exponent and sign
00A01BC6  4840                    5545      SWAP        d0              * move exponent and sign back to 16-31
00A01BC8  2080                    5546      MOVE.l  d0,(a0)         * store in destination
00A01BCA  205F                    5547      MOVE.l  (sp)+,a0            * restore pointer
00A01BCC  4E75                    5548      RTS
00A01BCE                          5549  
00A01BCE                          5550  
00A01BCE                          5551  *************************************************************************************
00A01BCE                          5552  *
00A01BCE                          5553  * copy FAC2 to FAC1
00A01BCE                          5554  
00A01BCE                          5555  LAB_279B
00A01BCE  376B 0E00 0DF8          5556      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy exponent & sign
00A01BD4  276B 0DFC 0DF4          5557      MOVE.l  FAC2_m(a3),FAC1_m(a3)   * copy mantissa
00A01BDA  4E75                    5558      RTS
00A01BDC                          5559  
00A01BDC                          5560  
00A01BDC                          5561  *************************************************************************************
00A01BDC                          5562  *
00A01BDC                          5563  * round FAC1
00A01BDC                          5564  
00A01BDC                          5565  LAB_27BA
00A01BDC  102B 0DF8               5566      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A01BE0  6720                    5567      BEQ.s       LAB_27C4            * branch if zero
00A01BE2                          5568  
00A01BE2  202B 0DF4               5569      MOVE.l  FAC1_m(a3),d0       * get FAC1
00A01BE6  0680 00000080           5570      ADD.l       #$80,d0         * round to 24 bit
00A01BEC  640A                    5571      BCC.s       LAB_27C3            * branch if no overflow
00A01BEE                          5572  
00A01BEE  E290                    5573      ROXR.l  #1,d0               * shift FAC1 mantissa
00A01BF0  522B 0DF8               5574      ADDQ.b  #1,FAC1_e(a3)       * correct exponent
00A01BF4  6500 E56C               5575      BCS     LAB_OFER            * if carry do overflow error & warm start
00A01BF8                          5576  
00A01BF8                          5577  LAB_27C3
00A01BF8  C03C 0000               5578      AND.b       #$00,d0         * clear guard byte
00A01BFC  2740 0DF4               5579      MOVE.l  d0,FAC1_m(a3)       * save back to FAC1
00A01C00  4E75                    5580      RTS
00A01C02                          5581  
00A01C02                          5582  LAB_27C4
00A01C02  1740 0DF9               5583      MOVE.b  d0,FAC1_s(a3)       * make zero always +ve
00A01C06                          5584  RTS_017
00A01C06  4E75                    5585      RTS
00A01C08                          5586  
00A01C08                          5587  
00A01C08                          5588  *************************************************************************************
00A01C08                          5589  *
00A01C08                          5590  * get FAC1 sign
00A01C08                          5591  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00A01C08                          5592  
00A01C08                          5593  LAB_27CA
00A01C08  7000                    5594      MOVEQ       #0,d0               * clear d0
00A01C0A  102B 0DF8               5595      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A01C0E  67F6                    5596      BEQ.s       RTS_017         * exit if zero (already correct SGN(0)=0)
00A01C10                          5597  
00A01C10                          5598  
00A01C10                          5599  *************************************************************************************
00A01C10                          5600  *
00A01C10                          5601  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00A01C10                          5602  * no = 0 check
00A01C10                          5603  
00A01C10                          5604  LAB_27CE
00A01C10  102B 0DF9               5605      MOVE.b  FAC1_s(a3),d0       * else get FAC1 sign (b7)
00A01C14                          5606  
00A01C14                          5607  
00A01C14                          5608  *************************************************************************************
00A01C14                          5609  *
00A01C14                          5610  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00A01C14                          5611  * no = 0 check, sign in d0
00A01C14                          5612  
00A01C14                          5613  LAB_27D0
00A01C14  4880                    5614      EXT.w       d0              * make word
00A01C16  48C0                    5615      EXT.l       d0              * make longword
00A01C18  E080                    5616      ASR.l       #8,d0               * move sign bit through byte to carry
00A01C1A  65EA                    5617      BCS.s       RTS_017         * exit if carry set
00A01C1C                          5618  
00A01C1C  7001                    5619      MOVEQ       #1,d0               * set result for +ve sign
00A01C1E  4E75                    5620      RTS
00A01C20                          5621  
00A01C20                          5622  
00A01C20                          5623  *************************************************************************************
00A01C20                          5624  *
00A01C20                          5625  * perform SGN()
00A01C20                          5626  
00A01C20                          5627  LAB_SGN
00A01C20  61E6                    5628      BSR.s       LAB_27CA            * get FAC1 sign
00A01C22                          5629                              * return d0=-1/-ve d0=+1/+ve
00A01C22                          5630  
00A01C22                          5631  
00A01C22                          5632  *************************************************************************************
00A01C22                          5633  *
00A01C22                          5634  * save d0 as integer longword
00A01C22                          5635  
00A01C22                          5636  LAB_27DB
00A01C22  2740 0DF4               5637      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00A01C26  377C A000 0DF8          5638      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent & sign
00A01C2C  D080                    5639      ADD.l       d0,d0               * top bit into carry
00A01C2E  6000 FCD0               5640      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00A01C32                          5641  
00A01C32                          5642  
00A01C32                          5643  *************************************************************************************
00A01C32                          5644  *
00A01C32                          5645  * perform ABS()
00A01C32                          5646  
00A01C32                          5647  LAB_ABS
00A01C32  177C 0000 0DF9          5648      MOVE.b  #0,FAC1_s(a3)       * clear FAC1 sign
00A01C38  4E75                    5649      RTS
00A01C3A                          5650  
00A01C3A                          5651  
00A01C3A                          5652  *************************************************************************************
00A01C3A                          5653  *
00A01C3A                          5654  * compare FAC1 with FAC2
00A01C3A                          5655  * returns d0=+1 Cb=0 if FAC1 > FAC2
00A01C3A                          5656  * returns d0= 0 Cb=0 if FAC1 = FAC2
00A01C3A                          5657  * returns d0=-1 Cb=1 if FAC1 < FAC2
00A01C3A                          5658  
00A01C3A                          5659  LAB_27FA
00A01C3A  122B 0E00               5660      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00A01C3E  67C8                    5661      BEQ.s       LAB_27CA            * branch if FAC2 exponent=0 & get FAC1 sign
00A01C40                          5662                              * d0=-1,C=1/-ve d0=+1,C=0/+ve
00A01C40                          5663  
00A01C40  102B 0E02               5664      MOVE.b  FAC_sc(a3),d0       * get FAC sign compare
00A01C44  6BCA                    5665      BMI.s       LAB_27CE            * if signs <> do return d0=-1,C=1/-ve
00A01C46                          5666                              * d0=+1,C=0/+ve & return
00A01C46                          5667  
00A01C46  102B 0DF9               5668      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00A01C4A  B22B 0DF8               5669      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00A01C4E  660A                    5670      BNE.s       LAB_2828            * branch if different
00A01C50                          5671  
00A01C50  222B 0DFC               5672      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00A01C54  B2AB 0DF4               5673      CMP.l       FAC1_m(a3),d1       * compare mantissas
00A01C58  6708                    5674      BEQ.s       LAB_282F            * exit if mantissas equal
00A01C5A                          5675  
00A01C5A                          5676  * gets here if number <> FAC1
00A01C5A                          5677  
00A01C5A                          5678  LAB_2828
00A01C5A  65B8                    5679      BCS.s       LAB_27D0            * if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
00A01C5C                          5680                              * C=0/+ve
00A01C5C                          5681  
00A01C5C  0A00 0080               5682      EORI.b  #$80,d0         * else toggle FAC1 sign
00A01C60                          5683  LAB_282E
00A01C60  60B2                    5684      BRA.s       LAB_27D0            * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00A01C62                          5685  
00A01C62                          5686  LAB_282F
00A01C62  7000                    5687      MOVEQ       #0,d0               * clear result
00A01C64  4E75                    5688      RTS
00A01C66                          5689  
00A01C66                          5690  
00A01C66                          5691  *************************************************************************************
00A01C66                          5692  *
00A01C66                          5693  * convert FAC1 floating to fixed
00A01C66                          5694  * result in d0 and Itemp, sets flags correctly
00A01C66                          5695  
00A01C66                          5696  LAB_2831
00A01C66  202B 0DF4               5697      MOVE.l  FAC1_m(a3),d0       * copy mantissa
00A01C6A  6730                    5698      BEQ.s       LAB_284J            * branch if mantissa = 0
00A01C6C                          5699  
00A01C6C  2F01                    5700      MOVE.l  d1,-(sp)            * save d1
00A01C6E  72A0                    5701      MOVEQ       #$A0,d1         * set for no floating bits
00A01C70  922B 0DF8               5702      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent
00A01C74  6500 E4EC               5703      BCS     LAB_OFER            * do overflow if too big
00A01C78                          5704  
00A01C78  660E                    5705      BNE.s       LAB_284G            * branch if exponent was not $A0
00A01C7A                          5706  
00A01C7A  4A2B 0DF9               5707      TST.b       FAC1_s(a3)          * test FAC1 sign
00A01C7E  6A1A                    5708      BPL.s       LAB_284H            * branch if FAC1 +ve
00A01C80                          5709  
00A01C80  4480                    5710      NEG.l       d0
00A01C82  6916                    5711      BVS.s       LAB_284H            * branch if was $80000000
00A01C84                          5712  
00A01C84  6000 E4DC               5713      BRA     LAB_OFER            * do overflow if too big
00A01C88                          5714  
00A01C88                          5715  LAB_284G
00A01C88  B23C 0020               5716      CMP.b       #$20,d1         * compare with minimum result for integer
00A01C8C  6502                    5717      BCS.s       LAB_284L            * if < minimum just do shift
00A01C8E                          5718  
00A01C8E  7000                    5719      MOVEQ       #0,d0               * else return zero
00A01C90                          5720  LAB_284L
00A01C90  E2A8                    5721      LSR.l       d1,d0               * shift integer
00A01C92                          5722  
00A01C92  4A2B 0DF9               5723      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00A01C96  6A02                    5724      BPL.s       LAB_284H            * branch if FAC1 +ve
00A01C98                          5725  
00A01C98  4480                    5726      NEG.l       d0              * negate integer value
00A01C9A                          5727  LAB_284H
00A01C9A  221F                    5728      MOVE.l  (sp)+,d1            * restore d1
00A01C9C                          5729  LAB_284J
00A01C9C  2740 0C8E               5730      MOVE.l  d0,Itemp(a3)        * save result to Itemp
00A01CA0  4E75                    5731      RTS
00A01CA2                          5732  
00A01CA2                          5733  
00A01CA2                          5734  *************************************************************************************
00A01CA2                          5735  *
00A01CA2                          5736  * perform INT()
00A01CA2                          5737  
00A01CA2                          5738  LAB_INT
00A01CA2  70A0                    5739      MOVEQ       #$A0,d0         * set for no floating bits
00A01CA4  902B 0DF8               5740      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00A01CA8  6310                    5741      BLS.s       LAB_IRTS            * exit if exponent >= $A0
00A01CAA                          5742                              * (too big for fraction part!)
00A01CAA                          5743  
00A01CAA  B03C 0020               5744      CMP.b       #$20,d0         * compare with minimum result for integer
00A01CAE  6400 025E               5745      BCC     LAB_POZE            * if >= minimum go return 0
00A01CB2                          5746                              * (too small for integer part!)
00A01CB2                          5747  
00A01CB2  72FF                    5748      MOVEQ       #-1,d1          * set integer mask
00A01CB4  E1A1                    5749      ASL.l       d0,d1               * shift mask [8+2*d0]
00A01CB6  C3AB 0DF4               5750      AND.l       d1,FAC1_m(a3)       * mask mantissa
00A01CBA                          5751  LAB_IRTS
00A01CBA  4E75                    5752      RTS
00A01CBC                          5753  
00A01CBC                          5754  
00A01CBC                          5755  *************************************************************************************
00A01CBC                          5756  *
00A01CBC                          5757  * print " in line [LINE #]"
00A01CBC                          5758  
00A01CBC                          5759  LAB_2953
00A01CBC  41FA 17FA               5760      LEA     LAB_LMSG(pc),a0     * point to " in line " message
00A01CC0  6100 ED24               5761      BSR     LAB_18C3            * print null terminated string
00A01CC4                          5762  
00A01CC4                          5763                              * Print Basic line #
00A01CC4  202B 0CB6               5764      MOVE.l  Clinel(a3),d0       * get current line
00A01CC8                          5765  
00A01CC8                          5766  
00A01CC8                          5767  *************************************************************************************
00A01CC8                          5768  *
00A01CC8                          5769  * print d0 as unsigned integer
00A01CC8                          5770  
00A01CC8                          5771  LAB_295E
00A01CC8  43FA 0DE8               5772      LEA     Bin2dec(pc),a1      * get table address
00A01CCC  7200                    5773      MOVEQ       #0,d1               * table index
00A01CCE  41EB 0E30               5774      LEA     Usdss(a3),a0        * output string start
00A01CD2  2401                    5775      MOVE.l  d1,d2               * output string index
00A01CD4                          5776  LAB_2967
00A01CD4  2631 1000               5777      MOVE.l  (a1,d1.w),d3        * get table value
00A01CD8  6714                    5778      BEQ.s       LAB_2969            * exit if end marker
00A01CDA                          5779  
00A01CDA  782F                    5780      MOVEQ       #'0'-1,d4           * set character to "0"-1
00A01CDC                          5781  LAB_2968
00A01CDC  5244                    5782      ADDQ.w  #1,d4               * next numeric character
00A01CDE  9083                    5783      SUB.l       d3,d0               * subtract table value
00A01CE0  6AFA                    5784      BPL.s       LAB_2968            * not overdone so loop
00A01CE2                          5785  
00A01CE2  D083                    5786      ADD.l       d3,d0               * correct value
00A01CE4  1184 2000               5787      MOVE.b  d4,(a0,d2.w)        * character out to string
00A01CE8  5841                    5788      ADDQ.w  #4,d1               * increment table pointer
00A01CEA  5242                    5789      ADDQ.w  #1,d2               * increment output string pointer
00A01CEC  60E6                    5790      BRA.s       LAB_2967            * loop
00A01CEE                          5791  
00A01CEE                          5792  LAB_2969
00A01CEE  0600 0030               5793      ADD.b       #'0',d0         * make last character
00A01CF2  1180 2000               5794      MOVE.b  d0,(a0,d2.w)        * character out to string
00A01CF6  5348                    5795      SUBQ.w  #1,a0               * decrement a0 (allow simple loop)
00A01CF8                          5796  
00A01CF8                          5797                              * now find non zero start of string
00A01CF8                          5798  LAB_296A
00A01CF8  5248                    5799      ADDQ.w  #1,a0               * increment a0 (this will never carry to b16)
00A01CFA  43EB 0E39               5800      LEA     BHsend-1(a3),a1     * get string end
00A01CFE  B1C9                    5801      CMPA.l  a1,a0               * are we at end
00A01D00  6700 ECE4               5802      BEQ     LAB_18C3            * if so print null terminated string and RETURN
00A01D04                          5803  
00A01D04  0C10 0030               5804      CMPI.b  #'0',(a0)           * is character "0" ?
00A01D08  67EE                    5805      BEQ.s       LAB_296A            * loop if so
00A01D0A                          5806  
00A01D0A  6000 ECDA               5807      BRA     LAB_18C3            * print null terminated string from memory & RET
00A01D0E                          5808  
00A01D0E                          5809  
00A01D0E                          5810  *************************************************************************************
00A01D0E                          5811  *
00A01D0E                          5812  * convert FAC1 to ASCII string result in (a0)
00A01D0E                          5813  * STR$() function enters here
00A01D0E                          5814  
00A01D0E                          5815  * now outputs 7 significant digits
00A01D0E                          5816  
00A01D0E                          5817  * d0 is character out
00A01D0E                          5818  * d1 is save index
00A01D0E                          5819  * d2 is gash
00A01D0E                          5820  
00A01D0E                          5821  * a0 is output string pointer
00A01D0E                          5822  
00A01D0E                          5823  LAB_2970
00A01D0E  43EB 0E2A               5824      LEA     Decss(a3),a1        * set output string start
00A01D12                          5825  
00A01D12  7420                    5826      MOVEQ       #' ',d2         * character = " ", assume +ve
00A01D14  08AB 0007 0DF9          5827      BCLR.b  #7,FAC1_s(a3)       * test and clear FAC1 sign (b7)
00A01D1A  6702                    5828      BEQ.s       LAB_2978            * branch if +ve
00A01D1C                          5829  
00A01D1C  742D                    5830      MOVEQ       #'-',d2         * else character = "-"
00A01D1E                          5831  LAB_2978
00A01D1E  1282                    5832      MOVE.b  d2,(a1)         * save the sign character
00A01D20  142B 0DF8               5833      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00A01D24  6608                    5834      BNE.s       LAB_2989            * branch if FAC1<>0
00A01D26                          5835  
00A01D26                          5836                              * exponent was $00 so FAC1 is 0
00A01D26  7030                    5837      MOVEQ       #'0',d0         * set character = "0"
00A01D28  7201                    5838      MOVEQ       #1,d1               * set output string index
00A01D2A  6000 01A4               5839      BRA     LAB_2A89            * save last character, [EOT] & exit
00A01D2E                          5840  
00A01D2E                          5841                              * FAC1 is some non zero value
00A01D2E                          5842  LAB_2989
00A01D2E  177C 0000 0E10          5843      MOVE.b  #0,numexp(a3)       * clear number exponent count
00A01D34  B43C 0081               5844      CMP.b       #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
00A01D38                          5845  
00A01D38  6448                    5846      BCC.s       LAB_299C            * branch if FAC1=>1
00A01D3A                          5847  
00A01D3A                          5848                              * else FAC1 < 1
00A01D3A  277C 98968000 0DFC      5849      MOVE.l  #$98968000,FAC2_m(a3)   * 10000000 mantissa
00A01D42  377C 9800 0E00          5850      MOVE.w  #$9800,FAC2_e(a3)       * 10000000 exponent & sign
00A01D48  176B 0DF9 0E02          5851      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make FAC1 sign sign compare
00A01D4E  6100 FCE4               5852      BSR     LAB_MULTIPLY        * do FAC2*FAC1
00A01D52                          5853  
00A01D52  177C 00F9 0E10          5854      MOVE.b  #$F9,numexp(a3)     * set number exponent count (-7)
00A01D58  6028                    5855      BRA.s       LAB_299C            * go test for fit
00A01D5A                          5856  
00A01D5A                          5857  LAB_29B9
00A01D5A  376B 0DF8 0E00          5858      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00A01D60  276B 0DF4 0DFC          5859      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00A01D66  176B 0DF9 0E02          5860      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * save FAC1_s as sign compare
00A01D6C                          5861  
00A01D6C  277C CCCCCCCD 0DF4      5862      MOVE.l  #$CCCCCCCD,FAC1_m(a3)   * 1/10 mantissa
00A01D74  377C 7D00 0DF8          5863      MOVE.w  #$7D00,FAC1_e(a3)       * 1/10 exponent & sign
00A01D7A  6100 FCB8               5864      BSR     LAB_MULTIPLY        * do FAC2*FAC1, effectively divide by 10 but
00A01D7E                          5865                              * faster
00A01D7E                          5866  
00A01D7E  522B 0E10               5867      ADDQ.b  #1,numexp(a3)       * increment number exponent count
00A01D82                          5868  LAB_299C
00A01D82  277C 98967F70 0DFC      5869      MOVE.l  #$98967F70,FAC2_m(a3)   * 9999999.4375 mantissa
00A01D8A  377C 9800 0E00          5870      MOVE.w  #$9800,FAC2_e(a3)       * 9999999.4375 exponent & sign
00A01D90                          5871                              * (max before scientific notation)
00A01D90  6100 014C               5872      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00A01D94                          5873                              * returns d0=+1 C=0 if FAC1 > FAC2
00A01D94                          5874                              * returns d0= 0 C=0 if FAC1 = FAC2
00A01D94                          5875                              * returns d0=-1 C=1 if FAC1 < FAC2
00A01D94  62C4                    5876      BHI.s       LAB_29B9            * go do /10 if FAC1 > 9999999.4375
00A01D96                          5877  
00A01D96  6750                    5878      BEQ.s       LAB_29C3            * branch if FAC1 = 9999999.4375
00A01D98                          5879  
00A01D98                          5880                              * FAC1 < 9999999.4375
00A01D98  277C F423F800 0DFC      5881      MOVE.l  #$F423F800,FAC2_m(a3)   * set mantissa for 999999.5
00A01DA0  377C 9400 0E00          5882      MOVE.w  #$9400,FAC2_e(a3)       * set exponent for 999999.5
00A01DA6                          5883  
00A01DA6  41EB 0DF4               5884      LEA     FAC1_m(a3),a0       * set pointer for x10
00A01DAA                          5885  LAB_29A7
00A01DAA  6100 0132               5886      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00A01DAE                          5887                              * returns d0=+1 C=0 if FAC1 > FAC2
00A01DAE                          5888                              * returns d0= 0 C=0 if FAC1 = FAC2
00A01DAE                          5889                              * returns d0=-1 C=1 if FAC1 < FAC2
00A01DAE  6220                    5890      BHI.s       LAB_29C0            * branch if FAC1 > 99999.9375,no decimal places
00A01DB0                          5891  
00A01DB0                          5892                              * FAC1 <= 999999.5 so do x 10
00A01DB0  2010                    5893      MOVE.l  (a0),d0         * get FAC1 mantissa
00A01DB2  1228 0004               5894      MOVE.b  4(a0),d1            * get FAC1 exponent
00A01DB6  2400                    5895      MOVE.l  d0,d2               * copy it
00A01DB8  E488                    5896      LSR.l       #2,d0               * /4
00A01DBA  D082                    5897      ADD.l       d2,d0               * add FAC1 (x1.125)
00A01DBC  6404                    5898      BCC.s       LAB_29B7            * branch if no carry
00A01DBE                          5899  
00A01DBE  E290                    5900      ROXR.l  #1,d0               * shift carry back in
00A01DC0  5201                    5901      ADDQ.b  #1,d1               * increment exponent (never overflows)
00A01DC2                          5902  LAB_29B7
00A01DC2  5601                    5903      ADDQ.b  #3,d1               * correct exponent ( 8 x 1.125 = 10 )
00A01DC4                          5904                              * (never overflows)
00A01DC4  2080                    5905      MOVE.l  d0,(a0)         * save new mantissa
00A01DC6  1141 0004               5906      MOVE.b  d1,4(a0)            * save new exponent
00A01DCA  532B 0E10               5907      SUBQ.b  #1,numexp(a3)       * decrement number exponent count
00A01DCE  60DA                    5908      BRA.s       LAB_29A7            * go test again
00A01DD0                          5909  
00A01DD0                          5910                              * now we have just the digits to do
00A01DD0                          5911  LAB_29C0
00A01DD0  277C 80000000 0DFC      5912      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 0.5
00A01DD8  377C 8000 0E00          5913      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for 0.5
00A01DDE  176B 0DF9 0E02          5914      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00A01DE4  6100 FAAA               5915      BSR     LAB_ADD         * add the 0.5 to FAC1 (round FAC1)
00A01DE8                          5916  
00A01DE8                          5917  LAB_29C3
00A01DE8  6100 FE7C               5918      BSR     LAB_2831            * convert FAC1 floating to fixed
00A01DEC                          5919                              * result in d0 and Itemp
00A01DEC  7401                    5920      MOVEQ       #$01,d2         * set default digits before dp = 1
00A01DEE  102B 0E10               5921      MOVE.b  numexp(a3),d0       * get number exponent count
00A01DF2  5000                    5922      ADD.b       #8,d0               * allow 7 digits before point
00A01DF4  6B0C                    5923      BMI.s       LAB_29D9            * if -ve then 1 digit before dp
00A01DF6                          5924  
00A01DF6  B03C 0009               5925      CMP.b       #$09,d0         * d0>=9 if n>=1E7
00A01DFA  6406                    5926      BCC.s       LAB_29D9            * branch if >= $09
00A01DFC                          5927  
00A01DFC                          5928                              * < $08
00A01DFC  5300                    5929      SUBQ.b  #1,d0               * take 1 from digit count
00A01DFE  1400                    5930      MOVE.b  d0,d2               * copy byte
00A01E00  7002                    5931      MOVEQ       #$02,d0         * set exponent adjust
00A01E02                          5932  LAB_29D9
00A01E02  7200                    5933      MOVEQ       #0,d1               * set output string index
00A01E04  5500                    5934      SUBQ.b  #2,d0               * -2
00A01E06  1740 0E11               5935      MOVE.b  d0,expcnt(a3)       * save exponent adjust
00A01E0A  1742 0E10               5936      MOVE.b  d2,numexp(a3)       * save digits before dp count
00A01E0E  1002                    5937      MOVE.b  d2,d0               * copy digits before dp count
00A01E10  6702                    5938      BEQ.s       LAB_29E4            * branch if no digits before dp
00A01E12                          5939  
00A01E12  6A14                    5940      BPL.s       LAB_29F7            * branch if digits before dp
00A01E14                          5941  
00A01E14                          5942  LAB_29E4
00A01E14  5281                    5943      ADDQ.l  #1,d1               * increment index
00A01E16  13BC 002E 1000          5944      MOVE.b  #'.',(a1,d1.w)      * save to output string
00A01E1C                          5945  
00A01E1C  4A02                    5946      TST.b       d2              * test digits before dp count
00A01E1E  6708                    5947      BEQ.s       LAB_29F7            * branch if no digits before dp
00A01E20                          5948  
00A01E20  5281                    5949      ADDQ.l  #1,d1               * increment index
00A01E22  13BC 0030 1000          5950      MOVE.b  #'0',(a1,d1.w)      * save to output string
00A01E28                          5951  LAB_29F7
00A01E28  7400                    5952      MOVEQ       #0,d2               * clear index (point to 1,000,000)
00A01E2A  7080                    5953      MOVEQ       #$80-$100,d0        * set output character
00A01E2C                          5954  LAB_29FB
00A01E2C  41FA 111E               5955      LEA     LAB_2A9A(pc),a0     * get base of table
00A01E30  2630 2000               5956      MOVE.l  (a0,d2.w),d3        * get table value
00A01E34                          5957  LAB_29FD
00A01E34  5200                    5958      ADDQ.b  #1,d0               * increment output character
00A01E36  D7AB 0C8E               5959      ADD.l       d3,Itemp(a3)        * add to (now fixed) mantissa
00A01E3A  0800 0007               5960      BTST        #7,d0               * set test sense (z flag only)
00A01E3E  6504                    5961      BCS.s       LAB_2A18            * did carry so has wrapped past zero
00A01E40                          5962  
00A01E40  67F2                    5963      BEQ.s       LAB_29FD            * no wrap and +ve test so try again
00A01E42                          5964  
00A01E42  6002                    5965      BRA.s       LAB_2A1A            * found this digit
00A01E44                          5966  
00A01E44                          5967  LAB_2A18
00A01E44  66EE                    5968      BNE.s       LAB_29FD            * wrap and -ve test so try again
00A01E46                          5969  
00A01E46                          5970  LAB_2A1A
00A01E46  6406                    5971      BCC.s       LAB_2A21            * branch if +ve test result
00A01E48                          5972  
00A01E48  4400                    5973      NEG.b       d0              * negate the digit number
00A01E4A  0600 000B               5974      ADD.b       #$0B,d0         * and subtract from 11 decimal
00A01E4E                          5975  LAB_2A21
00A01E4E  0600 002F               5976      ADD.b       #$2F,d0         * add "0"-1 to result
00A01E52  5842                    5977      ADDQ.w  #4,d2               * increment index to next less power of ten
00A01E54  5241                    5978      ADDQ.w  #1,d1               * increment output string index
00A01E56  1600                    5979      MOVE.b  d0,d3               * copy character to d3
00A01E58  C63C 007F               5980      AND.b       #$7F,d3         * mask out top bit
00A01E5C  1383 1000               5981      MOVE.b  d3,(a1,d1.w)        * save to output string
00A01E60  532B 0E10               5982      SUB.b       #1,numexp(a3)       * decrement # of characters before the dp
00A01E64  6608                    5983      BNE.s       LAB_2A3B            * branch if still characters to do
00A01E66                          5984  
00A01E66                          5985                              * else output the point
00A01E66  5281                    5986      ADDQ.l  #1,d1               * increment index
00A01E68  13BC 002E 1000          5987      MOVE.b  #'.',(a1,d1.w)      * save to output string
00A01E6E                          5988  LAB_2A3B
00A01E6E  C03C 0080               5989      AND.b       #$80,d0         * mask test sense bit
00A01E72  0A00 0080               5990      EORI.b  #$80,d0         * invert it
00A01E76  B43C 001C               5991      CMP.b       #LAB_2A9B-LAB_2A9A,d2   * compare table index with max+4
00A01E7A  66B0                    5992      BNE.s       LAB_29FB            * loop if not max
00A01E7C                          5993  
00A01E7C                          5994                              * now remove trailing zeroes
00A01E7C                          5995  LAB_2A4B
00A01E7C  1031 1000               5996      MOVE.b  (a1,d1.w),d0        * get character from output string
00A01E80  5381                    5997      SUBQ.l  #1,d1               * decrement output string index
00A01E82  B03C 0030               5998      CMP.b       #'0',d0         * compare with "0"
00A01E86  67F4                    5999      BEQ.s       LAB_2A4B            * loop until non "0" character found
00A01E88                          6000  
00A01E88  B03C 002E               6001      CMP.b       #'.',d0         * compare with "."
00A01E8C  6702                    6002      BEQ.s       LAB_2A58            * branch if was dp
00A01E8E                          6003  
00A01E8E                          6004                              * else restore last character
00A01E8E  5281                    6005      ADDQ.l  #1,d1               * increment output string index
00A01E90                          6006  LAB_2A58
00A01E90  13BC 002B 1002          6007      MOVE.b  #'+',2(a1,d1.w)     * save character "+" to output string
00A01E96  4A2B 0E11               6008      TST.b       expcnt(a3)          * test exponent count
00A01E9A  6738                    6009      BEQ.s       LAB_2A8C            * if zero go set null terminator & exit
00A01E9C                          6010  
00A01E9C                          6011                              * exponent isn't zero so write exponent
00A01E9C  6A0A                    6012      BPL.s       LAB_2A68            * branch if exponent count +ve
00A01E9E                          6013  
00A01E9E  13BC 002D 1002          6014      MOVE.b  #'-',2(a1,d1.w)     * save character "-" to output string
00A01EA4  442B 0E11               6015      NEG.b       expcnt(a3)          * convert -ve to +ve
00A01EA8                          6016  LAB_2A68
00A01EA8  13BC 0045 1001          6017      MOVE.b  #'E',1(a1,d1.w)     * save character "E" to output string
00A01EAE  142B 0E11               6018      MOVE.b  expcnt(a3),d2       * get exponent count
00A01EB2  702F                    6019      MOVEQ       #$2F,d0         * one less than "0" character
00A01EB4                          6020  LAB_2A74
00A01EB4  5200                    6021      ADDQ.b  #1,d0               * increment 10's character
00A01EB6  0402 000A               6022      SUB.b       #$0A,d2         * subtract 10 from exponent count
00A01EBA  64F8                    6023      BCC.s       LAB_2A74            * loop while still >= 0
00A01EBC                          6024  
00A01EBC  0602 003A               6025      ADD.b       #$3A,d2         * add character ":", $30+$0A, result is 10-value
00A01EC0  1380 1003               6026      MOVE.b  d0,3(a1,d1.w)       * save 10's character to output string
00A01EC4  1382 1004               6027      MOVE.b  d2,4(a1,d1.w)       * save 1's character to output string
00A01EC8  13BC 0000 1005          6028      MOVE.b  #0,5(a1,d1.w)       * save null terminator after last character
00A01ECE  600A                    6029      BRA.s       LAB_2A91            * go set string pointer (a0) and exit
00A01ED0                          6030  
00A01ED0                          6031  LAB_2A89
00A01ED0  1380 1000               6032      MOVE.b  d0,(a1,d1.w)        * save last character to output string
00A01ED4                          6033  LAB_2A8C
00A01ED4  13BC 0000 1001          6034      MOVE.b  #0,1(a1,d1.w)       * save null terminator after last character
00A01EDA                          6035  LAB_2A91
00A01EDA  2049                    6036      MOVEA.l a1,a0               * set result string pointer (a0)
00A01EDC  4E75                    6037      RTS
00A01EDE                          6038  
00A01EDE                          6039  
00A01EDE                          6040  *************************************************************************************
00A01EDE                          6041  *
00A01EDE                          6042  * fast compare FAC1 with FAC2
00A01EDE                          6043  * assumes both are +ve and FAC2>0
00A01EDE                          6044  * returns d0=+1 C=0 if FAC1 > FAC2
00A01EDE                          6045  * returns d0= 0 C=0 if FAC1 = FAC2
00A01EDE                          6046  * returns d0=-1 C=1 if FAC1 < FAC2
00A01EDE                          6047  
00A01EDE                          6048  LAB_27F0
00A01EDE  7000                    6049      MOVEQ       #0,d0               * set for FAC1 = FAC2
00A01EE0  122B 0E00               6050      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00A01EE4  B22B 0DF8               6051      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00A01EE8  660A                    6052      BNE.s       LAB_27F1            * branch if different
00A01EEA                          6053  
00A01EEA  222B 0DFC               6054      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00A01EEE  B2AB 0DF4               6055      CMP.l       FAC1_m(a3),d1       * compare mantissas
00A01EF2  6708                    6056      BEQ.s       LAB_27F3            * exit if mantissas equal
00A01EF4                          6057  
00A01EF4                          6058  LAB_27F1
00A01EF4  6504                    6059      BCS.s       LAB_27F2            * if FAC1 > FAC2 return d0=+1,C=0
00A01EF6                          6060  
00A01EF6  5380                    6061      SUBQ.l  #1,d0               * else FAC1 < FAC2 return d0=-1,C=1
00A01EF8  4E75                    6062      RTS
00A01EFA                          6063  
00A01EFA                          6064  LAB_27F2
00A01EFA  5280                    6065      ADDQ.l  #1,d0
00A01EFC                          6066  LAB_27F3
00A01EFC  4E75                    6067      RTS
00A01EFE                          6068  
00A01EFE                          6069  
00A01EFE                          6070  *************************************************************************************
00A01EFE                          6071  *
00A01EFE                          6072  * make FAC1 = 1
00A01EFE                          6073  
00A01EFE                          6074  LAB_POON
00A01EFE  277C 80000000 0DF4      6075      MOVE.l  #$80000000,FAC1_m(a3)   * 1 mantissa
00A01F06  377C 8100 0DF8          6076      MOVE.w  #$8100,FAC1_e(a3)       * 1 exonent & sign
00A01F0C  4E75                    6077      RTS
00A01F0E                          6078  
00A01F0E                          6079  
00A01F0E                          6080  *************************************************************************************
00A01F0E                          6081  *
00A01F0E                          6082  * make FAC1 = 0
00A01F0E                          6083  
00A01F0E                          6084  LAB_POZE
00A01F0E  7000                    6085      MOVEQ       #0,d0               * clear longword
00A01F10  2740 0DF4               6086      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00A01F14  3740 0DF8               6087      MOVE.w  d0,FAC1_e(a3)       * 0 exonent & sign
00A01F18  4E75                    6088      RTS
00A01F1A                          6089  
00A01F1A                          6090  
00A01F1A                          6091  *************************************************************************************
00A01F1A                          6092  *
00A01F1A                          6093  * perform power function
00A01F1A                          6094  * the number is in FAC2, the power is in FAC1
00A01F1A                          6095  * no longer trashes Itemp
00A01F1A                          6096  
00A01F1A                          6097  LAB_POWER
00A01F1A  4A2B 0DF8               6098      TST.b       FAC1_e(a3)          * test power
00A01F1E  67DE                    6099      BEQ.s       LAB_POON            * if zero go return 1
00A01F20                          6100  
00A01F20  4A2B 0E00               6101      TST.b       FAC2_e(a3)          * test number
00A01F24  67E8                    6102      BEQ.s       LAB_POZE            * if zero go return 0
00A01F26                          6103  
00A01F26  1F2B 0E01               6104      MOVE.b  FAC2_s(a3),-(sp)        * save number sign
00A01F2A  6A20                    6105      BPL.s       LAB_POWP            * power of positive number
00A01F2C                          6106  
00A01F2C  7200                    6107      MOVEQ       #0,d1               * clear d1
00A01F2E  1741 0E01               6108      MOVE.b  d1,FAC2_s(a3)       * make sign +ve
00A01F32                          6109  
00A01F32                          6110                              * number sign was -ve and can only be raised to
00A01F32                          6111                              * an integer power which gives an x +j0 result,
00A01F32                          6112                              * else do 'function call' error
00A01F32  122B 0DF8               6113      MOVE.b  FAC1_e(a3),d1       * get power exponent
00A01F36  0441 0080               6114      SUB.w       #$80,d1         * normalise to .5
00A01F3A  6300 E22A               6115      BLS     LAB_FCER            * if 0<power<1 then do 'function call' error
00A01F3E                          6116  
00A01F3E                          6117                              * now shift all the integer bits out
00A01F3E  202B 0DF4               6118      MOVE.l  FAC1_m(a3),d0       * get power mantissa
00A01F42  E3A0                    6119      ASL.l       d1,d0               * shift mantissa
00A01F44  6600 E220               6120      BNE     LAB_FCER            * if power<>INT(power) then do 'function call'
00A01F48                          6121                              * error
00A01F48                          6122  
00A01F48  6502                    6123      BCS.s       LAB_POWP            * if integer value odd then leave result -ve
00A01F4A                          6124  
00A01F4A  1E80                    6125      MOVE.b  d0,(sp)         * save result sign +ve
00A01F4C                          6126  LAB_POWP
00A01F4C  2F2B 0DF4               6127      MOVE.l  FAC1_m(a3),-(sp)        * save power mantissa
00A01F50  3F2B 0DF8               6128      MOVE.w  FAC1_e(a3),-(sp)        * save power sign & exponent
00A01F54                          6129  
00A01F54  6100 FC78               6130      BSR     LAB_279B            * copy number to FAC1
00A01F58  6100 F9E8               6131      BSR     LAB_LOG         * find log of number
00A01F5C                          6132  
00A01F5C  301F                    6133      MOVE.w  (sp)+,d0            * get power sign & exponent
00A01F5E  275F 0DFC               6134      MOVE.l  (sp)+,FAC2_m(a3)        * get power mantissa
00A01F62  3740 0E00               6135      MOVE.w  d0,FAC2_e(a3)       * save sign & exponent to FAC2
00A01F66  1740 0E02               6136      MOVE.b  d0,FAC_sc(a3)       * save sign as sign compare
00A01F6A  102B 0DF9               6137      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00A01F6E  B12B 0E02               6138      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00A01F72                          6139  
00A01F72  6100 FAC0               6140      BSR     LAB_MULTIPLY        * multiply by power
00A01F76  6158                    6141      BSR.s       LAB_EXP         * find exponential
00A01F78  175F 0DF9               6142      MOVE.b  (sp)+,FAC1_s(a3)        * restore number sign
00A01F7C  4E75                    6143      RTS
00A01F7E                          6144  
00A01F7E                          6145  
00A01F7E                          6146  *************************************************************************************
00A01F7E                          6147  *
00A01F7E                          6148  * do - FAC1
00A01F7E                          6149  
00A01F7E                          6150  LAB_GTHAN
00A01F7E  4A2B 0DF8               6151      TST.b       FAC1_e(a3)          * test for non zero FAC1
00A01F82  6706                    6152      BEQ.s       RTS_020         * branch if null
00A01F84                          6153  
00A01F84  0A2B 0080 0DF9          6154      EORI.b  #$80,FAC1_s(a3)     * (else) toggle FAC1 sign bit
00A01F8A                          6155  RTS_020
00A01F8A  4E75                    6156      RTS
00A01F8C                          6157  
00A01F8C                          6158  
00A01F8C                          6159  *************************************************************************************
00A01F8C                          6160  *
00A01F8C                          6161                              * return +1
00A01F8C                          6162  LAB_EX1
00A01F8C  277C 80000000 0DF4      6163      MOVE.l  #$80000000,FAC1_m(a3)   * +1 mantissa
00A01F94  377C 8100 0DF8          6164      MOVE.w  #$8100,FAC1_e(a3)       * +1 sign & exponent
00A01F9A  4E75                    6165      RTS
00A01F9C                          6166                              * do over/under flow
00A01F9C                          6167  LAB_EXOU
00A01F9C  4A2B 0DF9               6168      TST.b       FAC1_s(a3)          * test sign
00A01FA0  6A00 E1C0               6169      BPL     LAB_OFER            * was +ve so do overflow error
00A01FA4                          6170  
00A01FA4                          6171                              * else underflow so return zero
00A01FA4  7000                    6172      MOVEQ       #0,d0               * clear longword
00A01FA6  2740 0DF4               6173      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00A01FAA  3740 0DF8               6174      MOVE.w  d0,FAC1_e(a3)       * 0 sign & exponent
00A01FAE  4E75                    6175      RTS
00A01FB0                          6176                              * fraction was zero so do 2^n
00A01FB0                          6177  LAB_EXOF
00A01FB0  277C 80000000 0DF4      6178      MOVE.l  #$80000000,FAC1_m(a3)   * +n mantissa
00A01FB8  177C 0000 0DF9          6179      MOVE.b  #0,FAC1_s(a3)       * clear sign
00A01FBE  4A2B 0E18               6180      TST.b       cosout(a3)          * test sign flag
00A01FC2  6A02                    6181      BPL.s       LAB_EXOL            * branch if +ve
00A01FC4                          6182  
00A01FC4  4481                    6183      NEG.l       d1              * else do 1/2^n
00A01FC6                          6184  LAB_EXOL
00A01FC6  0601 0081               6185      ADD.b       #$81,d1         * adjust exponent
00A01FCA  1741 0DF8               6186      MOVE.b  d1,FAC1_e(a3)       * save exponent
00A01FCE  4E75                    6187      RTS
00A01FD0                          6188  
00A01FD0                          6189  * perform EXP() (x^e)
00A01FD0                          6190  * valid input range is -88 to +88
00A01FD0                          6191  
00A01FD0                          6192  LAB_EXP
00A01FD0  102B 0DF8               6193      MOVE.b  FAC1_e(a3),d0       * get exponent
00A01FD4  67B6                    6194      BEQ.s       LAB_EX1         * return 1 for zero in
00A01FD6                          6195  
00A01FD6  B03C 0064               6196      CMP.b       #$64,d0         * compare exponent with min
00A01FDA  65B0                    6197      BCS.s       LAB_EX1         * if smaller just return 1
00A01FDC                          6198  
00A01FDC                          6199  **  MOVEM.l d1-d6/a0,-(sp)      * save the registers
00A01FDC  177C 0000 0E18          6200      MOVE.b  #0,cosout(a3)       * flag +ve number
00A01FE2  222B 0DF4               6201      MOVE.l  FAC1_m(a3),d1       * get mantissa
00A01FE6  B03C 0087               6202      CMP.b       #$87,d0         * compare exponent with max
00A01FEA  62B0                    6203      BHI.s       LAB_EXOU            * go do over/under flow if greater
00A01FEC                          6204  
00A01FEC  6608                    6205      BNE.s       LAB_EXCM            * branch if less
00A01FEE                          6206  
00A01FEE                          6207                              * else is 2^7
00A01FEE  B2BC B00F33C7           6208      CMP.l       #$B00F33C7,d1       * compare mantissa with n*2^7 max
00A01FF4  64A6                    6209      BCC.s       LAB_EXOU            * if => go over/underflow
00A01FF6                          6210  
00A01FF6                          6211  LAB_EXCM
00A01FF6  4A2B 0DF9               6212      TST.b       FAC1_s(a3)          * test sign
00A01FFA  6A0C                    6213      BPL.s       LAB_EXPS            * branch if arg +ve
00A01FFC                          6214  
00A01FFC  177C 00FF 0E18          6215      MOVE.b  #$FF,cosout(a3)     * flag -ve number
00A02002  177C 0000 0DF9          6216      MOVE.b  #0,FAC1_s(a3)       * take absolute value
00A02008                          6217  LAB_EXPS
00A02008                          6218                              * now do n/LOG(2)
00A02008  277C B8AA3B29 0DFC      6219      MOVE.l  #$B8AA3B29,FAC2_m(a3)   * 1/LOG(2) mantissa
00A02010  377C 8100 0E00          6220      MOVE.w  #$8100,FAC2_e(a3)       * 1/LOG(2) exponent & sign
00A02016  177C 0000 0E02          6221      MOVE.b  #0,FAC_sc(a3)       * we know they're both +ve
00A0201C  6100 FA16               6222      BSR     LAB_MULTIPLY        * effectively divide by log(2)
00A02020                          6223  
00A02020                          6224                              * max here is +/- 127
00A02020                          6225                              * now separate integer and fraction
00A02020  177C 0000 0E3D          6226      MOVE.b  #0,tpower(a3)       * clear exponent add byte
00A02026  1A2B 0DF8               6227      MOVE.b  FAC1_e(a3),d5       * get exponent
00A0202A  0405 0080               6228      SUB.b       #$80,d5         * normalise
00A0202E  6324                    6229      BLS.s       LAB_ESML            * branch if < 1 (d5 is 0 or -ve)
00A02030                          6230  
00A02030                          6231                              * result is > 1
00A02030  202B 0DF4               6232      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A02034  2200                    6233      MOVE.l  d0,d1               * copy it
00A02036  2C05                    6234      MOVE.l  d5,d6               * copy normalised exponent
00A02038                          6235  
00A02038  4446                    6236      NEG.w       d6              * make -ve
00A0203A  0646 0020               6237      ADD.w       #32,d6          * is now 32-d6
00A0203E  ECA9                    6238      LSR.l       d6,d1               * just integer bits
00A02040  1741 0E3D               6239      MOVE.b  d1,tpower(a3)       * set exponent add byte
00A02044                          6240  
00A02044  EBA8                    6241      LSL.l       d5,d0               * shift out integer bits
00A02046  6700 FF68               6242      BEQ     LAB_EXOF            * fraction is zero so do 2^n
00A0204A                          6243  
00A0204A  2740 0DF4               6244      MOVE.l  d0,FAC1_m(a3)       * fraction to FAC1
00A0204E  377C 8000 0DF8          6245      MOVE.w  #$8000,FAC1_e(a3)       * set exponent & sign
00A02054                          6246  
00A02054                          6247                              * multiple was < 1
00A02054                          6248  LAB_ESML
00A02054  277C B17217F8 0DFC      6249      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00A0205C  377C 8000 0E00          6250      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00A02062  177C 0000 0E02          6251      MOVE.b  #0,FAC_sc(a3)       * clear sign compare
00A02068  6100 F9CA               6252      BSR     LAB_MULTIPLY        * multiply by log(2)
00A0206C                          6253  
00A0206C  202B 0DF4               6254      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A02070  1A2B 0DF8               6255      MOVE.b  FAC1_e(a3),d5       * get exponent
00A02074  0445 0082               6256      SUB.w       #$82,d5         * normalise and -2 (result is -1 to -30)
00A02078  4445                    6257      NEG.w       d5              * make +ve
00A0207A  EAA8                    6258      LSR.l       d5,d0               * shift for 2 integer bits
00A0207C                          6259  
00A0207C                          6260  * d0 = arg
00A0207C                          6261  * d6 = x, d1 = y
00A0207C                          6262  * d2 = x1, d3 = y1
00A0207C                          6263  * d4 = shift count
00A0207C                          6264  * d5 = loop count
00A0207C                          6265                              * now do cordic set-up
00A0207C  7200                    6266      MOVEQ       #0,d1               * y = 0
00A0207E  2C3C 26A3D110           6267      MOVE.l  #KFCTSEED,d6        * x = 1 with jkh inverse factored out
00A02084  41FA 0D2A               6268      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic arctan table
00A02088  7800                    6269      MOVEQ       #0,d4               * clear shift count
00A0208A                          6270   
00A0208A                          6271                              * cordic loop, shifts 4 and 13 (and 39
00A0208A                          6272                              * if it went that far) need to be repeated
00A0208A  7A03                    6273      MOVEQ       #3,d5               * 4 loops
00A0208C  6136                    6274      BSR.s       LAB_EXCC            * do loops 1 through 4
00A0208E  5948                    6275      SUBQ.w  #4,a0               * do table entry again
00A02090  5384                    6276      SUBQ.l  #1,d4               * do shift count again
00A02092  7A09                    6277      MOVEQ       #9,d5               * 10 loops
00A02094  612E                    6278      BSR.s       LAB_EXCC            * do loops 4 (again) through 13
00A02096  5948                    6279      SUBQ.w  #4,a0               * do table entry again
00A02098  5384                    6280      SUBQ.l  #1,d4               * do shift count again
00A0209A  7A12                    6281      MOVEQ       #18,d5          * 19 loops
00A0209C  6126                    6282      BSR.s       LAB_EXCC            * do loops 13 (again) through 31
00A0209E                          6283   
00A0209E                          6284                              * now get the result
00A0209E  4A2B 0E18               6285      TST.b       cosout(a3)          * test sign flag
00A020A2  6A06                    6286      BPL.s       LAB_EXPL            * branch if +ve
00A020A4                          6287  
00A020A4  4481                    6288      NEG.l       d1              * do -y
00A020A6  442B 0E3D               6289      NEG.b       tpower(a3)          * do -exp
00A020AA                          6290  LAB_EXPL
00A020AA  7083                    6291      MOVEQ       #$83-$100,d0        * set exponent
00A020AC  DC81                    6292      ADD.l       d1,d6               * y = y +/- x
00A020AE  6B06                    6293      BMI.s       LAB_EXRN            * branch if result normal
00A020B0                          6294  
00A020B0                          6295  LAB_EXNN
00A020B0  5380                    6296      SUBQ.l  #1,d0               * decrement exponent
00A020B2  DC86                    6297      ADD.l       d6,d6               * shift mantissa
00A020B4  6AFA                    6298      BPL.s       LAB_EXNN            * loop if not normal
00A020B6                          6299  
00A020B6                          6300  LAB_EXRN
00A020B6  2746 0DF4               6301      MOVE.l  d6,FAC1_m(a3)       * save exponent result
00A020BA  D02B 0E3D               6302      ADD.b       tpower(a3),d0       * add integer part
00A020BE  1740 0DF8               6303      MOVE.b  d0,FAC1_e(a3)       * save exponent
00A020C2                          6304  **  MOVEM.l (sp)+,d1-d6/a0      * restore registers
00A020C2  4E75                    6305      RTS
00A020C4                          6306   
00A020C4                          6307                              * cordic loop
00A020C4                          6308  LAB_EXCC
00A020C4  5284                    6309      ADDQ.l  #1,d4               * increment shift count
00A020C6  2406                    6310      MOVE.l  d6,d2               * x1 = x
00A020C8  E8A2                    6311      ASR.l       d4,d2               * x1 >> n
00A020CA  2601                    6312      MOVE.l  d1,d3               * y1 = y
00A020CC  E8A3                    6313      ASR.l       d4,d3               * y1 >> n
00A020CE  4A80                    6314      TST.l       d0              * test arg
00A020D0  6B0C                    6315      BMI.s       LAB_EXAD            * branch if -ve
00A020D2                          6316  
00A020D2  D282                    6317      ADD.l       d2,d1               * y = y + x1
00A020D4  DC83                    6318      ADD.l       d3,d6               * x = x + y1
00A020D6  9098                    6319      SUB.l       (a0)+,d0            * arg = arg - atnh(a0)
00A020D8  51CD FFEA               6320      DBF     d5,LAB_EXCC         * decrement and loop if not done
00A020DC                          6321  
00A020DC  4E75                    6322      RTS
00A020DE                          6323  
00A020DE                          6324  LAB_EXAD
00A020DE  9282                    6325      SUB.l       d2,d1               * y = y - x1
00A020E0  9C83                    6326      SUB.l       d3,d6               * x = x + y1
00A020E2  D098                    6327      ADD.l       (a0)+,d0            * arg = arg + atnh(a0)
00A020E4  51CD FFDE               6328      DBF     d5,LAB_EXCC         * decrement and loop if not done
00A020E8                          6329  
00A020E8  4E75                    6330      RTS
00A020EA                          6331  
00A020EA                          6332  
00A020EA                          6333  *************************************************************************************
00A020EA                          6334  *
00A020EA                          6335  * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
00A020EA                          6336  * to get 19th next number in sequence after seed n. This version of the PRNG uses
00A020EA                          6337  * the Galois method and a sample of 65536 bytes produced gives the following values.
00A020EA                          6338  
00A020EA                          6339  * Entropy = 7.997442 bits per byte
00A020EA                          6340  * Optimum compression would reduce these 65536 bytes by 0 percent
00A020EA                          6341  
00A020EA                          6342  * Chi square distribution for 65536 samples is 232.01, and
00A020EA                          6343  * randomly would exceed this value 75.00 percent of the time
00A020EA                          6344  
00A020EA                          6345  * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00A020EA                          6346  * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00A020EA                          6347  * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00A020EA                          6348  
00A020EA                          6349  LAB_RND
00A020EA  4A2B 0DF8               6350      TST.b       FAC1_e(a3)          * get FAC1 exponent
00A020EE  6708                    6351      BEQ.s       NextPRN         * do next random number if zero
00A020F0                          6352  
00A020F0                          6353                              * else get seed into random number store
00A020F0  41EB 0E04               6354      LEA     PRNlword(a3),a0     * set PRNG pointer
00A020F4  6100 FAB2               6355      BSR     LAB_2778            * pack FAC1 into (a0)
00A020F8                          6356  NextPRN
00A020F8  72AF                    6357      MOVEQ       #$AF-$100,d1        * set EOR value
00A020FA  7412                    6358      MOVEQ       #18,d2          * do this 19 times
00A020FC  202B 0E04               6359      MOVE.l  PRNlword(a3),d0     * get current
00A02100                          6360  Ninc0
00A02100  D080                    6361      ADD.l       d0,d0               * shift left 1 bit
00A02102  6402                    6362      BCC.s       Ninc1               * branch if bit 32 not set
00A02104                          6363  
00A02104  B300                    6364      EOR.b       d1,d0               * do Galois LFSR feedback
00A02106                          6365  Ninc1
00A02106  51CA FFF8               6366      DBF     d2,Ninc0            * loop
00A0210A                          6367  
00A0210A  2740 0E04               6368      MOVE.l  d0,PRNlword(a3)     * save back to seed word
00A0210E  2740 0DF4               6369      MOVE.l  d0,FAC1_m(a3)       * copy to FAC1 mantissa
00A02112  377C 8000 0DF8          6370      MOVE.w  #$8000,FAC1_e(a3)       * set the exponent and clear the sign
00A02118  6000 F7F2               6371      BRA     LAB_24D5            * normalise FAC1 & return
00A0211C                          6372  
00A0211C                          6373  
00A0211C                          6374  *************************************************************************************
00A0211C                          6375  *
00A0211C                          6376  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
00A0211C                          6377  * x = angle in radians
00A0211C                          6378  
00A0211C                          6379  LAB_TAN
00A0211C  6138                    6380      BSR.s       LAB_SIN         * go do SIN/COS cordic compute
00A0211E  376B 0DF8 0E00          6381      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00A02124  276B 0DF4 0DFC          6382      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00A0212A  2741 0DF4               6383      MOVE.l  d1,FAC1_m(a3)       * get COS(x) mantissa
00A0212E  1743 0DF8               6384      MOVE.b  d3,FAC1_e(a3)       * get COS(x) exponent
00A02132  6700 E02E               6385      BEQ     LAB_OFER            * do overflow if COS = 0
00A02136                          6386  
00A02136  6100 F7D4               6387      BSR     LAB_24D5            * normalise FAC1
00A0213A  6000 F984               6388      BRA     LAB_DIVIDE          * do FAC2/FAC1 and return, FAC_sc set by SIN
00A0213E                          6389                              * COS calculation
00A0213E                          6390  
00A0213E                          6391  
00A0213E                          6392  *************************************************************************************
00A0213E                          6393  *
00A0213E                          6394  * cordic SIN(x), COS(x) routine
00A0213E                          6395  * x = angle in radians
00A0213E                          6396  
00A0213E                          6397  LAB_COS
00A0213E  277C C90FDAA3 0DFC      6398      MOVE.l  #$C90FDAA3,FAC2_m(a3)   * pi/2 mantissa (LSB is rounded up so
00A02146                          6399                              * COS(PI/2)=0)
00A02146  377C 8100 0E00          6400      MOVE.w  #$8100,FAC2_e(a3)       * pi/2 exponent and sign
00A0214C  176B 0DF9 0E02          6401      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00A02152  6100 F73C               6402      BSR     LAB_ADD         * add FAC2 to FAC1, adjust for COS(x)
00A02156                          6403  
00A02156                          6404  
00A02156                          6405  *************************************************************************************
00A02156                          6406  *
00A02156                          6407  * SIN/COS cordic calculator
00A02156                          6408  
00A02156                          6409  LAB_SIN
00A02156  177C 0000 0E18          6410      MOVE.b  #0,cosout(a3)       * set needed result
00A0215C                          6411  
00A0215C  277C A2F9836F 0DFC      6412      MOVE.l  #$A2F9836F,FAC2_m(a3)   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
00A02164  377C 7F00 0E00          6413      MOVE.w  #$7F00,FAC2_e(a3)       * 1/pi exponent & sign
00A0216A  176B 0DF9 0E02          6414      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00A02170  6100 F8C2               6415      BSR     LAB_MULTIPLY        * multiply by 1/pi
00A02174                          6416  
00A02174  102B 0DF8               6417      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A02178  671C                    6418      BEQ.s       LAB_SCZE            * branch if zero
00A0217A                          6419  
00A0217A  41FA 0B34               6420      LEA     TAB_SNCO(pc),a0     * get pointer to constants table
00A0217E  2C2B 0DF4               6421      MOVE.l  FAC1_m(a3),d6       * get FAC1 mantissa
00A02182  5300                    6422      SUBQ.b  #1,d0               * 2 radians in 360 degrees so /2
00A02184  6710                    6423      BEQ.s       LAB_SCZE            * branch if zero
00A02186                          6424  
00A02186  0400 0080               6425      SUB.b       #$80,d0         * normalise exponent
00A0218A  6B18                    6426      BMI.s       LAB_SCL0            * branch if < 1
00A0218C                          6427  
00A0218C                          6428                              * X is > 1
00A0218C  B03C 0020               6429      CMP.b       #$20,d0         * is it >= 2^32
00A02190  6404                    6430      BCC.s       LAB_SCZE            * may as well do zero
00A02192                          6431  
00A02192  E1AE                    6432      LSL.l       d0,d6               * shift out integer part bits
00A02194  6618                    6433      BNE.s       LAB_CORD            * if fraction go test quadrant and adjust
00A02196                          6434  
00A02196                          6435                              * else no fraction so do zero
00A02196                          6436  LAB_SCZE
00A02196  7481                    6437      MOVEQ       #$81-$100,d2        * set exponent for 1.0
00A02198  7600                    6438      MOVEQ       #0,d3               * set exponent for 0.0
00A0219A  203C 80000000           6439      MOVE.l  #$80000000,d0       * mantissa for 1.0
00A021A0  2203                    6440      MOVE.l  d3,d1               * mantissa for 0.0
00A021A2  6062                    6441      BRA.s       outloop         * go output it
00A021A4                          6442  
00A021A4                          6443                              * x is < 1
00A021A4                          6444  LAB_SCL0
00A021A4  4400                    6445      NEG.b       d0              * make +ve
00A021A6  B03C 001E               6446      CMP.b       #$1E,d0         * is it <= 2^-30
00A021AA  64EA                    6447      BCC.s       LAB_SCZE            * may as well do zero
00A021AC                          6448  
00A021AC  E0AE                    6449      LSR.l       d0,d6               * shift out <= 2^-32 bits
00A021AE                          6450  
00A021AE                          6451  * cordic calculator, argument in d6
00A021AE                          6452  * table pointer in a0, returns in d0-d3
00A021AE                          6453  
00A021AE                          6454  LAB_CORD
00A021AE  176B 0DF9 0E02          6455      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * copy as sign compare for TAN
00A021B4  DC86                    6456      ADD.l       d6,d6               * shift 0.5 bit into carry
00A021B6  6406                    6457      BCC.s       LAB_LTPF            * branch if less than 0.5
00A021B8                          6458  
00A021B8  0A2B 00FF 0DF9          6459      EORI.b  #$FF,FAC1_s(a3)     * toggle result sign
00A021BE                          6460  LAB_LTPF
00A021BE  DC86                    6461      ADD.l       d6,d6               * shift 0.25 bit into carry
00A021C0  640C                    6462      BCC.s       LAB_LTPT            * branch if less than 0.25
00A021C2                          6463  
00A021C2  0A2B 00FF 0E18          6464      EORI.b  #$FF,cosout(a3)     * toggle needed result
00A021C8  0A2B 00FF 0E02          6465      EORI.b  #$FF,FAC_sc(a3)     * toggle sign compare for TAN
00A021CE                          6466  
00A021CE                          6467  LAB_LTPT
00A021CE  E48E                    6468      LSR.l       #2,d6               * shift the bits back (clear integer bits)
00A021D0  67C4                    6469      BEQ.s       LAB_SCZE            * no fraction so go do zero
00A021D2                          6470  
00A021D2                          6471                              * set start values
00A021D2  7A01                    6472      MOVEQ       #1,d5               * set bit count
00A021D4  2028 FFFC               6473      MOVE.l  -4(a0),d0           * get multiply constant (1st itteration d0)
00A021D8  2200                    6474      MOVE.l  d0,d1               * 1st itteration d1
00A021DA  9C98                    6475      SUB.l       (a0)+,d6            * 1st always +ve so do 1st step
00A021DC  6008                    6476      BRA.s       mainloop            * jump into routine
00A021DE                          6477  
00A021DE                          6478  subloop
00A021DE  9C98                    6479      SUB.l       (a0)+,d6            * z = z - arctan(i)/2pi
00A021E0  9083                    6480      SUB.l       d3,d0               * x = x - y1
00A021E2  D282                    6481      ADD.l       d2,d1               * y = y + x1
00A021E4  6012                    6482      BRA.s       nexta               * back to main loop
00A021E6                          6483  
00A021E6                          6484  mainloop
00A021E6  2400                    6485      MOVE.l  d0,d2               * x1 = x
00A021E8  EAA2                    6486      ASR.l       d5,d2               * / (2 ^ i)
00A021EA  2601                    6487      MOVE.l  d1,d3               * y1 = y
00A021EC  EAA3                    6488      ASR.l       d5,d3               * / (2 ^ i)
00A021EE  4A86                    6489      TST.l       d6              * test sign (is 2^0 bit)
00A021F0  6AEC                    6490      BPL.s       subloop         * go do subtract if > 1
00A021F2                          6491  
00A021F2  DC98                    6492      ADD.l       (a0)+,d6            * z = z + arctan(i)/2pi
00A021F4  D083                    6493      ADD.l       d3,d0               * x = x + y1
00A021F6  9282                    6494      SUB.l       d2,d1               * y = y + x1
00A021F8                          6495  nexta
00A021F8  5285                    6496      ADDQ.l  #1,d5               * i = i + 1
00A021FA  BABC 0000001E           6497      CMP.l       #$1E,d5         * check end condition
00A02200  66E4                    6498      BNE.s       mainloop            * loop if not all done
00A02202                          6499  
00A02202                          6500                              * now untangle output value
00A02202  7481                    6501      MOVEQ       #$81-$100,d2        * set exponent for 0 to .99 rec.
00A02204  2602                    6502      MOVE.l  d2,d3               * copy it for cos output
00A02206                          6503  outloop
00A02206  4A2B 0E18               6504      TST.b       cosout(a3)          * did we want cos output?
00A0220A  6B04                    6505      BMI.s       subexit         * if so skip
00A0220C                          6506  
00A0220C  C141                    6507      EXG     d0,d1               * swap SIN and COS mantissas
00A0220E  C543                    6508      EXG     d2,d3               * swap SIN and COS exponents
00A02210                          6509  subexit
00A02210  2740 0DF4               6510      MOVE.l  d0,FAC1_m(a3)       * set result mantissa
00A02214  1742 0DF8               6511      MOVE.b  d2,FAC1_e(a3)       * set result exponent
00A02218  6000 F6F2               6512      BRA     LAB_24D5            * normalise FAC1 & return
00A0221C                          6513  
00A0221C                          6514  
00A0221C                          6515  
00A0221C                          6516  *************************************************************************************
00A0221C                          6517  *
00A0221C                          6518  * perform ATN()
00A0221C                          6519  
00A0221C                          6520  LAB_ATN
00A0221C  102B 0DF8               6521      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00A02220  6700 00AA               6522      BEQ     RTS_021         * ATN(0) = 0 so skip calculation
00A02224                          6523  
00A02224  177C 0000 0E18          6524      MOVE.b  #0,cosout(a3)       * set result needed
00A0222A  B03C 0081               6525      CMP.b       #$81,d0         * compare exponent with 1
00A0222E  6528                    6526      BCS.s       LAB_ATLE            * branch if n<1
00A02230                          6527  
00A02230  6608                    6528      BNE.s       LAB_ATGO            * branch if n>1
00A02232                          6529  
00A02232  202B 0DF4               6530      MOVE.l  FAC1_m(a3),d0       * get mantissa
00A02236  D080                    6531      ADD.l       d0,d0               * shift left
00A02238  671E                    6532      BEQ.s       LAB_ATLE            * branch if n=1
00A0223A                          6533  
00A0223A                          6534  LAB_ATGO
00A0223A  277C 80000000 0DFC      6535      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00A02242  377C 8100 0E00          6536      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00A02248  176B 0DF9 0E02          6537      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00A0224E  6100 F870               6538      BSR     LAB_DIVIDE          * do 1/n
00A02252  177C 00FF 0E18          6539      MOVE.b  #$FF,cosout(a3)     * set inverse result needed
00A02258                          6540  LAB_ATLE
00A02258  202B 0DF4               6541      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00A0225C  7282                    6542      MOVEQ       #$82,d1         * set to correct exponent
00A0225E  922B 0DF8               6543      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent (always <= 1)
00A02262  E2A8                    6544      LSR.l       d1,d0               * shift in two integer part bits
00A02264  41FA 0ACA               6545      LEA     TAB_ATNC(pc),a0     * get pointer to arctan table
00A02268  7C00                    6546      MOVEQ       #0,d6               * Z = 0
00A0226A  223C 40000000           6547      MOVE.l  #1<<30,d1           * y = 1
00A02270  7A1D                    6548      MOVEQ       #29,d5          * loop 30 times
00A02272  7801                    6549      MOVEQ       #1,d4               * shift counter
00A02274  6006                    6550      BRA.s       LAB_ATCD            * enter loop
00A02276                          6551  
00A02276                          6552  LAB_ATNP
00A02276  E8A2                    6553      ASR.l       d4,d2               * x1 / 2^i
00A02278  D282                    6554      ADD.l       d2,d1               * y = y + x1
00A0227A  DC90                    6555      ADD.l       (a0),d6         * z = z + atn(i)
00A0227C                          6556  LAB_ATCD
00A0227C  2400                    6557      MOVE.l  d0,d2               * x1 = x
00A0227E  2601                    6558      MOVE.l  d1,d3               * y1 = y
00A02280  E8A3                    6559      ASR.l       d4,d3               * y1 / 2^i
00A02282                          6560  LAB_CATN
00A02282  9083                    6561      SUB.l       d3,d0               * x = x - y1
00A02284  6AF0                    6562      BPL.s       LAB_ATNP            * branch if x >= 0
00A02286                          6563  
00A02286  2002                    6564      MOVE.l  d2,d0               * else get x back
00A02288  5848                    6565      ADDQ.w  #4,a0               * increment pointer
00A0228A  5284                    6566      ADDQ.l  #1,d4               * increment i
00A0228C  E283                    6567      ASR.l       #1,d3               * y1 / 2^i
00A0228E  51CD FFF2               6568      DBF     d5,LAB_CATN         * decrement and loop if not done
00A02292                          6569  
00A02292  177C 0082 0DF8          6570      MOVE.b  #$82,FAC1_e(a3)     * set new exponent
00A02298  2746 0DF4               6571      MOVE.l  d6,FAC1_m(a3)       * save mantissa
00A0229C  6100 F66E               6572      BSR     LAB_24D5            * normalise FAC1
00A022A0                          6573  
00A022A0  4A2B 0E18               6574      TST.b       cosout(a3)          * was it > 1 ?
00A022A4  6A26                    6575      BPL.s       RTS_021         * branch if not
00A022A6                          6576  
00A022A6  1E2B 0DF9               6577      MOVE.b  FAC1_s(a3),d7       * get sign
00A022AA  177C 0000 0DF9          6578      MOVE.b  #0,FAC1_s(a3)       * clear sign
00A022B0  277C C90FDAA2 0DFC      6579      MOVE.l  #$C90FDAA2,FAC2_m(a3)   * set -(pi/2)
00A022B8  377C 8180 0E00          6580      MOVE.w  #$8180,FAC2_e(a3)       * set exponent and sign
00A022BE  177C 00FF 0E02          6581      MOVE.b  #$FF,FAC_sc(a3)     * set sign compare
00A022C4  6100 F5CA               6582      BSR     LAB_ADD         * perform addition, FAC2 to FAC1
00A022C8  1747 0DF9               6583      MOVE.b  d7,FAC1_s(a3)       * restore sign
00A022CC                          6584  RTS_021
00A022CC  4E75                    6585      RTS
00A022CE                          6586  
00A022CE                          6587  
00A022CE                          6588  *************************************************************************************
00A022CE                          6589  *
00A022CE                          6590  * perform BITSET
00A022CE                          6591  
00A022CE                          6592  LAB_BITSET
00A022CE  6100 F4A0               6593      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00A022D2                          6594                              * first parameter in a0, second in d0
00A022D2  B03C 0008               6595      CMP.b       #$08,d0         * only 0 to 7 are allowed
00A022D6  6400 DE8E               6596      BCC     LAB_FCER            * branch if > 7
00A022DA                          6597  
00A022DA  01D0                    6598      BSET        d0,(a0)         * set bit
00A022DC  4E75                    6599      RTS
00A022DE                          6600  
00A022DE                          6601  
00A022DE                          6602  *************************************************************************************
00A022DE                          6603  *
00A022DE                          6604  * perform BITCLR
00A022DE                          6605  
00A022DE                          6606  LAB_BITCLR
00A022DE  6100 F490               6607      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00A022E2                          6608                              * first parameter in a0, second in d0
00A022E2  B03C 0008               6609      CMP.b       #$08,d0         * only 0 to 7 are allowed
00A022E6  6400 DE7E               6610      BCC     LAB_FCER            * branch if > 7
00A022EA                          6611  
00A022EA  0190                    6612      BCLR        d0,(a0)         * clear bit
00A022EC  4E75                    6613      RTS
00A022EE                          6614  
00A022EE                          6615  
00A022EE                          6616  *************************************************************************************
00A022EE                          6617  *
00A022EE                          6618  * perform BITTST()
00A022EE                          6619  
00A022EE                          6620  LAB_BTST
00A022EE  101D                    6621      MOVE.b  (a5)+,d0            * increment BASIC pointer
00A022F0  6100 F47E               6622      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00A022F4                          6623                              * first parameter in a0, second in d0
00A022F4  B03C 0008               6624      CMP.b       #$08,d0         * only 0 to 7 are allowed
00A022F8  6400 DE6C               6625      BCC     LAB_FCER            * branch if > 7
00A022FC                          6626  
00A022FC  2200                    6627      MOVE.l  d0,d1               * copy bit # to test
00A022FE  6100 EAB2               6628      BSR     LAB_GBYT            * get next BASIC byte
00A02302  B03C 0029               6629      CMP.b       #')',d0         * is next character ")"
00A02306  6600 DE6A               6630      BNE     LAB_SNER            * if not ")" go do syntax error, then warm start
00A0230A                          6631  
00A0230A  6100 EAA4               6632      BSR     LAB_IGBY            * update execute pointer (to character past ")")
00A0230E  7000                    6633      MOVEQ       #0,d0               * set the result as zero
00A02310  0310                    6634      BTST        d1,(a0)         * test bit
00A02312  6700 F90E               6635      BEQ     LAB_27DB            * branch if zero (already correct)
00A02316                          6636  
00A02316  70FF                    6637      MOVEQ       #-1,d0          * set for -1 result
00A02318  6000 F908               6638      BRA     LAB_27DB            * go do SGN tail
00A0231C                          6639  
00A0231C                          6640  
00A0231C                          6641  *************************************************************************************
00A0231C                          6642  *
00A0231C                          6643  * perform USING$()
00A0231C                          6644  
00A0231C  =00000000               6645  fsd EQU  0                  *   (sp) format string descriptor pointer
00A0231C  =00000004               6646  fsti    EQU  4                  *  4(sp) format string this index
00A0231C  =00000006               6647  fsli    EQU  6                  *  6(sp) format string last index
00A0231C  =00000008               6648  fsdpi   EQU  8                  *  8(sp) format string decimal point index
00A0231C  =0000000A               6649  fsdc    EQU 10                  * 10(sp) format string decimal characters
00A0231C  =00000008               6650  fend    EQU 12-4                    *  x(sp) end-4, fsd is popped by itself
00A0231C                          6651  
00A0231C  =00000023               6652  ofchr   EQU '#'                 * the overflow character
00A0231C                          6653  
00A0231C                          6654  LAB_USINGS
00A0231C  4A2B 0E19               6655      TST.b       Dtypef(a3)          * test data type, $80=string
00A02320  6A00 DDFC               6656      BPL     LAB_FOER            * if not string type go do format error
00A02324                          6657  
00A02324  246B 0DF4               6658      MOVEA.l FAC1_m(a3),a2       * get the format string descriptor pointer
00A02328  3E2A 0004               6659      MOVE.w  4(a2),d7            * get the format string length
00A0232C  6700 DDF0               6660      BEQ     LAB_FOER            * if null string go do format error
00A02330                          6661  
00A02330                          6662  * clear the format string values
00A02330                          6663  
00A02330  7000                    6664      MOVEQ       #0,d0               * clear d0
00A02332  3F00                    6665      MOVE.w  d0,-(sp)            * clear the format string decimal characters
00A02334  3F00                    6666      MOVE.w  d0,-(sp)            * clear the format string decimal point index
00A02336  3F00                    6667      MOVE.w  d0,-(sp)            * clear the format string last index
00A02338  3F00                    6668      MOVE.w  d0,-(sp)            * clear the format string this index
00A0233A  2F0A                    6669      MOVE.l  a2,-(sp)            * save the format string descriptor pointer
00A0233C                          6670  
00A0233C                          6671  * make a null return string for the first string add
00A0233C                          6672  
00A0233C  7200                    6673      MOVEQ       #0,d1               * make a null string
00A0233E  2041                    6674      MOVEA.l d1,a0               * with a null pointer
00A02340  6100 F0CA               6675      BSR     LAB_RTST            * push a string on the descriptor stack
00A02344                          6676                              * a0 = pointer, d1 = length
00A02344                          6677  
00A02344                          6678  * do the USING$() function next value
00A02344                          6679  
00A02344  101D                    6680      MOVE.b  (a5)+,d0            * get the next BASIC byte
00A02346                          6681  LAB_U002
00A02346  B03C 002C               6682      CMP.b       #',',d0         * compare with comma
00A0234A  6600 DE26               6683      BNE     LAB_SNER            * if not "," go do syntax error
00A0234E                          6684  
00A0234E  6100 028E               6685      BSR     LAB_ProcFo          * process the format string
00A02352  4A02                    6686      TST.b       d2              * test the special characters flag
00A02354  6700 DDC8               6687      BEQ     LAB_FOER            * if no special characters go do format error
00A02358                          6688  
00A02358  6100 E8F6               6689      BSR     LAB_EVEX            * evaluate the expression
00A0235C  4A2B 0E19               6690      TST.b       Dtypef(a3)          * test the data type
00A02360  6B00 DDE4               6691      BMI     LAB_TMER            * if string type go do type missmatch error
00A02364                          6692  
00A02364  4A2B 0DF8               6693      TST.b       FAC1_e(a3)          * test FAC1 exponent
00A02368  6732                    6694      BEQ.s       LAB_U004            * if FAC1 = 0 skip the rounding
00A0236A                          6695  
00A0236A  322F 000A               6696      MOVE.w  fsdc(sp),d1         * get the format string decimal character count
00A0236E  B27C 0008               6697      CMP.w       #8,d1               * compare the fraction digit count with 8
00A02372  6428                    6698      BCC.s       LAB_U004            * if >= 8 skip the rounding
00A02374                          6699  
00A02374  3001                    6700      MOVE.w  d1,d0               * else copy the fraction digit count
00A02376  D241                    6701      ADD.w       d1,d1               * * 2
00A02378  D240                    6702      ADD.w       d0,d1               * * 3
00A0237A  D241                    6703      ADD.w       d1,d1               * * 6
00A0237C  41FA 0844               6704      LEA     LAB_P_10(pc),a0     * get the rounding table base
00A02380  2770 1002 0DFC          6705      MOVE.l  2(a0,d1.w),FAC2_m(a3)   * get the rounding mantissa
00A02386  3030 1000               6706      MOVE.w  (a0,d1.w),d0        * get the rounding exponent
00A0238A  0440 0100               6707      SUB.w       #$100,d0            * effectively divide the mantissa by 2
00A0238E  3740 0E00               6708      MOVE.w  d0,FAC2_e(a3)       * save the rounding exponent
00A02392  177C 0000 0E02          6709      MOVE.b  #$00,FAC_sc(a3)     * clear the sign compare
00A02398  6100 F4F6               6710      BSR     LAB_ADD         * round the value to n places
00A0239C                          6711  LAB_U004
00A0239C  6100 F970               6712      BSR     LAB_2970            * convert FAC1 to string - not on stack
00A023A0                          6713  
00A023A0  6100 01FE               6714      BSR     LAB_DupFmt          * duplicate the processed format string section
00A023A4                          6715                              * returns length in d1, pointer in a0
00A023A4                          6716  
00A023A4                          6717  * process the number string, length in d6, decimal point index in d2
00A023A4                          6718  
00A023A4  45EB 0E2A               6719      LEA     Decss(a3),a2        * set the number string start
00A023A8  7C00                    6720      MOVEQ       #0,d6               * clear the number string index
00A023AA  782E                    6721      MOVEQ       #'.',d4         * set the decimal point character
00A023AC                          6722  LAB_U005
00A023AC  3406                    6723      MOVE.w  d6,d2               * save the index to flag the decimal point
00A023AE                          6724  LAB_U006
00A023AE  5246                    6725      ADDQ.w  #1,d6               * increment the number string index
00A023B0  1032 6000               6726      MOVE.b  (a2,d6.w),d0        * get a number string character
00A023B4  677A                    6727      BEQ.s       LAB_U010            * if null then number complete
00A023B6                          6728  
00A023B6  B03C 0045               6729      CMP.b       #'E',d0         * compare the character with an "E"
00A023BA  6706                    6730      BEQ.s       LAB_U008            * was sx[.x]Esxx so go handle sci notation
00A023BC                          6731  
00A023BC  B004                    6732      CMP.b       d4,d0               * compare the character with "."
00A023BE  66EE                    6733      BNE.s       LAB_U006            * if not decimal point go get the next digit
00A023C0                          6734  
00A023C0  60EA                    6735      BRA.s       LAB_U005            * go save the index and get the next digit
00A023C2                          6736  
00A023C2                          6737  * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
00A023C2                          6738  
00A023C2                          6739  LAB_U008
00A023C2  3606                    6740      MOVE.w  d6,d3               * copy the index to the "E"
00A023C4  5343                    6741      SUBQ.w  #1,d3               * -1 gives the last digit index
00A023C6                          6742  
00A023C6  5246                    6743      ADDQ.w  #1,d6               * increment the index to the exponent sign
00A023C8  1032 6000               6744      MOVE.b  (a2,d6.w),d0        * get the exponent sign character
00A023CC  B03C 002D               6745      CMP.b       #'-',d0         * compare the exponent sign with "-"
00A023D0  6600 DD94               6746      BNE     LAB_FCER            * if it wasn't sx[.x]E-xx go do function
00A023D4                          6747                              * call error
00A023D4                          6748  
00A023D4                          6749  * found an sx[.x]E-xx number so check the exponent magnitude
00A023D4                          6750  
00A023D4  5246                    6751      ADDQ.w  #1,d6               * increment the index to the exponent 10s
00A023D6  1032 6000               6752      MOVE.b  (a2,d6.w),d0        * get the exponent 10s character
00A023DA  B03C 0030               6753      CMP.b       #'0',d0         * compare the exponent 10s with "0"
00A023DE  6704                    6754      BEQ.s       LAB_U009            * if it was sx[.x]E-0x go get the exponent
00A023E0                          6755                              * 1s character
00A023E0                          6756  
00A023E0  700A                    6757      MOVEQ       #10,d0          * else start writing at index 10
00A023E2  6008                    6758      BRA.s       LAB_U00A            * go copy the digits
00A023E4                          6759  
00A023E4                          6760  * found an sx[.x]E-0x number so get the exponent magnitude
00A023E4                          6761  
00A023E4                          6762  LAB_U009
00A023E4  5246                    6763      ADDQ.w  #1,d6               * increment the index to the exponent 1s
00A023E6  700F                    6764      MOVEQ       #$0F,d0         * set the mask for the exponent 1s digit
00A023E8  C032 6000               6765      AND.b       (a2,d6.w),d0        * get and convert the exponent 1s digit
00A023EC                          6766  LAB_U00A
00A023EC  3403                    6767      MOVE.w  d3,d2               * copy the number last digit index
00A023EE  0C42 0001               6768      CMPI.w  #1,d2               * is the number of the form sxE-0x
00A023F2  6602                    6769      BNE.s       LAB_U00B            * if it is sx.xE-0x skip the increment
00A023F4                          6770  
00A023F4                          6771                              * else make room for the decimal point
00A023F4  5242                    6772      ADDQ.w  #1,d2               * add 1 to the write index
00A023F6                          6773  LAB_U00B
00A023F6  D440                    6774      ADD.w       d0,d2               * add the exponent 1s to the write index
00A023F8  700A                    6775      MOVEQ       #10,d0          * set the maximum write index
00A023FA  9042                    6776      SUB.w       d2,d0               * compare the index with the maximum
00A023FC  6E0C                    6777      BGT.s       LAB_U00C            * if the index < the maximum continue
00A023FE                          6778  
00A023FE  D440                    6779      ADD.w       d0,d2               * else set the index to the maximum
00A02400  D640                    6780      ADD.w       d0,d3               * adjust the read index
00A02402  0C43 0001               6781      CMPI.w  #1,d3               * compare the adjusted index with 1
00A02406  6E02                    6782      BGT.s       LAB_U00C            * if > 1 continue
00A02408                          6783  
00A02408  7600                    6784      MOVEQ       #0,d3               * else allow for the decimal point
00A0240A                          6785  LAB_U00C
00A0240A  3C02                    6786      MOVE.w      d2,d6               * copy the write index as the number
00A0240C                          6787                              * string length
00A0240C  7000                    6788      MOVEQ       #0,d0               * clear d0 to null terminate the number
00A0240E                          6789                              * string
00A0240E                          6790  LAB_U00D
00A0240E  1580 2000               6791      MOVE.b  d0,(a2,d2.w)        * save the character to the number string
00A02412  5342                    6792      SUBQ.w  #1,d2               * decrement the number write index
00A02414  0C42 0001               6793      CMPI.w  #1,d2               * compare the number write index with 1
00A02418  6712                    6794      BEQ.s       LAB_U00F            * if at the decimal point go save it
00A0241A                          6795  
00A0241A                          6796                              * else write a digit to the number string
00A0241A  7030                    6797      MOVEQ       #'0',d0         * default to "0"
00A0241C  4A43                    6798      TST.w       d3              * test the number read index
00A0241E  67EE                    6799      BEQ.s       LAB_U00D            * if zero just go save the "0"
00A02420                          6800  
00A02420                          6801  LAB_U00E
00A02420  1032 3000               6802      MOVE.b  (a2,d3.w),d0        * read the next number digit
00A02424  5343                    6803      SUBQ.w  #1,d3               * decrement the read index
00A02426  B004                    6804      CMP.b       d4,d0               * compare the digit with "."
00A02428  66E4                    6805      BNE.s       LAB_U00D            * if not "." go save the digit
00A0242A                          6806  
00A0242A  60F4                    6807      BRA.s       LAB_U00E            * else go get the next digit
00A0242C                          6808  
00A0242C                          6809  LAB_U00F
00A0242C  1584 2000               6810      MOVE.b  d4,(a2,d2.w)        * save the decimal point
00A02430                          6811  LAB_U010
00A02430  4A42                    6812      TST.w       d2              * test the number string decimal point index
00A02432  6602                    6813      BNE.s       LAB_U014            * if dp present skip the reset
00A02434                          6814  
00A02434  3406                    6815      MOVE.w  d6,d2               * make the decimal point index = the length
00A02436                          6816  
00A02436                          6817  * copy the fractional digit characters from the number string
00A02436                          6818  
00A02436                          6819  LAB_U014
00A02436  3602                    6820      MOVE.w  d2,d3               * copy the number string decimal point index
00A02438  5243                    6821      ADDQ.w  #1,d3               * increment the number string index
00A0243A  382F 0008               6822      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00A0243E                          6823  LAB_U018
00A0243E  5244                    6824      ADDQ.w  #1,d4               * increment the new format string index
00A02440  B244                    6825      CMP.w       d4,d1               * compare it with the new format string length
00A02442  6322                    6826      BLS.s       LAB_U022            * if done the fraction digits go do integer
00A02444                          6827  
00A02444  1030 4000               6828      MOVE.b  (a0,d4.w),d0        * get a new format string character
00A02448  B03C 0025               6829      CMP.b       #'%',d0         * compare it with "%"
00A0244C  6706                    6830      BEQ.s       LAB_U01C            * if "%" go copy a number character
00A0244E                          6831  
00A0244E  B03C 0023               6832      CMP.b       #'#',d0         * compare it with "#"
00A02452  66EA                    6833      BNE.s       LAB_U018            * if not "#" go do the next new format character
00A02454                          6834  
00A02454                          6835  LAB_U01C
00A02454  7030                    6836      MOVEQ       #'0',d0         * default to "0" character
00A02456  BC43                    6837      CMP.w       d3,d6               * compare the number string index with length
00A02458  6306                    6838      BLS.s       LAB_U020            * if there skip the character get
00A0245A                          6839  
00A0245A  1032 3000               6840      MOVE.b  (a2,d3.w),d0        * get a character from the number string
00A0245E  5243                    6841      ADDQ.w  #1,d3               * increment the number string index
00A02460                          6842  LAB_U020
00A02460  1180 4000               6843      MOVE.b  d0,(a0,d4.w)        * save the number character to the new format
00A02464                          6844                              * string
00A02464  60D8                    6845      BRA.s       LAB_U018            * go do the next new format character
00A02466                          6846  
00A02466                          6847  * now copy the integer digit characters from the number string
00A02466                          6848  
00A02466                          6849  LAB_U022
00A02466  7C00                    6850      MOVEQ       #0,d6               * clear the sign done flag
00A02468  7A00                    6851      MOVEQ       #0,d5               * clear the sign present flag
00A0246A  5342                    6852      SUBQ.w  #1,d2               * decrement the number string index
00A0246C  6608                    6853      BNE.s       LAB_U026            * if not now at sign continue
00A0246E                          6854  
00A0246E  7401                    6855      MOVEQ       #1,d2               * increment the number string index
00A02470  15BC 0030 2000          6856      MOVE.b  #'0',(a2,d2.w)      * replace the point with a zero
00A02476                          6857  LAB_U026
00A02476  382F 0008               6858      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00A0247A  B244                    6859      CMP.w       d4,d1               * compare it with the new format string length
00A0247C  6402                    6860      BCC.s       LAB_U02A            * if within the string go use the index
00A0247E                          6861  
00A0247E  3801                    6862      MOVE.w  d1,d4               * else set the index to the end of the string
00A02480                          6863  LAB_U02A
00A02480  5344                    6864      SUBQ.w  #1,d4               * decrement the new format string index
00A02482  6B62                    6865      BMI.s       LAB_U03E            * if all done go test for any overflow
00A02484                          6866  
00A02484  1030 4000               6867      MOVE.b  (a0,d4.w),d0        * else get a new format string character
00A02488                          6868  
00A02488  7E30                    6869      MOVEQ       #'0',d7         * default to "0" character
00A0248A  B03C 0025               6870      CMP.b       #'%',d0         * compare it with "%"
00A0248E  6708                    6871      BEQ.s       LAB_U02B            * if "%" go copy a number character
00A02490                          6872  
00A02490  7E20                    6873      MOVEQ       #' ',d7         * default to " " character
00A02492  B03C 0023               6874      CMP.b       #'#',d0         * compare it with "#"
00A02496  6606                    6875      BNE.s       LAB_U02C            * if not "#" go try ","
00A02498                          6876  
00A02498                          6877  LAB_U02B
00A02498  4A42                    6878      TST.w       d2              * test the number string index
00A0249A  6634                    6879      BNE.s       LAB_U036            * if not at the sign go get a number character
00A0249C                          6880  
00A0249C  6042                    6881      BRA.s       LAB_U03C            * else go save the default character
00A0249E                          6882  
00A0249E                          6883  LAB_U02C
00A0249E  B03C 002C               6884      CMP.b       #',',d0         * compare it with ","
00A024A2  6610                    6885      BNE.s       LAB_U030            * if not "," go try the sign characters
00A024A4                          6886  
00A024A4  4A42                    6887      TST.w       d2              * test the number string index
00A024A6  6608                    6888      BNE.s       LAB_U02E            * if not at the sign keep the ","
00A024A8                          6889  
00A024A8  0C30 0025 40FF          6890      CMP.b       #'%',-1(a0,d4.w)        * else compare the next format string character
00A024AE                          6891                              * with "%"
00A024AE  6630                    6892      BNE.s       LAB_U03C            * if not "%" keep the default character
00A024B0                          6893  
00A024B0                          6894  LAB_U02E
00A024B0  1E00                    6895      MOVE.b  d0,d7               * else use the "," character
00A024B2  602C                    6896      BRA.s       LAB_U03C            * go save the character to the string
00A024B4                          6897  
00A024B4                          6898  LAB_U030
00A024B4  B03C 002D               6899      CMP.b       #'-',d0         * compare it with "-"
00A024B8  6710                    6900      BEQ.s       LAB_U034            * if "-" go do the sign character
00A024BA                          6901  
00A024BA  B03C 002B               6902      CMP.b       #'+',d0         * compare it with "+"
00A024BE  66C0                    6903      BNE.s       LAB_U02A            * if not "+" go do the next new format character
00A024C0                          6904  
00A024C0  0C12 002D               6905      CMP.b       #'-',(a2)           * compare the sign character with "-"
00A024C4  6704                    6906      BEQ.s       LAB_U034            * if "-" don't change the sign character
00A024C6                          6907  
00A024C6  14BC 002B               6908      MOVE.b  #'+',(a2)           * else make the sign character "+"
00A024CA                          6909  LAB_U034
00A024CA  1A00                    6910      MOVE.b  d0,d5               * set the sign present flag
00A024CC  4A42                    6911      TST.w       d2              * test the number string index
00A024CE  6708                    6912      BEQ.s       LAB_U038            * if at the sign keep the default character
00A024D0                          6913  
00A024D0                          6914  LAB_U036
00A024D0  1E32 2000               6915      MOVE.b  (a2,d2.w),d7        * else get a character from the number string
00A024D4  5342                    6916      SUBQ.w  #1,d2               * decrement the number string index
00A024D6  6008                    6917      BRA.s       LAB_U03C            * go save the character
00A024D8                          6918  
00A024D8                          6919  LAB_U038
00A024D8  4A06                    6920      TST.b       d6              * test the sign done flag
00A024DA  6604                    6921      BNE.s       LAB_U03C            * if the sign has been done go use the space
00A024DC                          6922                              * character
00A024DC                          6923  
00A024DC  1E12                    6924      MOVE.b  (a2),d7         * else get the sign character
00A024DE  1C07                    6925      MOVE.b  d7,d6               * flag that the sign has been done
00A024E0                          6926  LAB_U03C
00A024E0  1187 4000               6927      MOVE.b  d7,(a0,d4.w)        * save the number character to the new format
00A024E4                          6928                              * string
00A024E4  609A                    6929      BRA.s       LAB_U02A            * go do the next new format character
00A024E6                          6930  
00A024E6                          6931  * test for overflow conditions
00A024E6                          6932  
00A024E6                          6933  LAB_U03E
00A024E6  4A42                    6934      TST.w       d2              * test the number string index
00A024E8  6614                    6935      BNE.s       LAB_U040            * if all the digits aren't done go output
00A024EA                          6936                              * an overflow indication
00A024EA                          6937  
00A024EA                          6938  * test for sign overflows
00A024EA                          6939  
00A024EA  4A05                    6940      TST.b       d5              * test the sign present flag
00A024EC  6754                    6941      BEQ.s       LAB_U04A            * if no sign present go add the string
00A024EE                          6942  
00A024EE                          6943  * there was a sign in the format string
00A024EE                          6944  
00A024EE  4A06                    6945      TST.b       d6              * test the sign done flag
00A024F0  6650                    6946      BNE.s       LAB_U04A            * if the sign is done go add the string
00A024F2                          6947  
00A024F2                          6948  * the sign isn't done so see if it was mandatory
00A024F2                          6949  
00A024F2  0C05 002B               6950      CMPI.b  #'+',d5         * compare the sign with "+"
00A024F6  6706                    6951      BEQ.s       LAB_U040            * if it was "+" go output an overflow
00A024F8                          6952                              * indication
00A024F8                          6953  
00A024F8                          6954  * the sign wasn't mandatory but the number may have been negative
00A024F8                          6955  
00A024F8  0C12 002D               6956      CMP.b       #'-',(a2)           * compare the sign character with "-"
00A024FC  6644                    6957      BNE.s       LAB_U04A            * if it wasn't "-" go add the string
00A024FE                          6958  
00A024FE                          6959  * else the sign was "-" and a sign hasn't been output so ..
00A024FE                          6960  
00A024FE                          6961  * the number overflowed the format string so replace all the special format characters
00A024FE                          6962  * with the overflow character
00A024FE                          6963  
00A024FE                          6964  LAB_U040
00A024FE  7A23                    6965      MOVEQ       #ofchr,d5           * set the overflow character
00A02500  3E01                    6966      MOVE.w  d1,d7               * copy the new format string length
00A02502  5347                    6967      SUBQ.w  #1,d7               * adjust for the loop type
00A02504  3C2F 0004               6968      MOVE.w  fsti(sp),d6         * copy the new format string last index
00A02508  5346                    6969      SUBQ.w  #1,d6               * -1 gives the last character of this string
00A0250A  6E02                    6970      BGT.s       LAB_U044            * if not zero continue
00A0250C                          6971  
00A0250C  3C07                    6972      MOVE.w  d7,d6               * else set the format string index to the end
00A0250E                          6973  LAB_U044
00A0250E  1031 6000               6974      MOVE.b  (a1,d6.w),d0        * get a character from the format string
00A02512  0C00 0023               6975      CMPI.b  #'#',d0         * compare it with "#" special format character
00A02516  671E                    6976      BEQ.s       LAB_U046            * if "#" go use the overflow character
00A02518                          6977  
00A02518  0C00 0025               6978      CMPI.b  #'%',d0         * compare it with "%" special format character
00A0251C  6718                    6979      BEQ.s       LAB_U046            * if "%" go use the overflow character
00A0251E                          6980  
00A0251E  0C00 002C               6981      CMPI.b  #',',d0         * compare it with "," special format character
00A02522  6712                    6982      BEQ.s       LAB_U046            * if "," go use the overflow character
00A02524                          6983  
00A02524  0C00 002B               6984      CMPI.b  #'+',d0         * compare it with "+" special format character
00A02528  670C                    6985      BEQ.s       LAB_U046            * if "+" go use the overflow character
00A0252A                          6986  
00A0252A  0C00 002D               6987      CMPI.b  #'-',d0         * compare it with "-" special format character
00A0252E  6706                    6988      BEQ.s       LAB_U046            * if "-" go use the overflow character
00A02530                          6989  
00A02530  0C00 002E               6990      CMPI.b  #'.',d0         * compare it with "." special format character
00A02534  6602                    6991      BNE.s       LAB_U048            * if not "." skip the using overflow character
00A02536                          6992  
00A02536                          6993  LAB_U046
00A02536  1005                    6994      MOVE.b  d5,d0               * use the overflow character
00A02538                          6995  LAB_U048
00A02538  1180 7000               6996      MOVE.b  d0,(a0,d7.w)        * save the character to the new format string
00A0253C  5346                    6997      SUBQ.w  #1,d6               * decrement the format string index
00A0253E  51CF FFCE               6998      DBF     d7,LAB_U044         * decrement the count and loop if not all done
00A02542                          6999  
00A02542                          7000  * add the new string to the previous string
00A02542                          7001  
00A02542                          7002  LAB_U04A
00A02542  41EC 0006               7003      LEA     6(a4),a0            * get the descriptor pointer for string 1
00A02546  274C 0DF4               7004      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00A0254A  6100 F010               7005      BSR     LAB_224E            * concatenate the strings
00A0254E                          7006  
00A0254E                          7007  * now check for any tail on the format string
00A0254E                          7008  
00A0254E  302F 0004               7009      MOVE.w  fsti(sp),d0         * get this index
00A02552  6720                    7010      BEQ.s       LAB_U04C            * if at start of string skip the output
00A02554                          7011  
00A02554  3F40 0006               7012      MOVE.w  d0,fsli(sp)         * save this index to the last index
00A02558  6100 0084               7013      BSR     LAB_ProcFo          * now process the format string
00A0255C  4A02                    7014      TST.b       d2              * test the special characters flag
00A0255E  6614                    7015      BNE.s       LAB_U04C            * if special characters present skip the output
00A02560                          7016  
00A02560                          7017  * else output the new string part
00A02560                          7018  
00A02560  613E                    7019      BSR.s       LAB_DupFmt          * duplicate the processed format string section
00A02562  3F6F 0004 0006          7020      MOVE.w  fsti(sp),fsli(sp)       * copy this index to the last index
00A02568                          7021  
00A02568                          7022  * add the new string to the previous string
00A02568                          7023  
00A02568  41EC 0006               7024      LEA     6(a4),a0            * get the descriptor pointer for string 1
00A0256C  274C 0DF4               7025      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00A02570  6100 EFEA               7026      BSR     LAB_224E            * concatenate the strings
00A02574                          7027  
00A02574                          7028  * check for another value or end of function
00A02574                          7029  
00A02574                          7030  LAB_U04C
00A02574  101D                    7031      MOVE.b  (a5)+,d0            * get the next BASIC byte
00A02576  B03C 0029               7032      CMP.b       #')',d0         * compare with close bracket
00A0257A  6600 FDCA               7033      BNE     LAB_U002            * if not ")" go do next value
00A0257E                          7034  
00A0257E                          7035  * pop the result string off the descriptor stack
00A0257E                          7036  
00A0257E  204C                    7037      MOVEA.l a4,a0               * copy the result string descriptor pointer
00A02580  222B 0CAA               7038      MOVE.l  Sstorl(a3),d1       * save the bottom of string space
00A02584  6100 F038               7039      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00A02588                          7040                              * d0 = length, a0 = pointer
00A02588  2741 0CAA               7041      MOVE.l  d1,Sstorl(a3)       * restore the bottom of string space
00A0258C  2248                    7042      MOVEA.l a0,a1               * copy the string result pointer
00A0258E  3200                    7043      MOVE.w  d0,d1               * copy the string result length
00A02590                          7044  
00A02590                          7045  * pop the format string off the descriptor stack
00A02590                          7046  
00A02590  205F                    7047      MOVEA.l (sp)+,a0            * pull the format string descriptor pointer
00A02592  6100 F02A               7048      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00A02596                          7049                              * d0 = length, a0 = pointer
00A02596                          7050  
00A02596  4FEF 0008               7051      LEA     fend(sp),sp         * dump the saved values
00A0259A                          7052  
00A0259A                          7053  * push the result string back on the descriptor stack and return
00A0259A                          7054  
00A0259A  2049                    7055      MOVEA.l a1,a0               * copy the result string pointer back
00A0259C  6000 EE6E               7056      BRA     LAB_RTST            * push a string on the descriptor stack and
00A025A0                          7057                              * return. a0 = pointer, d1 = length
00A025A0                          7058  
00A025A0                          7059  
00A025A0                          7060  *************************************************************************************
00A025A0                          7061  *
00A025A0                          7062  * duplicate the processed format string section
00A025A0                          7063  
00A025A0                          7064                              * make a string as long as the format string
00A025A0                          7065  LAB_DupFmt
00A025A0  226F 0004               7066      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00A025A4  3E29 0004               7067      MOVE.w  4(a1),d7            * get the format string length
00A025A8  342F 000A               7068      MOVE.w  4+fsli(sp),d2       * get the format string last index
00A025AC  3C2F 0008               7069      MOVE.w  4+fsti(sp),d6       * get the format string this index
00A025B0  3206                    7070      MOVE.w  d6,d1               * copy the format string this index
00A025B2  9242                    7071      SUB.w       d2,d1               * subtract the format string last index
00A025B4  6202                    7072      BHI.s       LAB_D002            * if > 0 skip the correction
00A025B6                          7073  
00A025B6  D247                    7074      ADD.w       d7,d1               * else add the format string length as the
00A025B8                          7075                              * correction
00A025B8                          7076  LAB_D002
00A025B8  6100 EE6C               7077      BSR     LAB_2115            * make string space d1 bytes long
00A025BC                          7078                              * return a0/Sutill = pointer, others unchanged
00A025BC                          7079  
00A025BC                          7080  * push the new string on the descriptor stack
00A025BC                          7081  
00A025BC  6100 EE4E               7082      BSR     LAB_RTST            * push a string on the descriptor stack and
00A025C0                          7083                              * return. a0 = pointer, d1 = length
00A025C0                          7084  
00A025C0                          7085  * copy the characters from the format string
00A025C0                          7086  
00A025C0  226F 0004               7087      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00A025C4  2251                    7088      MOVEA.l (a1),a1         * get the format string pointer
00A025C6  7800                    7089      MOVEQ       #0,d4               * clear the new string index
00A025C8                          7090  LAB_D00A
00A025C8  11B1 2000 4000          7091      MOVE.b  (a1,d2.w),(a0,d4.w) * get a character from the format string and
00A025CE                          7092                              * save it to the new string
00A025CE  5244                    7093      ADDQ.w  #1,d4               * increment the new string index
00A025D0  5242                    7094      ADDQ.w  #1,d2               * increment the format string index
00A025D2  BE42                    7095      CMP.w       d2,d7               * compare the format index with the length
00A025D4  6602                    7096      BNE.s       LAB_D00E            * if not there skip the reset
00A025D6                          7097  
00A025D6  7400                    7098      MOVEQ       #0,d2               * else reset the format string index
00A025D8                          7099  LAB_D00E
00A025D8  BC42                    7100      CMP.w       d2,d6               * compare the index with this index
00A025DA  66EC                    7101      BNE.s       LAB_D00A            * if not equal go do the next character
00A025DC                          7102  
00A025DC  4E75                    7103      RTS
00A025DE                          7104  
00A025DE                          7105  
00A025DE                          7106  **************************************************************************************
00A025DE                          7107  *
00A025DE                          7108  * process the format string
00A025DE                          7109  
00A025DE                          7110  LAB_ProcFo
00A025DE  226F 0004               7111      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00A025E2  3E29 0004               7112      MOVE.w  4(a1),d7            * get the format string length
00A025E6  2251                    7113      MOVEA.l (a1),a1         * get the format string pointer
00A025E8  3C2F 000A               7114      MOVE.w  4+fsli(sp),d6       * get the format string last index
00A025EC                          7115  
00A025EC  3F47 000C               7116      MOVE.w  d7,4+fsdpi(sp)      * set the format string decimal point index
00A025F0                          7117  *## MOVE.w  #-1,4+fsdpi(sp)     * set the format string decimal point index
00A025F0  7A00                    7118      MOVEQ       #0,d5               * no decimal point
00A025F2  7600                    7119      MOVEQ       #0,d3               * no decimal characters
00A025F4  7400                    7120      MOVEQ       #0,d2               * no special characters
00A025F6                          7121  LAB_P004
00A025F6  1031 6000               7122      MOVE.b  (a1,d6.w),d0        * get a format string byte
00A025FA                          7123  
00A025FA  B03C 002C               7124      CMP.b       #',',d0         * compare it with ","
00A025FE  6742                    7125      BEQ.s       LAB_P01A            * if "," go do the next format string byte
00A02600                          7126  
00A02600  B03C 0023               7127      CMP.b       #'#',d0         * compare it with "#"
00A02604  6706                    7128      BEQ.s       LAB_P008            * if "#" go flag special characters
00A02606                          7129  
00A02606  B03C 0025               7130      CMP.b       #'%',d0         * compare it with "%"
00A0260A  6608                    7131      BNE.s       LAB_P00C            * if not "%" go try "+"
00A0260C                          7132  
00A0260C                          7133  LAB_P008
00A0260C  4A85                    7134      TST.l       d5              * test the decimal point flag
00A0260E  6A10                    7135      BPL.s       LAB_P00E            * if no point skip counting decimal characters
00A02610                          7136  
00A02610  5243                    7137      ADDQ.w  #1,d3               * else increment the decimal character count
00A02612  602E                    7138      BRA.s       LAB_P01A            * go do the next character
00A02614                          7139  
00A02614                          7140  LAB_P00C
00A02614  B03C 002B               7141      CMP.b       #'+',d0         * compare it with "+"
00A02618  6706                    7142      BEQ.s       LAB_P00E            * if "+" go flag special characters
00A0261A                          7143  
00A0261A  B03C 002D               7144      CMP.b       #'-',d0         * compare it with "-"
00A0261E  6604                    7145      BNE.s       LAB_P010            * if not "-" go check decimal point
00A02620                          7146  
00A02620                          7147  LAB_P00E
00A02620  8400                    7148      OR.b        d0,d2               * flag special characters
00A02622  601E                    7149      BRA.s       LAB_P01A            * go do the next character
00A02624                          7150  
00A02624                          7151  LAB_P010
00A02624  B03C 002E               7152      CMP.b       #'.',d0         * compare it with "."
00A02628  6614                    7153      BNE.s       LAB_P018            * if not "." go check next
00A0262A                          7154  
00A0262A                          7155  * "." a decimal point
00A0262A                          7156  
00A0262A  4A85                    7157      TST.l       d5              * if there is already a decimal point
00A0262C  6B14                    7158      BMI.s       LAB_P01A            * go do the next character
00A0262E                          7159  
00A0262E  3006                    7160      MOVE.w  d6,d0               * copy the decimal point index
00A02630  906F 000A               7161      SUB.w       4+fsli(sp),d0       * calculate it from the scan start
00A02634  3F40 000C               7162      MOVE.w  d0,4+fsdpi(sp)      * save the decimal point index
00A02638  7AFF                    7163      MOVEQ       #-1,d5          * flag decimal point
00A0263A  8400                    7164      OR.b        d0,d2               * flag special characters
00A0263C  6004                    7165      BRA.s       LAB_P01A            * go do the next character
00A0263E                          7166  
00A0263E                          7167  * was not a special character
00A0263E                          7168  
00A0263E                          7169  LAB_P018
00A0263E  4A02                    7170      TST.b       d2              * test if there have been special characters
00A02640  6608                    7171      BNE.s       LAB_P01E            * if so exit the format string process
00A02642                          7172  
00A02642                          7173  LAB_P01A
00A02642  5246                    7174      ADDQ.w  #1,d6               * increment the format string index
00A02644  BE46                    7175      CMP.w       d6,d7               * compare it with the format string length
00A02646  62AE                    7176      BHI.s       LAB_P004            * if length > index go get the next character
00A02648                          7177  
00A02648  7C00                    7178      MOVEQ       #0,d6               * length = index so reset the format string
00A0264A                          7179                              * index
00A0264A                          7180  LAB_P01E
00A0264A  3F46 0008               7181      MOVE.w  d6,4+fsti(sp)       * save the format string this index
00A0264E  3F43 000E               7182      MOVE.w  d3,4+fsdc(sp)       * save the format string decimal characters
00A02652                          7183  
00A02652  4E75                    7184      RTS
00A02654                          7185  
00A02654                          7186  
00A02654                          7187  *************************************************************************************
00A02654                          7188  *
00A02654                          7189  * perform BIN$()
00A02654                          7190  * # of leading 0s is in d1, the number is in d0
00A02654                          7191  
00A02654                          7192  LAB_BINS
00A02654  B23C 0021               7193      CMP.b       #$21,d1         * max + 1
00A02658  6400 DB0C               7194      BCC     LAB_FCER            * exit if too big ( > or = )
00A0265C                          7195  
00A0265C  741F                    7196      MOVEQ       #$1F,d2         * bit count-1
00A0265E  41EB 0E1A               7197      LEA     Binss(a3),a0        * point to string
00A02662  7830                    7198      MOVEQ       #$30,d4         * "0" character for ADDX
00A02664                          7199  NextB1
00A02664  7600                    7200      MOVEQ       #0,d3               * clear byte
00A02666  E288                    7201      LSR.l       #1,d0               * shift bit into Xb
00A02668  D704                    7202      ADDX.b  d4,d3               * add carry and character to zero
00A0266A  1183 2000               7203      MOVE.b  d3,(a0,d2.w)        * save character to string
00A0266E  51CA FFF4               7204      DBF     d2,NextB1           * decrement and loop if not done
00A02672                          7205  
00A02672                          7206  * this is the exit code and is also used by HEX$()
00A02672                          7207  
00A02672                          7208  EndBHS
00A02672  177C 0000 0E3A          7209      MOVE.b  #0,BHsend(a3)       * null terminate the string
00A02678  4A01                    7210      TST.b       d1              * test # of characters
00A0267A  670E                    7211      BEQ.s       NextB2          * go truncate string
00A0267C                          7212  
00A0267C  4481                    7213      NEG.l       d1              * make -ve
00A0267E  0681 00000E3A           7214      ADD.l       #BHsend,d1          * effectively (end-length)
00A02684  41F3 1000               7215      LEA     0(a3,d1.w),a0       * effectively add (end-length) to pointer
00A02688  600E                    7216      BRA.s       BinPr               * go print string
00A0268A                          7217  
00A0268A                          7218  * truncate string to remove leading "0"s
00A0268A                          7219  
00A0268A                          7220  NextB2
00A0268A  1010                    7221      MOVE.b  (a0),d0         * get byte
00A0268C  670A                    7222      BEQ.s       BinPr               * if null then end of string so add 1 and go
00A0268E                          7223                              * print it
00A0268E                          7224  
00A0268E  B03C 0030               7225      CMP.b       #'0',d0         * compare with "0"
00A02692  660E                    7226      BNE.s       GoPr                * if not "0" then go print string from here
00A02694                          7227  
00A02694  5248                    7228      ADDQ.w  #1,a0               * else increment pointer
00A02696  60F2                    7229      BRA.s       NextB2          * loop always
00A02698                          7230  
00A02698                          7231  * make fixed length output string - ignore overflows!
00A02698                          7232  
00A02698                          7233  BinPr
00A02698  43EB 0E3A               7234      LEA     BHsend(a3),a1       * get string end
00A0269C  B1C9                    7235      CMPA.l  a1,a0               * are we at the string end
00A0269E  6602                    7236      BNE.s       GoPr                * branch if not
00A026A0                          7237  
00A026A0  5348                    7238      SUBQ.w  #1,a0               * else need at least one zero
00A026A2                          7239  GoPr
00A026A2  6000 ED22               7240      BRA     LAB_20AE            * print " terminated string to FAC1, stack & RET
00A026A6                          7241  
00A026A6                          7242  
00A026A6                          7243  *************************************************************************************
00A026A6                          7244  *
00A026A6                          7245  * perform HEX$()
00A026A6                          7246  * # of leading 0s is in d1, the number is in d0
00A026A6                          7247  
00A026A6                          7248  LAB_HEXS
00A026A6  B23C 0009               7249      CMP.b       #$09,d1         * max + 1
00A026AA  6400 DABA               7250      BCC     LAB_FCER            * exit if too big ( > or = )
00A026AE                          7251  
00A026AE  7407                    7252      MOVEQ       #$07,d2         * nibble count-1
00A026B0  41EB 0E32               7253      LEA     Hexss(a3),a0        * point to string
00A026B4  7830                    7254      MOVEQ       #$30,d4         * "0" character for ABCD
00A026B6                          7255  NextH1
00A026B6  1600                    7256      MOVE.b  d0,d3               * copy lowest byte
00A026B8  E898                    7257      ROR.l       #4,d0               * shift nibble into 0-3
00A026BA  C63C 000F               7258      AND.b       #$0F,d3         * just this nibble
00A026BE  1A03                    7259      MOVE.b  d3,d5               * copy it
00A026C0  0605 00F6               7260      ADD.b       #$F6,d5         * set extend bit
00A026C4  C704                    7261      ABCD        d4,d3               * decimal add extend and character to zero
00A026C6  1183 2000               7262      MOVE.b  d3,(a0,d2.w)        * save character to string
00A026CA  51CA FFEA               7263      DBF     d2,NextH1           * decrement and loop if not done
00A026CE                          7264  
00A026CE  60A2                    7265      BRA.s       EndBHS          * go process string
00A026D0                          7266  
00A026D0                          7267  
00A026D0                          7268  *************************************************************************************
00A026D0                          7269  *
00A026D0                          7270  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00A026D0                          7271  
00A026D0                          7272  VEC_CC
00A026D0  4A2B 0E4C               7273      TST.b       ccflag(a3)          * check [CTRL-C] check flag
00A026D4  661E                    7274      BNE.s       RTS_022         * exit if [CTRL-C] check inhibited
00A026D6                          7275  
00A026D6  4EAB 0C70               7276      JSR     V_INPT(a3)          * scan input device
00A026DA  640E                    7277      BCC.s       LAB_FBA0            * exit if buffer empty
00A026DC                          7278  
00A026DC  1740 0E4D               7279      MOVE.b  d0,ccbyte(a3)       * save received byte
00A026E0  177C 0020 0E4E          7280      MOVE.b  #$20,ccnull(a3)     * set "life" timer for bytes countdown
00A026E6  6000 DEF2               7281      BRA     LAB_1636            * return to BASIC
00A026EA                          7282  
00A026EA                          7283  LAB_FBA0
00A026EA  4A2B 0E4E               7284      TST.b       ccnull(a3)          * get countdown byte
00A026EE  6704                    7285      BEQ.s       RTS_022         * exit if finished
00A026F0                          7286  
00A026F0  532B 0E4E               7287      SUBQ.b  #1,ccnull(a3)       * else decrement countdown
00A026F4                          7288  RTS_022
00A026F4  4E75                    7289      RTS
00A026F6                          7290  
00A026F6                          7291  
00A026F6                          7292  *************************************************************************************
00A026F6                          7293  *
00A026F6                          7294  * get byte from input device, no waiting
00A026F6                          7295  * returns with carry set if byte in A
00A026F6                          7296  
00A026F6                          7297  INGET
00A026F6  4EAB 0C70               7298      JSR     V_INPT(a3)          * call scan input device
00A026FA  650A                    7299      BCS.s       LAB_FB95            * if byte go reset timer
00A026FC                          7300  
00A026FC  102B 0E4E               7301      MOVE.b  ccnull(a3),d0       * get countdown
00A02700  67F2                    7302      BEQ.s       RTS_022         * exit if empty
00A02702                          7303  
00A02702  102B 0E4D               7304      MOVE.b  ccbyte(a3),d0       * get last received byte
00A02706                          7305  LAB_FB95
00A02706  177C 0000 0E4E          7306      MOVE.b  #$00,ccnull(a3)     * clear timer because we got a byte
00A0270C  003C 0001               7307      ORI.b       #1,CCR          * set carry, flag we got a byte
00A02710  4E75                    7308      RTS
00A02712                          7309  
00A02712                          7310  
00A02712                          7311  *************************************************************************************
00A02712                          7312  *
00A02712                          7313  * perform MAX()
00A02712                          7314  
00A02712                          7315  LAB_MAX
00A02712  6100 E53E               7316      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00A02716  4A2B 0E19               7317      TST.b       Dtypef(a3)          * test data type
00A0271A  6B00 DA2A               7318      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00A0271E                          7319  
00A0271E                          7320  LAB_MAXN
00A0271E  612E                    7321      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00A02720                          7322                              * pull FAC2 & compare with FAC1
00A02720  64FC                    7323      BCC.s       LAB_MAXN            * branch if no swap to do
00A02722                          7324  
00A02722  6100 F4AA               7325      BSR     LAB_279B            * copy FAC2 to FAC1
00A02726  60F6                    7326      BRA.s       LAB_MAXN            * go do next
00A02728                          7327  
00A02728                          7328  
00A02728                          7329  *************************************************************************************
00A02728                          7330  *
00A02728                          7331  * perform MIN()
00A02728                          7332  
00A02728                          7333  LAB_MIN
00A02728  6100 E528               7334      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00A0272C  4A2B 0E19               7335      TST.b       Dtypef(a3)          * test data type
00A02730  6B00 DA14               7336      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00A02734                          7337  
00A02734                          7338  LAB_MINN
00A02734  6118                    7339      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00A02736                          7340                              * pull FAC2 & compare with FAC1
00A02736  63FC                    7341      BLS.s       LAB_MINN            * branch if no swap to do
00A02738                          7342  
00A02738  6100 F494               7343      BSR     LAB_279B            * copy FAC2 to FAC1
00A0273C  60F6                    7344      BRA.s       LAB_MINN            * go do next (branch always)
00A0273E                          7345  
00A0273E                          7346  * exit routine. don't bother returning to the loop code
00A0273E                          7347  * check for correct exit, else so syntax error
00A0273E                          7348  
00A0273E                          7349  LAB_MMEC
00A0273E  B03C 0029               7350      CMP.b       #')',d0         * is it end of function?
00A02742  6600 DA2E               7351      BNE     LAB_SNER            * if not do MAX MIN syntax error
00A02746                          7352  
00A02746  4FEF 0004               7353      LEA     4(sp),sp            * dump return address (faster)
00A0274A  6000 E664               7354      BRA     LAB_IGBY            * update BASIC execute pointer (to chr past ")")
00A0274E                          7355                              * and return
00A0274E                          7356  
00A0274E                          7357  * check for next, evaluate & return or exit
00A0274E                          7358  * this is the routine that does most of the work
00A0274E                          7359  
00A0274E                          7360  LAB_PHFA
00A0274E  6100 E662               7361      BSR     LAB_GBYT            * get next BASIC byte
00A02752  B03C 002C               7362      CMP.b       #',',d0         * is there more ?
00A02756  66E6                    7363      BNE.s       LAB_MMEC            * if not go do end check
00A02758                          7364  
00A02758  3F2B 0DF8               7365      MOVE.w  FAC1_e(a3),-(sp)        * push exponent and sign
00A0275C  2F2B 0DF4               7366      MOVE.l  FAC1_m(a3),-(sp)        * push mantissa
00A02760                          7367  
00A02760  6100 E4F0               7368      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00A02764  4A2B 0E19               7369      TST.b       Dtypef(a3)          * test data type
00A02768  6B00 D9DC               7370      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00A0276C                          7371  
00A0276C                          7372  
00A0276C                          7373                              * pop FAC2 (MAX/MIN expression so far)
00A0276C  275F 0DFC               7374      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00A02770                          7375  
00A02770  301F                    7376      MOVE.w  (sp)+,d0            * pop exponent and sign
00A02772  3740 0E00               7377      MOVE.w  d0,FAC2_e(a3)       * save exponent and sign
00A02776  176B 0DF9 0E02          7378      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * get FAC1 sign
00A0277C  B12B 0E02               7379      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00A02780  6000 F4B8               7380      BRA     LAB_27FA            * compare FAC1 with FAC2 & return
00A02784                          7381                              * returns d0=+1 Cb=0 if FAC1 > FAC2
00A02784                          7382                              * returns d0= 0 Cb=0 if FAC1 = FAC2
00A02784                          7383                              * returns d0=-1 Cb=1 if FAC1 < FAC2
00A02784                          7384  
00A02784                          7385  
00A02784                          7386  *************************************************************************************
00A02784                          7387  *
00A02784                          7388  * perform WIDTH
00A02784                          7389  
00A02784                          7390  LAB_WDTH
00A02784  B03C 002C               7391      CMP.b       #',',d0         * is next byte ","
00A02788  672C                    7392      BEQ.s       LAB_TBSZ            * if so do tab size
00A0278A                          7393  
00A0278A  6100 EF8E               7394      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00A0278E  4A00                    7395      TST.b       d0              * test result
00A02790  6712                    7396      BEQ.s       LAB_NSTT            * branch if set for infinite line
00A02792                          7397  
00A02792  B03C 0010               7398      CMP.b       #$10,d0         * else make min width = 16d
00A02796  6500 D9CE               7399      BCS     LAB_FCER            * if less do function call error & exit
00A0279A                          7400  
00A0279A                          7401  * this next compare ensures that we can't exit WIDTH via an error leaving the
00A0279A                          7402  * tab size greater than the line length.
00A0279A                          7403  
00A0279A  B02B 0E46               7404      CMP.b       TabSiz(a3),d0       * compare with tab size
00A0279E  6404                    7405      BCC.s       LAB_NSTT            * branch if >= tab size
00A027A0                          7406  
00A027A0  1740 0E46               7407      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00A027A4                          7408  LAB_NSTT
00A027A4  1740 0E4A               7409      MOVE.b  d0,TWidth(a3)       * set the terminal width
00A027A8  6100 E608               7410      BSR     LAB_GBYT            * get BASIC byte back
00A027AC  672C                    7411      BEQ.s       WExit               * exit if no following
00A027AE                          7412  
00A027AE  B03C 002C               7413      CMP.b       #',',d0         * else is it ","
00A027B2  6600 D9BE               7414      BNE     LAB_SNER            * if not do syntax error
00A027B6                          7415  
00A027B6                          7416  LAB_TBSZ
00A027B6  6100 EF5E               7417      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00A027BA  4A00                    7418      TST.b       d0              * test TAB size
00A027BC  6B00 D9A8               7419      BMI     LAB_FCER            * if >127 do function call error & exit
00A027C0                          7420  
00A027C0  B03C 0001               7421      CMP.b       #1,d0               * compare with min-1
00A027C4  6500 D9A0               7422      BCS     LAB_FCER            * if <=1 do function call error & exit
00A027C8                          7423  
00A027C8  122B 0E4A               7424      MOVE.b  TWidth(a3),d1       * set flags for width
00A027CC  6708                    7425      BEQ.s       LAB_SVTB            * skip check if infinite line
00A027CE                          7426  
00A027CE  B02B 0E4A               7427      CMP.b       TWidth(a3),d0       * compare TAB with width
00A027D2  6E00 D992               7428      BGT     LAB_FCER            * branch if too big
00A027D6                          7429  
00A027D6                          7430  LAB_SVTB
00A027D6  1740 0E46               7431      MOVE.b  d0,TabSiz(a3)       * save TAB size
00A027DA                          7432  
00A027DA                          7433  * calculate tab column limit from TAB size. The Iclim is set to the last tab
00A027DA                          7434  * position on a line that still has at least one whole tab width between it
00A027DA                          7435  * and the end of the line.
00A027DA                          7436  
00A027DA                          7437  WExit
00A027DA  102B 0E4A               7438      MOVE.b  TWidth(a3),d0       * get width
00A027DE  670A                    7439      BEQ.s       LAB_WDLP            * branch if infinite line
00A027E0                          7440  
00A027E0  B02B 0E46               7441      CMP.b       TabSiz(a3),d0       * compare with tab size
00A027E4  6404                    7442      BCC.s       LAB_WDLP            * branch if >= tab size
00A027E6                          7443  
00A027E6  1740 0E46               7444      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00A027EA                          7445  LAB_WDLP
00A027EA  902B 0E46               7446      SUB.b       TabSiz(a3),d0       * subtract tab size
00A027EE  64FA                    7447      BCC.s       LAB_WDLP            * loop while no borrow
00A027F0                          7448  
00A027F0  D02B 0E46               7449      ADD.b       TabSiz(a3),d0       * add tab size back
00A027F4  D02B 0E46               7450      ADD.b       TabSiz(a3),d0       * add tab size back again
00A027F8                          7451  
00A027F8  4400                    7452      NEG.b       d0              * make -ve
00A027FA  D02B 0E4A               7453      ADD.b       TWidth(a3),d0       * subtract remainder from width
00A027FE  1740 0E4B               7454      MOVE.b  d0,Iclim(a3)        * save tab column limit
00A02802                          7455  RTS_023
00A02802  4E75                    7456      RTS
00A02804                          7457  
00A02804                          7458  
00A02804                          7459  *************************************************************************************
00A02804                          7460  *
00A02804                          7461  * perform SQR()
00A02804                          7462  
00A02804                          7463  * d0 is number to find the root of
00A02804                          7464  * d1 is the root result
00A02804                          7465  * d2 is the remainder
00A02804                          7466  * d3 is a counter
00A02804                          7467  * d4 is temp
00A02804                          7468  
00A02804                          7469  LAB_SQR
00A02804  4A2B 0DF9               7470      TST.b       FAC1_s(a3)          * test FAC1 sign
00A02808  6B00 D95C               7471      BMI     LAB_FCER            * if -ve do function call error
00A0280C                          7472  
00A0280C  4A2B 0DF8               7473      TST.b       FAC1_e(a3)          * test exponent
00A02810  67F0                    7474      BEQ.s       RTS_023         * exit if zero
00A02812                          7475  
00A02812  48E7 7800               7476      MOVEM.l d1-d4,-(sp)         * save registers
00A02816  202B 0DF4               7477      MOVE.l  FAC1_m(a3),d0       * copy FAC1
00A0281A  7400                    7478      MOVEQ       #0,d2               * clear remainder
00A0281C  2202                    7479      MOVE.l  d2,d1               * clear root
00A0281E                          7480  
00A0281E  761F                    7481      MOVEQ       #$1F,d3         * $1F for DBF, 64 pairs of bits to
00A02820                          7482                              * do for a 32 bit result
00A02820  082B 0000 0DF8          7483      BTST        #0,FAC1_e(a3)       * test exponent odd/even
00A02826  6606                    7484      BNE.s       LAB_SQE2            * if odd only 1 shift first time
00A02828                          7485  
00A02828                          7486  LAB_SQE1
00A02828  D080                    7487      ADD.l       d0,d0               * shift highest bit of number ..
00A0282A  D582                    7488      ADDX.l  d2,d2               * .. into remainder .. never overflows
00A0282C  D281                    7489      ADD.l       d1,d1               * root = root * 2 .. never overflows
00A0282E                          7490  LAB_SQE2
00A0282E  D080                    7491      ADD.l       d0,d0               * shift highest bit of number ..
00A02830  D582                    7492      ADDX.l  d2,d2               * .. into remainder .. never overflows
00A02832                          7493  
00A02832  2801                    7494      MOVE.l  d1,d4               * copy root
00A02834  D884                    7495      ADD.l       d4,d4               * 2n
00A02836  5284                    7496      ADDQ.l  #1,d4               * 2n+1
00A02838                          7497  
00A02838  B484                    7498      CMP.l       d4,d2               * compare 2n+1 to remainder
00A0283A  6504                    7499      BCS.s       LAB_SQNS            * skip sub if remainder smaller
00A0283C                          7500  
00A0283C  9484                    7501      SUB.l       d4,d2               * subtract temp from remainder
00A0283E  5281                    7502      ADDQ.l  #1,d1               * increment root
00A02840                          7503  LAB_SQNS
00A02840  51CB FFE6               7504      DBF     d3,LAB_SQE1         * loop if not all done
00A02844                          7505  
00A02844  2741 0DF4               7506      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00A02848  102B 0DF8               7507      MOVE.b  FAC1_e(a3),d0       * get exponent (d0 is clear here)
00A0284C  0440 0080               7508      SUB.w       #$80,d0         * normalise
00A02850  E248                    7509      LSR.w       #1,d0               * /2
00A02852  6402                    7510      BCC.s       LAB_SQNA            * skip increment if carry clear
00A02854                          7511  
00A02854  5240                    7512      ADDQ.w  #1,d0               * add bit zero back in (allow for half shift)
00A02856                          7513  LAB_SQNA
00A02856  0640 0080               7514      ADD.w       #$80,d0         * re-bias to $80
00A0285A  1740 0DF8               7515      MOVE.b  d0,FAC1_e(a3)       * save it
00A0285E  4CDF 001E               7516      MOVEM.l (sp)+,d1-d4         * restore registers
00A02862  6000 F0A8               7517      BRA     LAB_24D5            * normalise FAC1 & return
00A02866                          7518  
00A02866                          7519  
00A02866                          7520  *************************************************************************************
00A02866                          7521  *
00A02866                          7522  * perform VARPTR()
00A02866                          7523  
00A02866                          7524  LAB_VARPTR
00A02866  101D                    7525      MOVE.b  (a5)+,d0            * increment pointer
00A02868                          7526  LAB_VARCALL
00A02868  6100 E756               7527      BSR     LAB_GVAR            * get variable address in a0
00A0286C  6100 E530               7528      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00A02870  2008                    7529      MOVE.l  a0,d0               * copy the variable address
00A02872  6000 EA3C               7530      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A02876                          7531  
00A02876                          7532  
00A02876                          7533  *************************************************************************************
00A02876                          7534  *
00A02876                          7535  * perform RAMBASE
00A02876                          7536  
00A02876                          7537  LAB_RAM
00A02876  41EB 0C64               7538      LEA     ram_base(a3),a0     * get start of EhBASIC RAM
00A0287A  2008                    7539      MOVE.l  a0,d0               * copy it
00A0287C  6000 EA32               7540      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00A02880                          7541  
00A02880                          7542  
00A02880                          7543  *************************************************************************************
00A02880                          7544  *
00A02880                          7545  * perform PI
00A02880                          7546  
00A02880                          7547  LAB_PI
00A02880  277C C90FDAA2 0DF4      7548      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * pi mantissa (32 bit)
00A02888  377C 8200 0DF8          7549      MOVE.w  #$8200,FAC1_e(a3)       * pi exponent and sign
00A0288E  4E75                    7550      RTS
00A02890                          7551  
00A02890                          7552  
00A02890                          7553  *************************************************************************************
00A02890                          7554  *
00A02890                          7555  * perform TWOPI
00A02890                          7556  
00A02890                          7557  LAB_TWOPI
00A02890  277C C90FDAA2 0DF4      7558      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * 2pi mantissa (32 bit)
00A02898  377C 8300 0DF8          7559      MOVE.w  #$8300,FAC1_e(a3)       * 2pi exponent and sign
00A0289E  4E75                    7560      RTS
00A028A0                          7561  
00A028A0                          7562  
00A028A0                          7563  *************************************************************************************
00A028A0                          7564  *
00A028A0                          7565  * get ASCII string equivalent into FAC1 as integer32 or float
00A028A0                          7566  
00A028A0                          7567  * entry is with a5 pointing to the first character of the string
00A028A0                          7568  * exit with a5 pointing to the first character after the string
00A028A0                          7569  
00A028A0                          7570  * d0 is character
00A028A0                          7571  * d1 is mantissa
00A028A0                          7572  * d2 is partial and table mantissa
00A028A0                          7573  * d3 is mantissa exponent (decimal & binary)
00A028A0                          7574  * d4 is decimal exponent
00A028A0                          7575  
00A028A0                          7576  * get FAC1 from string
00A028A0                          7577  * this routine now handles hex and binary values from strings
00A028A0                          7578  * starting with "$" and "%" respectively
00A028A0                          7579  
00A028A0                          7580  LAB_2887
00A028A0  48E7 7C00               7581      MOVEM.l d1-d5,-(sp)         * save registers
00A028A4  7200                    7582      MOVEQ       #$00,d1         * clear temp accumulator
00A028A6  2601                    7583      MOVE.l  d1,d3               * set mantissa decimal exponent count
00A028A8  2801                    7584      MOVE.l  d1,d4               * clear decimal exponent
00A028AA  1741 0DF9               7585      MOVE.b  d1,FAC1_s(a3)       * clear sign byte
00A028AE  1741 0E19               7586      MOVE.b  d1,Dtypef(a3)       * set float data type
00A028B2  1741 0E13               7587      MOVE.b  d1,expneg(a3)       * clear exponent sign
00A028B6  6100 E4FA               7588      BSR     LAB_GBYT            * get first byte back
00A028BA  653C                    7589      BCS.s       LAB_28FE            * go get floating if 1st character numeric
00A028BC                          7590  
00A028BC  B03C 002D               7591      CMP.b       #'-',d0         * or is it -ve number
00A028C0  6608                    7592      BNE.s       LAB_289A            * branch if not
00A028C2                          7593  
00A028C2  177C 00FF 0DF9          7594      MOVE.b  #$FF,FAC1_s(a3)     * set sign byte
00A028C8  6006                    7595      BRA.s       LAB_289C            * now go scan & check for hex/bin/int
00A028CA                          7596  
00A028CA                          7597  LAB_289A
00A028CA                          7598                              * first character wasn't numeric or -
00A028CA  B03C 002B               7599      CMP.b       #'+',d0         * compare with '+'
00A028CE  6606                    7600      BNE.s       LAB_289D            * branch if not '+' (go check for '.'/hex/binary
00A028D0                          7601                              * /integer)
00A028D0                          7602      
00A028D0                          7603  LAB_289C
00A028D0                          7604                              * was "+" or "-" to start, so get next character
00A028D0  6100 E4DE               7605      BSR     LAB_IGBY            * increment & scan memory
00A028D4  6522                    7606      BCS.s       LAB_28FE            * branch if numeric character
00A028D6                          7607  
00A028D6                          7608  LAB_289D
00A028D6  B03C 002E               7609      CMP.b       #'.',d0         * else compare with '.'
00A028DA  6700 0092               7610      BEQ     LAB_2904            * branch if '.'
00A028DE                          7611  
00A028DE                          7612                              * code here for hex/binary/integer numbers
00A028DE  B03C 0024               7613      CMP.b       #'$',d0         * compare with '$'
00A028E2  6700 010A               7614      BEQ     LAB_CHEX            * branch if '$'
00A028E6                          7615  
00A028E6  B03C 0025               7616      CMP.b       #'%',d0         * else compare with '%'
00A028EA  6700 0164               7617      BEQ     LAB_CBIN            * branch if '%'
00A028EE                          7618  
00A028EE  6000 008C               7619      BRA     LAB_2Y01            * not #.$%& so return 0
00A028F2                          7620  
00A028F2                          7621  LAB_28FD
00A028F2  6100 E4BC               7622      BSR     LAB_IGBY            * get next character
00A028F6  646C                    7623      BCC.s       LAB_2902            * exit loop if not a digit
00A028F8                          7624  
00A028F8                          7625  LAB_28FE
00A028F8  6100 01A8               7626      BSR     d1x10               * multiply d1 by 10 and add character
00A028FC  64F4                    7627      BCC.s       LAB_28FD            * loop for more if no overflow
00A028FE                          7628  
00A028FE                          7629  LAB_28FF
00A028FE                          7630                              * overflowed mantissa, count 10s exponent
00A028FE  5283                    7631      ADDQ.l  #1,d3               * increment mantissa decimal exponent count
00A02900  6100 E4AE               7632      BSR     LAB_IGBY            * get next character
00A02904  65F8                    7633      BCS.s       LAB_28FF            * loop while numeric character
00A02906                          7634  
00A02906                          7635                              * done overflow, now flush fraction or do E
00A02906  B03C 002E               7636      CMP.b       #'.',d0         * else compare with '.'
00A0290A  6606                    7637      BNE.s       LAB_2901            * branch if not '.'
00A0290C                          7638  
00A0290C                          7639  LAB_2900
00A0290C                          7640                              * flush remaining fraction digits
00A0290C  6100 E4A2               7641      BSR     LAB_IGBY            * get next character
00A02910  65FA                    7642      BCS     LAB_2900            * loop while numeric character
00A02912                          7643  
00A02912                          7644  LAB_2901
00A02912                          7645                              * done number, only (possible) exponent remains
00A02912  B03C 0045               7646      CMP.b       #'E',d0         * else compare with 'E'
00A02916  6664                    7647      BNE.s       LAB_2Y01            * if not 'E' all done, go evaluate
00A02918                          7648  
00A02918                          7649                              * process exponent
00A02918  6100 E496               7650      BSR     LAB_IGBY            * get next character
00A0291C  6528                    7651      BCS.s       LAB_2X04            * branch if digit
00A0291E                          7652  
00A0291E  B03C 002D               7653      CMP.b       #'-',d0         * or is it -ve number
00A02922  6706                    7654      BEQ.s       LAB_2X01            * branch if so
00A02924                          7655  
00A02924  B03C 00B3               7656      CMP.b       #TK_MINUS,d0        * or is it -ve number
00A02928  6608                    7657      BNE.s       LAB_2X02            * branch if not
00A0292A                          7658  
00A0292A                          7659  LAB_2X01
00A0292A  177C 00FF 0E13          7660      MOVE.b  #$FF,expneg(a3)     * set exponent sign
00A02930  600E                    7661      BRA.s       LAB_2X03            * now go scan & check exponent
00A02932                          7662  
00A02932                          7663  LAB_2X02
00A02932  B03C 002B               7664      CMP.b       #'+',d0         * or is it +ve number
00A02936  6708                    7665      BEQ.s       LAB_2X03            * branch if so
00A02938                          7666  
00A02938  B03C 00B2               7667      CMP.b       #TK_PLUS,d0         * or is it +ve number
00A0293C  6600 D834               7668      BNE     LAB_SNER            * wasn't - + TK_MINUS TK_PLUS or # so do error
00A02940                          7669  
00A02940                          7670  LAB_2X03
00A02940  6100 E46E               7671      BSR     LAB_IGBY            * get next character
00A02944  6436                    7672      BCC.s       LAB_2Y01            * if not digit all done, go evaluate
00A02946                          7673  LAB_2X04
00A02946  C8FC 000A               7674      MULU        #10,d4          * multiply decimal exponent by 10
00A0294A  C0BC 000000FF           7675      AND.l       #$FF,d0         * mask character
00A02950  0400 0030               7676      SUB.b       #'0',d0         * convert to value
00A02954  D880                    7677      ADD.l       d0,d4               * add to decimal exponent
00A02956  B83C 0030               7678      CMP.b       #48,d4          * compare with decimal exponent limit+10
00A0295A  6FE4                    7679      BLE.s       LAB_2X03            * loop if no overflow/underflow
00A0295C                          7680  
00A0295C                          7681  LAB_2X05
00A0295C                          7682                              * exponent value has overflowed
00A0295C  6100 E452               7683      BSR     LAB_IGBY            * get next character
00A02960  65FA                    7684      BCS.s       LAB_2X05            * loop while numeric digit
00A02962                          7685  
00A02962  6018                    7686      BRA.s       LAB_2Y01            * all done, go evaluate
00A02964                          7687  
00A02964                          7688  LAB_2902
00A02964  B03C 002E               7689      CMP.b       #'.',d0         * else compare with '.'
00A02968  6704                    7690      BEQ.s       LAB_2904            * branch if was '.'
00A0296A                          7691  
00A0296A  60A6                    7692      BRA.s       LAB_2901            * branch if not '.' (go check/do 'E')
00A0296C                          7693  
00A0296C                          7694  LAB_2903
00A0296C  5383                    7695      SUBQ.l  #1,d3               * decrement mantissa decimal exponent
00A0296E                          7696  LAB_2904
00A0296E                          7697                              * was dp so get fraction part
00A0296E  6100 E440               7698      BSR     LAB_IGBY            * get next character
00A02972  649E                    7699      BCC.s       LAB_2901            * exit loop if not a digit (go check/do 'E')
00A02974                          7700  
00A02974  6100 012C               7701      BSR     d1x10               * multiply d1 by 10 and add character
00A02978  64F2                    7702      BCC.s       LAB_2903            * loop for more if no overflow
00A0297A                          7703  
00A0297A  6090                    7704      BRA.s       LAB_2900            * else go flush remaining fraction part
00A0297C                          7705  
00A0297C                          7706  LAB_2Y01
00A0297C                          7707                              * now evaluate result
00A0297C  4A2B 0E13               7708      TST.b       expneg(a3)          * test exponent sign
00A02980  6A02                    7709      BPL.s       LAB_2Y02            * branch if sign positive
00A02982                          7710  
00A02982  4484                    7711      NEG.l       d4              * negate decimal exponent
00A02984                          7712  LAB_2Y02
00A02984  D883                    7713      ADD.l       d3,d4               * add mantissa decimal exponent
00A02986  7620                    7714      MOVEQ       #32,d3          * set up max binary exponent
00A02988  4A81                    7715      TST.l       d1              * test mantissa
00A0298A  6752                    7716      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00A0298C                          7717  
00A0298C  6B08                    7718      BMI.s       LAB_2Y04            * branch if already mormalised
00A0298E                          7719  
00A0298E  5383                    7720      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00A02990                          7721  LAB_2Y03
00A02990  D281                    7722      ADD.l       d1,d1               * shift mantissa
00A02992  5BCB FFFC               7723      DBMI        d3,LAB_2Y03         * decrement & loop if not normalised
00A02996                          7724  
00A02996                          7725                              * ensure not too big or small
00A02996                          7726  LAB_2Y04
00A02996  B8BC 00000026           7727      CMP.l       #38,d4          * compare decimal exponent with max exponent
00A0299C  6E00 D7C4               7728      BGT     LAB_OFER            * if greater do overflow error and warm start
00A029A0                          7729  
00A029A0  B8BC FFFFFFDA           7730      CMP.l       #-38,d4         * compare decimal exponent with min exponent
00A029A6  6D34                    7731      BLT.s       LAB_ret0            * if less just return zero
00A029A8                          7732  
00A029A8  4484                    7733      NEG.l       d4              * negate decimal exponent to go right way
00A029AA  C9FC 0006               7734      MULS        #6,d4               * 6 bytes per entry
00A029AE  2F08                    7735      MOVE.l  a0,-(sp)            * save register
00A029B0  41FA 0210               7736      LEA     LAB_P_10(pc),a0     * point to table
00A029B4  1770 4000 0E00          7737      MOVE.b  (a0,d4.w),FAC2_e(a3)    * copy exponent for multiply
00A029BA  2770 4002 0DFC          7738      MOVE.l  2(a0,d4.w),FAC2_m(a3)   * copy table mantissa
00A029C0  205F                    7739      MOVE.l  (sp)+,a0            * restore register
00A029C2                          7740  
00A029C2  0A03 0080               7741      EORI.b  #$80,d3         * normalise input exponent
00A029C6  2741 0DF4               7742      MOVE.l  d1,FAC1_m(a3)       * save input mantissa
00A029CA  1743 0DF8               7743      MOVE.b  d3,FAC1_e(a3)       * save input exponent
00A029CE  176B 0DF9 0E02          7744      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * set sign as sign compare
00A029D4                          7745  
00A029D4  4CDF 003E               7746      MOVEM.l (sp)+,d1-d5         * restore registers
00A029D8  6000 F05A               7747      BRA     LAB_MULTIPLY        * go multiply input by table
00A029DC                          7748  
00A029DC                          7749  LAB_ret0
00A029DC  7200                    7750      MOVEQ       #0,d1               * clear mantissa
00A029DE                          7751  LAB_rtn0
00A029DE  2601                    7752      MOVE.l  d1,d3               * clear exponent
00A029E0  1743 0DF8               7753      MOVE.b  d3,FAC1_e(a3)       * save exponent
00A029E4  2741 0DF4               7754      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00A029E8  4CDF 003E               7755      MOVEM.l (sp)+,d1-d5         * restore registers
00A029EC  4E75                    7756      RTS
00A029EE                          7757  
00A029EE                          7758  
00A029EE                          7759  *************************************************************************************
00A029EE                          7760  *
00A029EE                          7761  * $ for hex add-on
00A029EE                          7762  
00A029EE                          7763  * gets here if the first character was "$" for hex
00A029EE                          7764  * get hex number
00A029EE                          7765  
00A029EE                          7766  LAB_CHEX
00A029EE  177C 0040 0E19          7767      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00A029F4  7620                    7768      MOVEQ       #32,d3          * set up max binary exponent
00A029F6                          7769  LAB_CHXX
00A029F6  6100 E3B8               7770      BSR     LAB_IGBY            * increment & scan memory
00A029FA  6514                    7771      BCS.s       LAB_ISHN            * branch if numeric character
00A029FC                          7772  
00A029FC  803C 0020               7773      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00A02A00  0400 0061               7774      SUB.b       #'a',d0         * subtract "a"
00A02A04  652A                    7775      BCS.s       LAB_CHX3            * exit if <"a"
00A02A06                          7776  
00A02A06  B03C 0006               7777      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00A02A0A  6424                    7778      BCC.s       LAB_CHX3            * exit if >"f"
00A02A0C                          7779  
00A02A0C  0600 003A               7780      ADD.b       #$3A,d0         * convert to nibble+"0"
00A02A10                          7781  LAB_ISHN
00A02A10  616C                    7782      BSR.s       d1x16               * multiply d1 by 16 and add the character
00A02A12  64E2                    7783      BCC.s       LAB_CHXX            * loop for more if no overflow
00A02A14                          7784  
00A02A14                          7785                              * overflowed mantissa, count 16s exponent
00A02A14                          7786  LAB_CHX1
00A02A14  5883                    7787      ADDQ.l  #4,d3               * increment mantissa exponent count
00A02A16  6900 D74A               7788      BVS     LAB_OFER            * do overflow error if overflowed
00A02A1A                          7789  
00A02A1A  6100 E394               7790      BSR     LAB_IGBY            * get next character
00A02A1E  65F4                    7791      BCS.s       LAB_CHX1            * loop while numeric character
00A02A20                          7792  
00A02A20  803C 0020               7793      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00A02A24  0400 0061               7794      SUB.b       #'a',d0         * subtract "a"
00A02A28  6506                    7795      BCS.s       LAB_CHX3            * exit if <"a"
00A02A2A                          7796  
00A02A2A  B03C 0006               7797      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00A02A2E  65E4                    7798      BCS.s       LAB_CHX1            * loop if <="f"
00A02A30                          7799  
00A02A30                          7800                              * now return value
00A02A30                          7801  LAB_CHX3
00A02A30  4A81                    7802      TST.l       d1              * test mantissa
00A02A32  67AA                    7803      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00A02A34                          7804  
00A02A34  6B08                    7805      BMI.s       LAB_exxf            * branch if already mormalised
00A02A36                          7806  
00A02A36  5383                    7807      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00A02A38                          7808  LAB_CHX2
00A02A38  D281                    7809      ADD.l       d1,d1               * shift mantissa
00A02A3A  5BCB FFFC               7810      DBMI        d3,LAB_CHX2         * decrement & loop if not normalised
00A02A3E                          7811  
00A02A3E                          7812  LAB_exxf
00A02A3E  0A03 0080               7813      EORI.b  #$80,d3         * normalise exponent
00A02A42  1743 0DF8               7814      MOVE.b  d3,FAC1_e(a3)       * save exponent
00A02A46  2741 0DF4               7815      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00A02A4A  4CDF 003E               7816      MOVEM.l (sp)+,d1-d5         * restore registers
00A02A4E                          7817  RTS_024
00A02A4E  4E75                    7818      RTS
00A02A50                          7819  
00A02A50                          7820  
00A02A50                          7821  *************************************************************************************
00A02A50                          7822  *
00A02A50                          7823  * % for binary add-on
00A02A50                          7824  
00A02A50                          7825  * gets here if the first character was "%" for binary
00A02A50                          7826  * get binary number
00A02A50                          7827  
00A02A50                          7828  LAB_CBIN
00A02A50  177C 0040 0E19          7829      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00A02A56  7620                    7830      MOVEQ       #32,d3          * set up max binary exponent
00A02A58                          7831  LAB_CBXN
00A02A58  6100 E356               7832      BSR     LAB_IGBY            * increment & scan memory
00A02A5C  64D2                    7833      BCC.s       LAB_CHX3            * if not numeric character go return value
00A02A5E                          7834  
00A02A5E  B03C 0032               7835      CMP.b       #'2',d0         * compare with "2" (max+1)
00A02A62  64CC                    7836      BCC.s       LAB_CHX3            * if >="2" go return value
00A02A64                          7837  
00A02A64  2401                    7838      MOVE.l  d1,d2               * copy value
00A02A66  6124                    7839      BSR.s       d1x02               * multiply d1 by 2 and add character
00A02A68  64EE                    7840      BCC.s       LAB_CBXN            * loop for more if no overflow
00A02A6A                          7841  
00A02A6A                          7842                              * overflowed mantissa, count 2s exponent
00A02A6A                          7843  LAB_CBX1
00A02A6A  5283                    7844      ADDQ.l  #1,d3               * increment mantissa exponent count
00A02A6C  6900 D6F4               7845      BVS     LAB_OFER            * do overflow error if overflowed
00A02A70                          7846  
00A02A70  6100 E33E               7847      BSR     LAB_IGBY            * get next character
00A02A74  64BA                    7848      BCC.s       LAB_CHX3            * if not numeric character go return value
00A02A76                          7849  
00A02A76  B03C 0032               7850      CMP.b       #'2',d0         * compare with "2" (max+1)
00A02A7A  65EE                    7851      BCS.s       LAB_CBX1            * loop if <"2"
00A02A7C                          7852  
00A02A7C  60B2                    7853      BRA.s       LAB_CHX3            * if not numeric character go return value
00A02A7E                          7854  
00A02A7E                          7855  * half way decent times 16 and times 2 with overflow checks
00A02A7E                          7856  
00A02A7E                          7857  d1x16
00A02A7E  2401                    7858      MOVE.l  d1,d2               * copy value
00A02A80  D482                    7859      ADD.l       d2,d2               * times two
00A02A82  65CA                    7860      BCS.s       RTS_024         * return if overflow
00A02A84                          7861  
00A02A84  D482                    7862      ADD.l       d2,d2               * times four
00A02A86  65C6                    7863      BCS.s       RTS_024         * return if overflow
00A02A88                          7864  
00A02A88  D482                    7865      ADD.l       d2,d2               * times eight
00A02A8A  65C2                    7866      BCS.s       RTS_024         * return if overflow
00A02A8C                          7867  
00A02A8C                          7868  d1x02
00A02A8C  D482                    7869      ADD.l       d2,d2               * times sixteen (ten/two)
00A02A8E  65BE                    7870      BCS.s       RTS_024         * return if overflow
00A02A90                          7871  
00A02A90                          7872  * now add in new digit
00A02A90                          7873  
00A02A90  C0BC 000000FF           7874      AND.l       #$FF,d0         * mask character
00A02A96  0400 0030               7875      SUB.b       #'0',d0         * convert to value
00A02A9A  D480                    7876      ADD.l       d0,d2               * add to result
00A02A9C  65B0                    7877      BCS.s       RTS_024         * return if overflow, it should never ever do
00A02A9E                          7878                              * this
00A02A9E                          7879  
00A02A9E  2202                    7880      MOVE.l  d2,d1               * copy result
00A02AA0  4E75                    7881      RTS
00A02AA2                          7882  
00A02AA2                          7883  * half way decent times 10 with overflow checks
00A02AA2                          7884  
00A02AA2                          7885  d1x10
00A02AA2  2401                    7886      MOVE.l  d1,d2               * copy value
00A02AA4  D482                    7887      ADD.l       d2,d2               * times two
00A02AA6  6508                    7888      BCS.s       RTS_025         * return if overflow
00A02AA8                          7889  
00A02AA8  D482                    7890      ADD.l       d2,d2               * times four
00A02AAA  6504                    7891      BCS.s       RTS_025         * return if overflow
00A02AAC                          7892  
00A02AAC  D481                    7893      ADD.l       d1,d2               * times five
00A02AAE  64DC                    7894      BCC.s       d1x02               * do times two and add in new digit if ok
00A02AB0                          7895  
00A02AB0                          7896  RTS_025
00A02AB0  4E75                    7897      RTS
00A02AB2                          7898  
00A02AB2                          7899  
00A02AB2                          7900  *************************************************************************************
00A02AB2                          7901  *
00A02AB2                          7902  * token values needed for BASIC
00A02AB2                          7903  
00A02AB2  =00000080               7904  TK_END      EQU $80         * $80
00A02AB2  =00000081               7905  TK_FOR      EQU TK_END+1        * $81
00A02AB2  =00000082               7906  TK_NEXT     EQU TK_FOR+1        * $82
00A02AB2  =00000083               7907  TK_DATA     EQU TK_NEXT+1       * $83
00A02AB2  =00000084               7908  TK_INPUT        EQU TK_DATA+1       * $84
00A02AB2  =00000085               7909  TK_DIM      EQU TK_INPUT+1      * $85
00A02AB2  =00000086               7910  TK_READ     EQU TK_DIM+1        * $86
00A02AB2  =00000087               7911  TK_LET      EQU TK_READ+1       * $87
00A02AB2  =00000088               7912  TK_DEC      EQU TK_LET+1        * $88
00A02AB2  =00000089               7913  TK_GOTO     EQU TK_DEC+1        * $89
00A02AB2  =0000008A               7914  TK_RUN      EQU TK_GOTO+1       * $8A
00A02AB2  =0000008B               7915  TK_IF           EQU TK_RUN+1        * $8B
00A02AB2  =0000008C               7916  TK_RESTORE      EQU TK_IF+1         * $8C
00A02AB2  =0000008D               7917  TK_GOSUB        EQU TK_RESTORE+1        * $8D
00A02AB2  =0000008E               7918  TK_RETURN       EQU TK_GOSUB+1      * $8E
00A02AB2  =0000008F               7919  TK_REM      EQU TK_RETURN+1     * $8F
00A02AB2  =00000090               7920  TK_STOP     EQU TK_REM+1        * $90
00A02AB2  =00000091               7921  TK_ON           EQU TK_STOP+1       * $91
00A02AB2  =00000092               7922  TK_NULL     EQU TK_ON+1         * $92
00A02AB2  =00000093               7923  TK_INC      EQU TK_NULL+1       * $93
00A02AB2  =00000094               7924  TK_WAIT     EQU TK_INC+1        * $94
00A02AB2  =00000095               7925  TK_LOAD     EQU TK_WAIT+1       * $95
00A02AB2  =00000096               7926  TK_SAVE     EQU TK_LOAD+1       * $96
00A02AB2  =00000097               7927  TK_DEF      EQU TK_SAVE+1       * $97
00A02AB2  =00000098               7928  TK_POKE     EQU TK_DEF+1        * $98
00A02AB2  =00000099               7929  TK_DOKE     EQU TK_POKE+1       * $99
00A02AB2  =0000009A               7930  TK_LOKE     EQU TK_DOKE+1       * $9A
00A02AB2  =0000009B               7931  TK_CALL     EQU TK_LOKE+1       * $9B
00A02AB2  =0000009C               7932  TK_DO           EQU TK_CALL+1       * $9C
00A02AB2  =0000009D               7933  TK_LOOP     EQU TK_DO+1         * $9D
00A02AB2  =0000009E               7934  TK_PRINT        EQU TK_LOOP+1       * $9E
00A02AB2  =0000009F               7935  TK_CONT     EQU TK_PRINT+1      * $9F
00A02AB2  =000000A0               7936  TK_LIST     EQU TK_CONT+1       * $A0
00A02AB2  =000000A1               7937  TK_CLEAR        EQU TK_LIST+1       * $A1
00A02AB2  =000000A2               7938  TK_NEW      EQU TK_CLEAR+1      * $A2
00A02AB2  =000000A3               7939  TK_WIDTH        EQU TK_NEW+1        * $A3
00A02AB2  =000000A4               7940  TK_GET      EQU TK_WIDTH+1      * $A4
00A02AB2  =000000A5               7941  TK_SWAP     EQU TK_GET+1        * $A5
00A02AB2  =000000A6               7942  TK_BITSET       EQU TK_SWAP+1       * $A6
00A02AB2  =000000A7               7943  TK_BITCLR       EQU TK_BITSET+1     * $A7
00A02AB2  =000000A8               7944  TK_TAB      EQU TK_BITCLR+1     * $A8
00A02AB2  =000000A9               7945  TK_ELSE     EQU TK_TAB+1        * $A9
00A02AB2  =000000AA               7946  TK_TO           EQU TK_ELSE+1       * $AA
00A02AB2  =000000AB               7947  TK_FN           EQU TK_TO+1         * $AB
00A02AB2  =000000AC               7948  TK_SPC      EQU TK_FN+1         * $AC
00A02AB2  =000000AD               7949  TK_THEN     EQU TK_SPC+1        * $AD
00A02AB2  =000000AE               7950  TK_NOT      EQU TK_THEN+1       * $AE
00A02AB2  =000000AF               7951  TK_STEP     EQU TK_NOT+1        * $AF
00A02AB2  =000000B0               7952  TK_UNTIL        EQU TK_STEP+1       * $B0
00A02AB2  =000000B1               7953  TK_WHILE        EQU TK_UNTIL+1      * $B1
00A02AB2  =000000B2               7954  TK_PLUS     EQU TK_WHILE+1      * $B2
00A02AB2  =000000B3               7955  TK_MINUS        EQU TK_PLUS+1       * $B3
00A02AB2  =000000B4               7956  TK_MULT     EQU TK_MINUS+1      * $B4
00A02AB2  =000000B5               7957  TK_DIV      EQU TK_MULT+1       * $B5
00A02AB2  =000000B6               7958  TK_POWER        EQU TK_DIV+1        * $B6
00A02AB2  =000000B7               7959  TK_AND      EQU TK_POWER+1      * $B7
00A02AB2  =000000B8               7960  TK_EOR      EQU TK_AND+1        * $B8
00A02AB2  =000000B9               7961  TK_OR           EQU TK_EOR+1        * $B9
00A02AB2  =000000BA               7962  TK_RSHIFT       EQU TK_OR+1         * $BA
00A02AB2  =000000BB               7963  TK_LSHIFT       EQU TK_RSHIFT+1     * $BB
00A02AB2  =000000BC               7964  TK_GT           EQU TK_LSHIFT+1     * $BC
00A02AB2  =000000BD               7965  TK_EQUAL        EQU TK_GT+1         * $BD
00A02AB2  =000000BE               7966  TK_LT           EQU TK_EQUAL+1      * $BE
00A02AB2  =000000BF               7967  TK_SGN      EQU TK_LT+1         * $BF
00A02AB2  =000000C0               7968  TK_INT      EQU TK_SGN+1        * $C0
00A02AB2  =000000C1               7969  TK_ABS      EQU TK_INT+1        * $C1
00A02AB2  =000000C2               7970  TK_USR      EQU TK_ABS+1        * $C2
00A02AB2  =000000C3               7971  TK_FRE      EQU TK_USR+1        * $C3
00A02AB2  =000000C4               7972  TK_POS      EQU TK_FRE+1        * $C4
00A02AB2  =000000C5               7973  TK_SQR      EQU TK_POS+1        * $C5
00A02AB2  =000000C6               7974  TK_RND      EQU TK_SQR+1        * $C6
00A02AB2  =000000C7               7975  TK_LOG      EQU TK_RND+1        * $C7
00A02AB2  =000000C8               7976  TK_EXP      EQU TK_LOG+1        * $C8
00A02AB2  =000000C9               7977  TK_COS      EQU TK_EXP+1        * $C9
00A02AB2  =000000CA               7978  TK_SIN      EQU TK_COS+1        * $CA
00A02AB2  =000000CB               7979  TK_TAN      EQU TK_SIN+1        * $CB
00A02AB2  =000000CC               7980  TK_ATN      EQU TK_TAN+1        * $CC
00A02AB2  =000000CD               7981  TK_PEEK     EQU TK_ATN+1        * $CD
00A02AB2  =000000CE               7982  TK_DEEK     EQU TK_PEEK+1       * $CE
00A02AB2  =000000CF               7983  TK_LEEK     EQU TK_DEEK+1       * $CF
00A02AB2  =000000D0               7984  TK_LEN      EQU TK_LEEK+1       * $D0
00A02AB2  =000000D1               7985  TK_STRS     EQU TK_LEN+1        * $D1
00A02AB2  =000000D2               7986  TK_VAL      EQU TK_STRS+1       * $D2
00A02AB2  =000000D3               7987  TK_ASC      EQU TK_VAL+1        * $D3
00A02AB2  =000000D4               7988  TK_UCASES       EQU TK_ASC+1        * $D4
00A02AB2  =000000D5               7989  TK_LCASES       EQU TK_UCASES+1     * $D5
00A02AB2  =000000D6               7990  TK_CHRS     EQU TK_LCASES+1     * $D6
00A02AB2  =000000D7               7991  TK_HEXS     EQU TK_CHRS+1       * $D7
00A02AB2  =000000D8               7992  TK_BINS     EQU TK_HEXS+1       * $D8
00A02AB2  =000000D9               7993  TK_BITTST       EQU TK_BINS+1       * $D9
00A02AB2  =000000DA               7994  TK_MAX      EQU TK_BITTST+1     * $DA
00A02AB2  =000000DB               7995  TK_MIN      EQU TK_MAX+1        * $DB
00A02AB2  =000000DC               7996  TK_RAM      EQU TK_MIN+1        * $DC
00A02AB2  =000000DD               7997  TK_PI           EQU TK_RAM+1        * $DD
00A02AB2  =000000DE               7998  TK_TWOPI        EQU TK_PI+1         * $DE
00A02AB2  =000000DF               7999  TK_VPTR     EQU TK_TWOPI+1      * $DF
00A02AB2  =000000E0               8000  TK_SADD     EQU TK_VPTR+1       * $E0
00A02AB2  =000000E1               8001  TK_LEFTS        EQU TK_SADD+1       * $E1
00A02AB2  =000000E2               8002  TK_RIGHTS       EQU TK_LEFTS+1      * $E2
00A02AB2  =000000E3               8003  TK_MIDS     EQU TK_RIGHTS+1     * $E3
00A02AB2  =000000E4               8004  TK_USINGS       EQU TK_MIDS+1       * $E4
00A02AB2                          8005  
00A02AB2                          8006  
00A02AB2                          8007  *************************************************************************************
00A02AB2                          8008  *
00A02AB2                          8009  * binary to unsigned decimal table
00A02AB2                          8010  
00A02AB2                          8011  Bin2dec
00A02AB2= 3B9ACA00                8012      dc.l    $3B9ACA00               * 1000000000
00A02AB6= 05F5E100                8013      dc.l    $05F5E100               * 100000000
00A02ABA= 00989680                8014      dc.l    $00989680               * 10000000
00A02ABE= 000F4240                8015      dc.l    $000F4240               * 1000000
00A02AC2= 000186A0                8016      dc.l    $000186A0               * 100000
00A02AC6= 00002710                8017      dc.l    $00002710               * 10000
00A02ACA= 000003E8                8018      dc.l    $000003E8               * 1000
00A02ACE= 00000064                8019      dc.l    $00000064               * 100
00A02AD2= 0000000A                8020      dc.l    $0000000A               * 10
00A02AD6= 00000000                8021      dc.l    $00000000               * 0 end marker
00A02ADA                          8022  
00A02ADA                          8023  LAB_RSED
00A02ADA= 332E3232                8024      dc.l    $332E3232               * 858665522
00A02ADE                          8025  
00A02ADE                          8026  * string to value exponent table
00A02ADE                          8027  
00A02ADE= FF00                    8028      dc.w    255<<8              * 10**38
00A02AE0= 96769951                8029      dc.l    $96769951
00A02AE4= FB00                    8030      dc.w    251<<8              * 10**37
00A02AE6= F0BDC21B                8031      dc.l    $F0BDC21B
00A02AEA= F800                    8032      dc.w    248<<8              * 10**36
00A02AEC= C097CE7C                8033      dc.l    $C097CE7C
00A02AF0= F500                    8034      dc.w    245<<8              * 10**35
00A02AF2= 9A130B96                8035      dc.l    $9A130B96
00A02AF6= F100                    8036      dc.w    241<<8              * 10**34
00A02AF8= F684DF57                8037      dc.l    $F684DF57
00A02AFC= EE00                    8038      dc.w    238<<8              * 10**33
00A02AFE= C5371912                8039      dc.l    $C5371912
00A02B02= EB00                    8040      dc.w    235<<8              * 10**32
00A02B04= 9DC5ADA8                8041      dc.l    $9DC5ADA8
00A02B08= E700                    8042      dc.w    231<<8              * 10**31
00A02B0A= FC6F7C40                8043      dc.l    $FC6F7C40
00A02B0E= E400                    8044      dc.w    228<<8              * 10**30
00A02B10= C9F2C9CD                8045      dc.l    $C9F2C9CD
00A02B14= E100                    8046      dc.w    225<<8              * 10**29
00A02B16= A18F07D7                8047      dc.l    $A18F07D7
00A02B1A= DE00                    8048      dc.w    222<<8              * 10**28
00A02B1C= 813F3979                8049      dc.l    $813F3979
00A02B20= DA00                    8050      dc.w    218<<8              * 10**27
00A02B22= CECB8F28                8051      dc.l    $CECB8F28
00A02B26= D700                    8052      dc.w    215<<8              * 10**26
00A02B28= A56FA5BA                8053      dc.l    $A56FA5BA
00A02B2C= D400                    8054      dc.w    212<<8              * 10**25
00A02B2E= 84595161                8055      dc.l    $84595161
00A02B32= D000                    8056      dc.w    208<<8              * 10**24
00A02B34= D3C21BCF                8057      dc.l    $D3C21BCF
00A02B38= CD00                    8058      dc.w    205<<8              * 10**23
00A02B3A= A968163F                8059      dc.l    $A968163F
00A02B3E= CA00                    8060      dc.w    202<<8              * 10**22
00A02B40= 87867832                8061      dc.l    $87867832
00A02B44= C600                    8062      dc.w    198<<8              * 10**21
00A02B46= D8D726B7                8063      dc.l    $D8D726B7
00A02B4A= C300                    8064      dc.w    195<<8              * 10**20
00A02B4C= AD78EBC6                8065      dc.l    $AD78EBC6
00A02B50= C000                    8066      dc.w    192<<8              * 10**19
00A02B52= 8AC72305                8067      dc.l    $8AC72305
00A02B56= BC00                    8068      dc.w    188<<8              * 10**18
00A02B58= DE0B6B3A                8069      dc.l    $DE0B6B3A
00A02B5C= B900                    8070      dc.w    185<<8              * 10**17
00A02B5E= B1A2BC2F                8071      dc.l    $B1A2BC2F
00A02B62= B600                    8072      dc.w    182<<8              * 10**16
00A02B64= 8E1BC9BF                8073      dc.l    $8E1BC9BF
00A02B68= B200                    8074      dc.w    178<<8              * 10**15
00A02B6A= E35FA932                8075      dc.l    $E35FA932
00A02B6E= AF00                    8076      dc.w    175<<8              * 10**14
00A02B70= B5E620F5                8077      dc.l    $B5E620F5
00A02B74= AC00                    8078      dc.w    172<<8              * 10**13
00A02B76= 9184E72A                8079      dc.l    $9184E72A
00A02B7A= A800                    8080      dc.w    168<<8              * 10**12
00A02B7C= E8D4A510                8081      dc.l    $E8D4A510
00A02B80= A500                    8082      dc.w    165<<8              * 10**11
00A02B82= BA43B740                8083      dc.l    $BA43B740
00A02B86= A200                    8084      dc.w    162<<8              * 10**10
00A02B88= 9502F900                8085      dc.l    $9502F900
00A02B8C= 9E00                    8086      dc.w    158<<8              * 10**9
00A02B8E= EE6B2800                8087      dc.l    $EE6B2800
00A02B92= 9B00                    8088      dc.w    155<<8              * 10**8
00A02B94= BEBC2000                8089      dc.l    $BEBC2000
00A02B98= 9800                    8090      dc.w    152<<8              * 10**7
00A02B9A= 98968000                8091      dc.l    $98968000
00A02B9E= 9400                    8092      dc.w    148<<8              * 10**6
00A02BA0= F4240000                8093      dc.l    $F4240000
00A02BA4= 9100                    8094      dc.w    145<<8              * 10**5
00A02BA6= C3500000                8095      dc.l    $C3500000
00A02BAA= 8E00                    8096      dc.w    142<<8              * 10**4
00A02BAC= 9C400000                8097      dc.l    $9C400000
00A02BB0= 8A00                    8098      dc.w    138<<8              * 10**3
00A02BB2= FA000000                8099      dc.l    $FA000000
00A02BB6= 8700                    8100      dc.w    135<<8              * 10**2
00A02BB8= C8000000                8101      dc.l    $C8000000
00A02BBC= 8400                    8102      dc.w    132<<8              * 10**1
00A02BBE= A0000000                8103      dc.l    $A0000000
00A02BC2                          8104  LAB_P_10
00A02BC2= 8100                    8105      dc.w    129<<8              * 10**0
00A02BC4= 80000000                8106      dc.l    $80000000
00A02BC8= 7D00                    8107      dc.w    125<<8              * 10**-1
00A02BCA= CCCCCCCD                8108      dc.l    $CCCCCCCD
00A02BCE= 7A00                    8109      dc.w    122<<8              * 10**-2
00A02BD0= A3D70A3D                8110      dc.l    $A3D70A3D
00A02BD4= 7700                    8111      dc.w    119<<8              * 10**-3
00A02BD6= 83126E98                8112      dc.l    $83126E98
00A02BDA= 7300                    8113      dc.w    115<<8              * 10**-4
00A02BDC= D1B71759                8114      dc.l    $D1B71759
00A02BE0= 7000                    8115      dc.w    112<<8              * 10**-5
00A02BE2= A7C5AC47                8116      dc.l    $A7C5AC47
00A02BE6= 6D00                    8117      dc.w    109<<8              * 10**-6
00A02BE8= 8637BD06                8118      dc.l    $8637BD06
00A02BEC= 6900                    8119      dc.w    105<<8              * 10**-7
00A02BEE= D6BF94D6                8120      dc.l    $D6BF94D6
00A02BF2= 6600                    8121      dc.w    102<<8              * 10**-8
00A02BF4= ABCC7712                8122      dc.l    $ABCC7712
00A02BF8= 6300                    8123      dc.w    99<<8                   * 10**-9
00A02BFA= 89705F41                8124      dc.l    $89705F41
00A02BFE= 5F00                    8125      dc.w    95<<8                   * 10**-10
00A02C00= DBE6FECF                8126      dc.l    $DBE6FECF
00A02C04= 5C00                    8127      dc.w    92<<8                   * 10**-11
00A02C06= AFEBFF0C                8128      dc.l    $AFEBFF0C
00A02C0A= 5900                    8129      dc.w    89<<8                   * 10**-12
00A02C0C= 8CBCCC09                8130      dc.l    $8CBCCC09
00A02C10= 5500                    8131      dc.w    85<<8                   * 10**-13
00A02C12= E12E1342                8132      dc.l    $E12E1342
00A02C16= 5200                    8133      dc.w    82<<8                   * 10**-14
00A02C18= B424DC35                8134      dc.l    $B424DC35
00A02C1C= 4F00                    8135      dc.w    79<<8                   * 10**-15
00A02C1E= 901D7CF7                8136      dc.l    $901D7CF7
00A02C22= 4B00                    8137      dc.w    75<<8                   * 10**-16
00A02C24= E69594BF                8138      dc.l    $E69594BF
00A02C28= 4800                    8139      dc.w    72<<8                   * 10**-17
00A02C2A= B877AA32                8140      dc.l    $B877AA32
00A02C2E= 4500                    8141      dc.w    69<<8                   * 10**-18
00A02C30= 9392EE8F                8142      dc.l    $9392EE8F
00A02C34= 4100                    8143      dc.w    65<<8                   * 10**-19
00A02C36= EC1E4A7E                8144      dc.l    $EC1E4A7E
00A02C3A= 3E00                    8145      dc.w    62<<8                   * 10**-20
00A02C3C= BCE50865                8146      dc.l    $BCE50865
00A02C40= 3B00                    8147      dc.w    59<<8                   * 10**-21
00A02C42= 971DA050                8148      dc.l    $971DA050
00A02C46= 3700                    8149      dc.w    55<<8                   * 10**-22
00A02C48= F1C90081                8150      dc.l    $F1C90081
00A02C4C= 3400                    8151      dc.w    52<<8                   * 10**-23
00A02C4E= C16D9A01                8152      dc.l    $C16D9A01
00A02C52= 3100                    8153      dc.w    49<<8                   * 10**-24
00A02C54= 9ABE14CD                8154      dc.l    $9ABE14CD
00A02C58= 2D00                    8155      dc.w    45<<8                   * 10**-25
00A02C5A= F79687AE                8156      dc.l    $F79687AE
00A02C5E= 2A00                    8157      dc.w    42<<8                   * 10**-26
00A02C60= C6120625                8158      dc.l    $C6120625
00A02C64= 2700                    8159      dc.w    39<<8                   * 10**-27
00A02C66= 9E74D1B8                8160      dc.l    $9E74D1B8
00A02C6A= 2300                    8161      dc.w    35<<8                   * 10**-28
00A02C6C= FD87B5F3                8162      dc.l    $FD87B5F3
00A02C70= 2000                    8163      dc.w    32<<8                   * 10**-29
00A02C72= CAD2F7F5                8164      dc.l    $CAD2F7F5
00A02C76= 1D00                    8165      dc.w    29<<8                   * 10**-30
00A02C78= A2425FF7                8166      dc.l    $A2425FF7
00A02C7C= 1A00                    8167      dc.w    26<<8                   * 10**-31
00A02C7E= 81CEB32C                8168      dc.l    $81CEB32C
00A02C82= 1600                    8169      dc.w    22<<8                   * 10**-32
00A02C84= CFB11EAD                8170      dc.l    $CFB11EAD
00A02C88= 1300                    8171      dc.w    19<<8                   * 10**-33
00A02C8A= A6274BBE                8172      dc.l    $A6274BBE
00A02C8E= 1000                    8173      dc.w    16<<8                   * 10**-34
00A02C90= 84EC3C98                8174      dc.l    $84EC3C98
00A02C94= 0C00                    8175      dc.w    12<<8                   * 10**-35
00A02C96= D4AD2DC0                8176      dc.l    $D4AD2DC0
00A02C9A= 0900                    8177      dc.w    9<<8                    * 10**-36
00A02C9C= AA242499                8178      dc.l    $AA242499
00A02CA0= 0600                    8179      dc.w    6<<8                    * 10**-37
00A02CA2= 881CEA14                8180      dc.l    $881CEA14
00A02CA6= 0200                    8181      dc.w    2<<8                    * 10**-38
00A02CA8= D9C7DCED                8182      dc.l    $D9C7DCED
00A02CAC                          8183  
00A02CAC                          8184  
00A02CAC                          8185  *************************************************************************************
00A02CAC                          8186  *
00A02CAC                          8187  * table of constants for cordic SIN/COS/TAN calculations
00A02CAC                          8188  * constants are un normalised fractions and are atn(2^-i)/2pi
00A02CAC                          8189  
00A02CAC= 4DBA76D4                8190      dc.l    $4DBA76D4               * SIN/COS multiply constant
00A02CB0                          8191  TAB_SNCO
00A02CB0= 20000000                8192      dc.l    $20000000               * atn(2^0)/2pi
00A02CB4= 12E4051E                8193      dc.l    $12E4051E               * atn(2^1)/2pi
00A02CB8= 09FB385C                8194      dc.l    $09FB385C               * atn(2^2)/2pi
00A02CBC= 051111D5                8195      dc.l    $051111D5               * atn(2^3)/2pi
00A02CC0= 028B0D44                8196      dc.l    $028B0D44               * atn(2^4)/2pi
00A02CC4= 0145D7E2                8197      dc.l    $0145D7E2               * atn(2^5)/2pi
00A02CC8= 00A2F61F                8198      dc.l    $00A2F61F               * atn(2^6)/2pi
00A02CCC= 00517C56                8199      dc.l    $00517C56               * atn(2^7)/2pi
00A02CD0= 0028BE54                8200      dc.l    $0028BE54               * atn(2^8)/2pi
00A02CD4= 00145F2F                8201      dc.l    $00145F2F               * atn(2^9)/2pi
00A02CD8= 000A2F99                8202      dc.l    $000A2F99               * atn(2^10)/2pi
00A02CDC= 000517CD                8203      dc.l    $000517CD               * atn(2^11)/2pi
00A02CE0= 00028BE7                8204      dc.l    $00028BE7               * atn(2^12)/2pi
00A02CE4= 000145F4                8205      dc.l    $000145F4               * atn(2^13)/2pi
00A02CE8= 0000A2FA                8206      dc.l    $0000A2FA               * atn(2^14)/2pi
00A02CEC= 0000517D                8207      dc.l    $0000517D               * atn(2^15)/2pi
00A02CF0= 000028BF                8208      dc.l    $000028BF               * atn(2^16)/2pi
00A02CF4= 00001460                8209      dc.l    $00001460               * atn(2^17)/2pi
00A02CF8= 00000A30                8210      dc.l    $00000A30               * atn(2^18)/2pi
00A02CFC= 00000518                8211      dc.l    $00000518               * atn(2^19)/2pi
00A02D00= 0000028C                8212      dc.l    $0000028C               * atn(2^20)/2pi
00A02D04= 00000146                8213      dc.l    $00000146               * atn(2^21)/2pi
00A02D08= 000000A3                8214      dc.l    $000000A3               * atn(2^22)/2pi
00A02D0C= 00000052                8215      dc.l    $00000052               * atn(2^23)/2pi
00A02D10= 00000029                8216      dc.l    $00000029               * atn(2^24)/2pi
00A02D14= 00000015                8217      dc.l    $00000015               * atn(2^25)/2pi
00A02D18= 0000000B                8218      dc.l    $0000000B               * atn(2^26)/2pi
00A02D1C= 00000006                8219      dc.l    $00000006               * atn(2^27)/2pi
00A02D20= 00000003                8220      dc.l    $00000003               * atn(2^28)/2pi
00A02D24= 00000002                8221      dc.l    $00000002               * atn(2^29)/2pi
00A02D28= 00000001                8222      dc.l    $00000001               * atn(2^30)/2pi
00A02D2C= 00000001                8223      dc.l    $00000001               * atn(2^31)/2pi
00A02D30                          8224  
00A02D30                          8225  
00A02D30                          8226  *************************************************************************************
00A02D30                          8227  *
00A02D30                          8228  * table of constants for cordic ATN calculation
00A02D30                          8229  * constants are normalised to two integer bits and are atn(2^-i)
00A02D30                          8230  
00A02D30                          8231  TAB_ATNC
00A02D30= 1DAC6705                8232      dc.l    $1DAC6705               * atn(2^-1)
00A02D34= 0FADBAFD                8233      dc.l    $0FADBAFD               * atn(2^-2)
00A02D38= 07F56EA7                8234      dc.l    $07F56EA7               * atn(2^-3)
00A02D3C= 03FEAB77                8235      dc.l    $03FEAB77               * atn(2^-4)
00A02D40= 01FFD55C                8236      dc.l    $01FFD55C               * atn(2^-5)
00A02D44= 00FFFAAB                8237      dc.l    $00FFFAAB               * atn(2^-6)
00A02D48= 007FFF55                8238      dc.l    $007FFF55               * atn(2^-7)
00A02D4C= 003FFFEB                8239      dc.l    $003FFFEB               * atn(2^-8)
00A02D50= 001FFFFD                8240      dc.l    $001FFFFD               * atn(2^-9)
00A02D54= 00100000                8241      dc.l    $00100000               * atn(2^-10)
00A02D58= 00080000                8242      dc.l    $00080000               * atn(2^-11)
00A02D5C= 00040000                8243      dc.l    $00040000               * atn(2^-12)
00A02D60= 00020000                8244      dc.l    $00020000               * atn(2^-13)
00A02D64= 00010000                8245      dc.l    $00010000               * atn(2^-14)
00A02D68= 00008000                8246      dc.l    $00008000               * atn(2^-15)
00A02D6C= 00004000                8247      dc.l    $00004000               * atn(2^-16)
00A02D70= 00002000                8248      dc.l    $00002000               * atn(2^-17)
00A02D74= 00001000                8249      dc.l    $00001000               * atn(2^-18)
00A02D78= 00000800                8250      dc.l    $00000800               * atn(2^-19)
00A02D7C= 00000400                8251      dc.l    $00000400               * atn(2^-20)
00A02D80= 00000200                8252      dc.l    $00000200               * atn(2^-21)
00A02D84= 00000100                8253      dc.l    $00000100               * atn(2^-22)
00A02D88= 00000080                8254      dc.l    $00000080               * atn(2^-23)
00A02D8C= 00000040                8255      dc.l    $00000040               * atn(2^-24)
00A02D90= 00000020                8256      dc.l    $00000020               * atn(2^-25)
00A02D94= 00000010                8257      dc.l    $00000010               * atn(2^-26)
00A02D98= 00000008                8258      dc.l    $00000008               * atn(2^-27)
00A02D9C= 00000004                8259      dc.l    $00000004               * atn(2^-28)
00A02DA0= 00000002                8260      dc.l    $00000002               * atn(2^-29)
00A02DA4= 00000001                8261      dc.l    $00000001               * atn(2^-30)
00A02DA8                          8262  LAB_1D96
00A02DA8= 00000000                8263      dc.l    $00000000               * atn(2^-31)
00A02DAC= 00000000                8264      dc.l    $00000000               * atn(2^-32)
00A02DB0                          8265  
00A02DB0                          8266  * constants are normalised to n integer bits and are tanh(2^-i)
00A02DB0  =00000002               8267  n   equ 2
00A02DB0                          8268  TAB_HTHET
00A02DB0= 2327D4F4                8269      dc.l    $8C9F53D0>>n            * atnh(2^-1)    .549306144
00A02DB4= 1058AEFA                8270      dc.l    $4162BBE8>>n            * atnh(2^-2)    .255412812
00A02DB8= 080AC48E                8271      dc.l    $202B1238>>n            * atnh(2^-3)
00A02DBC= 04015622                8272      dc.l    $10055888>>n            * atnh(2^-4)
00A02DC0= 02002AB0                8273      dc.l    $0800AAC0>>n            * atnh(2^-5)
00A02DC4= 01000554                8274      dc.l    $04001550>>n            * atnh(2^-6)
00A02DC8= 008000AA                8275      dc.l    $020002A8>>n            * atnh(2^-7)
00A02DCC= 00400014                8276      dc.l    $01000050>>n            * atnh(2^-8)
00A02DD0= 00200002                8277      dc.l    $00800008>>n            * atnh(2^-9)
00A02DD4= 00100000                8278      dc.l    $00400000>>n            * atnh(2^-10)
00A02DD8= 00080000                8279      dc.l    $00200000>>n            * atnh(2^-11)
00A02DDC= 00040000                8280      dc.l    $00100000>>n            * atnh(2^-12)
00A02DE0= 00020000                8281      dc.l    $00080000>>n            * atnh(2^-13)
00A02DE4= 00010000                8282      dc.l    $00040000>>n            * atnh(2^-14)
00A02DE8= 00008000                8283      dc.l    $00020000>>n            * atnh(2^-15)
00A02DEC= 00004000                8284      dc.l    $00010000>>n            * atnh(2^-16)
00A02DF0= 00002000                8285      dc.l    $00008000>>n            * atnh(2^-17)
00A02DF4= 00001000                8286      dc.l    $00004000>>n            * atnh(2^-18)
00A02DF8= 00000800                8287      dc.l    $00002000>>n            * atnh(2^-19)
00A02DFC= 00000400                8288      dc.l    $00001000>>n            * atnh(2^-20)
00A02E00= 00000200                8289      dc.l    $00000800>>n            * atnh(2^-21)
00A02E04= 00000100                8290      dc.l    $00000400>>n            * atnh(2^-22)
00A02E08= 00000080                8291      dc.l    $00000200>>n            * atnh(2^-23)
00A02E0C= 00000040                8292      dc.l    $00000100>>n            * atnh(2^-24)
00A02E10= 00000020                8293      dc.l    $00000080>>n            * atnh(2^-25)
00A02E14= 00000010                8294      dc.l    $00000040>>n            * atnh(2^-26)
00A02E18= 00000008                8295      dc.l    $00000020>>n            * atnh(2^-27)
00A02E1C= 00000004                8296      dc.l    $00000010>>n            * atnh(2^-28)
00A02E20= 00000002                8297      dc.l    $00000008>>n            * atnh(2^-29)
00A02E24= 00000001                8298      dc.l    $00000004>>n            * atnh(2^-30)
00A02E28= 00000000                8299      dc.l    $00000002>>n            * atnh(2^-31)
00A02E2C= 00000000                8300      dc.l    $00000001>>n            * atnh(2^-32)
00A02E30                          8301  
00A02E30  =26A3D110               8302  KFCTSEED    equ $9A8F4441>>n        * $26A3D110
00A02E30                          8303  
00A02E30                          8304  
00A02E30                          8305  *************************************************************************************
00A02E30                          8306  *
00A02E30                          8307  * command vector table
00A02E30                          8308  
00A02E30                          8309  LAB_CTBL
00A02E30= D7B2                    8310      dc.w    LAB_END-LAB_CTBL            * END
00A02E32= D6E6                    8311      dc.w    LAB_FOR-LAB_CTBL            * FOR
00A02E34= DD52                    8312      dc.w    LAB_NEXT-LAB_CTBL           * NEXT
00A02E36= D906                    8313      dc.w    LAB_DATA-LAB_CTBL           * DATA
00A02E38= DC46                    8314      dc.w    LAB_INPUT-LAB_CTBL      * INPUT
00A02E3A= E122                    8315      dc.w    LAB_DIM-LAB_CTBL            * DIM
00A02E3C= DC6C                    8316      dc.w    LAB_READ-LAB_CTBL           * READ
00A02E3E= DA78                    8317      dc.w    LAB_LET-LAB_CTBL            * LET
00A02E40= DA16                    8318      dc.w    LAB_DEC-LAB_CTBL            * DEC   
00A02E42= D86E                    8319      dc.w    LAB_GOTO-LAB_CTBL           * GOTO
00A02E44= D836                    8320      dc.w    LAB_RUN-LAB_CTBL            * RUN
00A02E46= D92E                    8321      dc.w    LAB_IF-LAB_CTBL         * IF
00A02E48= D7E0                    8322      dc.w    LAB_RESTORE-LAB_CTBL        * RESTORE
00A02E4A= D85C                    8323      dc.w    LAB_GOSUB-LAB_CTBL      * GOSUB
00A02E4C= D8F2                    8324      dc.w    LAB_RETURN-LAB_CTBL     * RETURN
00A02E4E= D99C                    8325      dc.w    LAB_REM-LAB_CTBL            * REM
00A02E50= D7BA                    8326      dc.w    LAB_STOP-LAB_CTBL           * STOP
00A02E52= D9A4                    8327      dc.w    LAB_ON-LAB_CTBL         * ON
00A02E54= D80E                    8328      dc.w    LAB_NULL-LAB_CTBL           * NULL
00A02E56= DA1C                    8329      dc.w    LAB_INC-LAB_CTBL            * INC   
00A02E58= EA28                    8330      dc.w    LAB_WAIT-LAB_CTBL           * WAIT
00A02E5A= EA16                    8331      dc.w    LAB_LOAD-LAB_CTBL           * LOAD
00A02E5C= EA1A                    8332      dc.w    LAB_SAVE-LAB_CTBL           * SAVE
00A02E5E= E4B2                    8333      dc.w    LAB_DEF-LAB_CTBL            * DEF
00A02E60= E996                    8334      dc.w    LAB_POKE-LAB_CTBL           * POKE
00A02E62= E9C6                    8335      dc.w    LAB_DOKE-LAB_CTBL           * DOKE
00A02E64= E9CC                    8336      dc.w    LAB_LOKE-LAB_CTBL           * LOKE
00A02E66= EA1E                    8337      dc.w    LAB_CALL-LAB_CTBL           * CALL
00A02E68= D84A                    8338      dc.w    LAB_DO-LAB_CTBL         * DO    
00A02E6A= D89C                    8339      dc.w    LAB_LOOP-LAB_CTBL           * LOOP
00A02E6C= DB0C                    8340      dc.w    LAB_PRINT-LAB_CTBL      * PRINT
00A02E6E= D818                    8341      dc.w    LAB_CONT-LAB_CTBL           * CONT
00A02E70= D630                    8342      dc.w    LAB_LIST-LAB_CTBL           * LIST
00A02E72= D62C                    8343      dc.w    LAB_CLEAR-LAB_CTBL      * CLEAR
00A02E74= D5DC                    8344      dc.w    LAB_NEW-LAB_CTBL            * NEW
00A02E76= F954                    8345      dc.w    LAB_WDTH-LAB_CTBL           * WIDTH
00A02E78= DAD2                    8346      dc.w    LAB_GET-LAB_CTBL            * GET
00A02E7A= E9E0                    8347      dc.w    LAB_SWAP-LAB_CTBL           * SWAP
00A02E7C= F49E                    8348      dc.w    LAB_BITSET-LAB_CTBL     * BITSET
00A02E7E= F4AE                    8349      dc.w    LAB_BITCLR-LAB_CTBL     * BITCLR
00A02E80                          8350  
00A02E80                          8351  
00A02E80                          8352  *************************************************************************************
00A02E80                          8353  *
00A02E80                          8354  * function pre process routine table
00A02E80                          8355  
00A02E80                          8356  LAB_FTPP
00A02E80= DFD0                    8357      dc.w    LAB_PPFN-LAB_FTPP           * SGN(n)    process numeric expression in ()
00A02E82= DFD0                    8358      dc.w    LAB_PPFN-LAB_FTPP           * INT(n)        "
00A02E84= DFD0                    8359      dc.w    LAB_PPFN-LAB_FTPP           * ABS(n)        "
00A02E86= DDD2                    8360      dc.w    LAB_EVEZ-LAB_FTPP           * USR(x)    process any expression
00A02E88= DF1A                    8361      dc.w    LAB_1BF7-LAB_FTPP           * FRE(x)    process any expression in ()
00A02E8A= DF1A                    8362      dc.w    LAB_1BF7-LAB_FTPP           * POS(x)        "
00A02E8C= DFD0                    8363      dc.w    LAB_PPFN-LAB_FTPP           * SQR(n)    process numeric expression in ()
00A02E8E= DFD0                    8364      dc.w    LAB_PPFN-LAB_FTPP           * RND(n)        "
00A02E90= DFD0                    8365      dc.w    LAB_PPFN-LAB_FTPP           * LOG(n)        "
00A02E92= DFD0                    8366      dc.w    LAB_PPFN-LAB_FTPP           * EXP(n)        "
00A02E94= DFD0                    8367      dc.w    LAB_PPFN-LAB_FTPP           * COS(n)        "
00A02E96= DFD0                    8368      dc.w    LAB_PPFN-LAB_FTPP           * SIN(n)        "
00A02E98= DFD0                    8369      dc.w    LAB_PPFN-LAB_FTPP           * TAN(n)        "
00A02E9A= DFD0                    8370      dc.w    LAB_PPFN-LAB_FTPP           * ATN(n)        "
00A02E9C= DFD0                    8371      dc.w    LAB_PPFN-LAB_FTPP           * PEEK(n)       "
00A02E9E= DFD0                    8372      dc.w    LAB_PPFN-LAB_FTPP           * DEEK(n)       "
00A02EA0= DFD0                    8373      dc.w    LAB_PPFN-LAB_FTPP           * LEEK(n)       "
00A02EA2= DFC2                    8374      dc.w    LAB_PPFS-LAB_FTPP           * LEN($)    process string expression in ()
00A02EA4= DFD0                    8375      dc.w    LAB_PPFN-LAB_FTPP           * STR$(n)   process numeric expression in ()
00A02EA6= DFC2                    8376      dc.w    LAB_PPFS-LAB_FTPP           * VAL($)    process string expression in ()
00A02EA8= DFC2                    8377      dc.w    LAB_PPFS-LAB_FTPP           * ASC($)        "
00A02EAA= DFC2                    8378      dc.w    LAB_PPFS-LAB_FTPP           * UCASE$($)     "
00A02EAC= DFC2                    8379      dc.w    LAB_PPFS-LAB_FTPP           * LCASE$($)     "
00A02EAE= DFD0                    8380      dc.w    LAB_PPFN-LAB_FTPP           * CHR$(n)   process numeric expression in ()
00A02EB0= E00A                    8381      dc.w    LAB_BHSS-LAB_FTPP           * HEX$()    bin/hex pre process
00A02EB2= E00A                    8382      dc.w    LAB_BHSS-LAB_FTPP           * BIN$()        "
00A02EB4= 0000                    8383      dc.w    $0000                   * BITTST()  none
00A02EB6= 0000                    8384      dc.w    $0000                   * MAX()     "
00A02EB8= 0000                    8385      dc.w    $0000                   * MIN()     "
00A02EBA= DFDE                    8386      dc.w    LAB_PPBI-LAB_FTPP           * RAMBASE   advance pointer
00A02EBC= DFDE                    8387      dc.w    LAB_PPBI-LAB_FTPP           * PI            "
00A02EBE= DFDE                    8388      dc.w    LAB_PPBI-LAB_FTPP           * TWOPI     "
00A02EC0= 0000                    8389      dc.w    $0000                   * VARPTR()  none
00A02EC2= 0000                    8390      dc.w    $0000                   * SADD()        "
00A02EC4= DFE8                    8391      dc.w    LAB_LRMS-LAB_FTPP           * LEFT$()   process string expression
00A02EC6= DFE8                    8392      dc.w    LAB_LRMS-LAB_FTPP           * RIGHT$()      "
00A02EC8= DFE8                    8393      dc.w    LAB_LRMS-LAB_FTPP           * MID$()        "
00A02ECA= DDD2                    8394      dc.w    LAB_EVEZ-LAB_FTPP           * USING$(x) process any expression
00A02ECC                          8395  
00A02ECC                          8396  
00A02ECC                          8397  *************************************************************************************
00A02ECC                          8398  *
00A02ECC                          8399  * action addresses for functions
00A02ECC                          8400  
00A02ECC                          8401  LAB_FTBL
00A02ECC= ED54                    8402      dc.w    LAB_SGN-LAB_FTBL            * SGN()
00A02ECE= EDD6                    8403      dc.w    LAB_INT-LAB_FTBL            * INT()
00A02ED0= ED66                    8404      dc.w    LAB_ABS-LAB_FTBL            * ABS()
00A02ED2= E972                    8405      dc.w    LAB_USR-LAB_FTBL            * USR()
00A02ED4= E3CE                    8406      dc.w    LAB_FRE-LAB_FTBL            * FRE()
00A02ED6= E400                    8407      dc.w    LAB_POS-LAB_FTBL            * POS()
00A02ED8= F938                    8408      dc.w    LAB_SQR-LAB_FTBL            * SQR()
00A02EDA= F21E                    8409      dc.w    LAB_RND-LAB_FTBL            * RND()
00A02EDC= EA76                    8410      dc.w    LAB_LOG-LAB_FTBL            * LOG()
00A02EDE= F104                    8411      dc.w    LAB_EXP-LAB_FTBL            * EXP()
00A02EE0= F272                    8412      dc.w    LAB_COS-LAB_FTBL            * COS()
00A02EE2= F28A                    8413      dc.w    LAB_SIN-LAB_FTBL            * SIN()
00A02EE4= F250                    8414      dc.w    LAB_TAN-LAB_FTBL            * TAN()
00A02EE6= F350                    8415      dc.w    LAB_ATN-LAB_FTBL            * ATN()
00A02EE8= E8EE                    8416      dc.w    LAB_PEEK-LAB_FTBL           * PEEK()
00A02EEA= E900                    8417      dc.w    LAB_DEEK-LAB_FTBL           * DEEK()
00A02EEC= E916                    8418      dc.w    LAB_LEEK-LAB_FTBL           * LEEK()
00A02EEE= E832                    8419      dc.w    LAB_LENS-LAB_FTBL           * LEN()
00A02EF0= E4F6                    8420      dc.w    LAB_STRS-LAB_FTBL           * STR$()
00A02EF2= E876                    8421      dc.w    LAB_VAL-LAB_FTBL            * VAL()
00A02EF4= E83A                    8422      dc.w    LAB_ASC-LAB_FTBL            * ASC()
00A02EF6= E7E8                    8423      dc.w    LAB_UCASE-LAB_FTBL      * UCASE$()
00A02EF8= E7B8                    8424      dc.w    LAB_LCASE-LAB_FTBL      * LCASE$()
00A02EFA= E720                    8425      dc.w    LAB_CHRS-LAB_FTBL           * CHR$()
00A02EFC= F7DA                    8426      dc.w    LAB_HEXS-LAB_FTBL           * HEX$()
00A02EFE= F788                    8427      dc.w    LAB_BINS-LAB_FTBL           * BIN$()
00A02F00= F422                    8428      dc.w    LAB_BTST-LAB_FTBL           * BITTST()
00A02F02= F846                    8429      dc.w    LAB_MAX-LAB_FTBL            * MAX()
00A02F04= F85C                    8430      dc.w    LAB_MIN-LAB_FTBL            * MIN()
00A02F06= F9AA                    8431      dc.w    LAB_RAM-LAB_FTBL            * RAMBASE
00A02F08= F9B4                    8432      dc.w    LAB_PI-LAB_FTBL         * PI
00A02F0A= F9C4                    8433      dc.w    LAB_TWOPI-LAB_FTBL      * TWOPI
00A02F0C= F99A                    8434      dc.w    LAB_VARPTR-LAB_FTBL     * VARPTR()
00A02F0E= E81A                    8435      dc.w    LAB_SADD-LAB_FTBL           * SADD()
00A02F10= E730                    8436      dc.w    LAB_LEFT-LAB_FTBL           * LEFT$()
00A02F12= E744                    8437      dc.w    LAB_RIGHT-LAB_FTBL      * RIGHT$()
00A02F14= E774                    8438      dc.w    LAB_MIDS-LAB_FTBL           * MID$()
00A02F16= F450                    8439      dc.w    LAB_USINGS-LAB_FTBL     * USING$()
00A02F18                          8440  
00A02F18                          8441  
00A02F18                          8442  *************************************************************************************
00A02F18                          8443  *
00A02F18                          8444  * hierarchy and action addresses for operator
00A02F18                          8445  
00A02F18                          8446  LAB_OPPT
00A02F18= 0079                    8447      dc.w    $0079                   * +
00A02F1A= E978                    8448      dc.w    LAB_ADD-LAB_OPPT
00A02F1C= 0079                    8449      dc.w    $0079                   * -
00A02F1E= E964                    8450      dc.w    LAB_SUBTRACT-LAB_OPPT
00A02F20= 007B                    8451      dc.w    $007B                   * *
00A02F22= EB1C                    8452      dc.w    LAB_MULTIPLY-LAB_OPPT
00A02F24= 007B                    8453      dc.w    $007B                   * /
00A02F26= EBA8                    8454      dc.w    LAB_DIVIDE-LAB_OPPT
00A02F28= 007F                    8455      dc.w    $007F                   * ^
00A02F2A= F002                    8456      dc.w    LAB_POWER-LAB_OPPT
00A02F2C= 0050                    8457      dc.w    $0050                   * AND
00A02F2E= DFB2                    8458      dc.w    LAB_AND-LAB_OPPT
00A02F30= 0046                    8459      dc.w    $0046                   * EOR
00A02F32= DFA2                    8460      dc.w    LAB_EOR-LAB_OPPT
00A02F34= 0046                    8461      dc.w    $0046                   * OR
00A02F36= DFAA                    8462      dc.w    LAB_OR-LAB_OPPT
00A02F38= 0056                    8463      dc.w    $0056                   * >>
00A02F3A= E056                    8464      dc.w    LAB_RSHIFT-LAB_OPPT
00A02F3C= 0056                    8465      dc.w    $0056                   * <<
00A02F3E= E046                    8466      dc.w    LAB_LSHIFT-LAB_OPPT
00A02F40= 007D                    8467      dc.w    $007D                   * >
00A02F42= F066                    8468      dc.w    LAB_GTHAN-LAB_OPPT      * used to evaluate -n
00A02F44= 005A                    8469      dc.w    $005A                   * =
00A02F46= DFC8                    8470      dc.w    LAB_EQUAL-LAB_OPPT      * used to evaluate NOT
00A02F48= 0064                    8471      dc.w    $0064                   * <
00A02F4A= DFD2                    8472      dc.w    LAB_LTHAN-LAB_OPPT
00A02F4C                          8473  
00A02F4C                          8474  
00A02F4C                          8475  *************************************************************************************
00A02F4C                          8476  *
00A02F4C                          8477  * misc constants
00A02F4C                          8478  
00A02F4C                          8479  * This table is used in converting numbers to ASCII.
00A02F4C                          8480  * first four entries for expansion to 9.25 digits
00A02F4C                          8481  
00A02F4C                          8482  LAB_2A9A
00A02F4C= FFF0BDC0                8483      dc.l    $FFF0BDC0               * -1000000
00A02F50= 000186A0                8484      dc.l    $000186A0               * 100000
00A02F54= FFFFD8F0                8485      dc.l    $FFFFD8F0               * -10000
00A02F58= 000003E8                8486      dc.l    $000003E8               * 1000
00A02F5C= FFFFFF9C                8487      dc.l    $FFFFFF9C               * -100
00A02F60= 0000000A                8488      dc.l    $0000000A               * 10
00A02F64= FFFFFFFF                8489      dc.l    $FFFFFFFF               * -1
00A02F68                          8490  LAB_2A9B
00A02F68                          8491  
00A02F68                          8492  
00A02F68                          8493  *************************************************************************************
00A02F68                          8494  *
00A02F68                          8495  * new keyword tables
00A02F68                          8496  
00A02F68                          8497  * offsets to keyword tables
00A02F68                          8498  
00A02F68                          8499  TAB_CHRT
00A02F68= 0000                    8500      dc.w    TAB_STAR-TAB_STAR           * "*"   $2A
00A02F6A= 0002                    8501      dc.w    TAB_PLUS-TAB_STAR           * "+"   $2B
00A02F6C= FFFF                    8502      dc.w    -1                  * "," $2C no keywords
00A02F6E= 0004                    8503      dc.w    TAB_MNUS-TAB_STAR           * "-"   $2D
00A02F70= FFFF                    8504      dc.w    -1                  * "." $2E no keywords
00A02F72= 0006                    8505      dc.w    TAB_SLAS-TAB_STAR           * "/"   $2F
00A02F74= FFFF                    8506      dc.w    -1                  * "0" $30 no keywords
00A02F76= FFFF                    8507      dc.w    -1                  * "1" $31 no keywords
00A02F78= FFFF                    8508      dc.w    -1                  * "2" $32 no keywords
00A02F7A= FFFF                    8509      dc.w    -1                  * "3" $33 no keywords
00A02F7C= FFFF                    8510      dc.w    -1                  * "4" $34 no keywords
00A02F7E= FFFF                    8511      dc.w    -1                  * "5" $35 no keywords
00A02F80= FFFF                    8512      dc.w    -1                  * "6" $36 no keywords
00A02F82= FFFF                    8513      dc.w    -1                  * "7" $37 no keywords
00A02F84= FFFF                    8514      dc.w    -1                  * "8" $38 no keywords
00A02F86= FFFF                    8515      dc.w    -1                  * "9" $39 no keywords
00A02F88= FFFF                    8516      dc.w    -1                  * ";" $3A no keywords
00A02F8A= FFFF                    8517      dc.w    -1                  * ":" $3B no keywords
00A02F8C= 0008                    8518      dc.w    TAB_LESS-TAB_STAR           * "<"   $3C
00A02F8E= 000C                    8519      dc.w    TAB_EQUL-TAB_STAR           * "="   $3D
00A02F90= 000E                    8520      dc.w    TAB_MORE-TAB_STAR           * ">"   $3E
00A02F92= 0012                    8521      dc.w    TAB_QEST-TAB_STAR           * "?"   $3F
00A02F94= FFFF                    8522      dc.w    -1                  * "@" $40 no keywords
00A02F96= 0014                    8523      dc.w    TAB_ASCA-TAB_STAR           * "A"   $41
00A02F98= 0024                    8524      dc.w    TAB_ASCB-TAB_STAR           * "B"   $42
00A02F9A= 003D                    8525      dc.w    TAB_ASCC-TAB_STAR           * "C"   $43
00A02F9C= 0054                    8526      dc.w    TAB_ASCD-TAB_STAR           * "D"   $44
00A02F9E= 006D                    8527      dc.w    TAB_ASCE-TAB_STAR           * "E"   $45
00A02FA0= 007C                    8528      dc.w    TAB_ASCF-TAB_STAR           * "F"   $46
00A02FA2= 0086                    8529      dc.w    TAB_ASCG-TAB_STAR           * "G"   $47
00A02FA4= 0093                    8530      dc.w    TAB_ASCH-TAB_STAR           * "H"   $48
00A02FA6= 0099                    8531      dc.w    TAB_ASCI-TAB_STAR           * "I"   $49
00A02FA8= FFFF                    8532      dc.w    -1                  * "J" $4A no keywords
00A02FAA= FFFF                    8533      dc.w    -1                  * "K" $4B no keywords
00A02FAC= 00A8                    8534      dc.w    TAB_ASCL-TAB_STAR           * "L"   $4C
00A02FAE= 00D6                    8535      dc.w    TAB_ASCM-TAB_STAR           * "M"   $4D
00A02FB0= 00E4                    8536      dc.w    TAB_ASCN-TAB_STAR           * "N"   $4E
00A02FB2= 00F3                    8537      dc.w    TAB_ASCO-TAB_STAR           * "O"   $4F
00A02FB4= 00F8                    8538      dc.w    TAB_ASCP-TAB_STAR           * "P"   $50
00A02FB6= FFFF                    8539      dc.w    -1                  * "Q" $51 no keywords
00A02FB8= 010D                    8540      dc.w    TAB_ASCR-TAB_STAR           * "R"   $52
00A02FBA= 0137                    8541      dc.w    TAB_ASCS-TAB_STAR           * "S"   $53
00A02FBC= 0162                    8542      dc.w    TAB_ASCT-TAB_STAR           * "T"   $54
00A02FBE= 0176                    8543      dc.w    TAB_ASCU-TAB_STAR           * "U"   $55
00A02FC0= 018E                    8544      dc.w    TAB_ASCV-TAB_STAR           * "V"   $56
00A02FC2= 019A                    8545      dc.w    TAB_ASCW-TAB_STAR           * "W"   $57
00A02FC4= FFFF                    8546      dc.w    -1                  * "X" $58 no keywords
00A02FC6= FFFF                    8547      dc.w    -1                  * "Y" $59 no keywords
00A02FC8= FFFF                    8548      dc.w    -1                  * "Z" $5A no keywords
00A02FCA= FFFF                    8549      dc.w    -1                  * "[" $5B no keywords
00A02FCC= FFFF                    8550      dc.w    -1                  * "\" $5C no keywords
00A02FCE= FFFF                    8551      dc.w    -1                  * "]" $5D no keywords
00A02FD0= 01A9                    8552      dc.w    TAB_POWR-TAB_STAR           * "^"   $5E
00A02FD2                          8553  
00A02FD2                          8554  
00A02FD2                          8555  *************************************************************************************
00A02FD2                          8556  *
00A02FD2                          8557  * Table of Basic keywords for LIST command
00A02FD2                          8558  * [byte]first character,[byte]remaining length -1
00A02FD2                          8559  * [word]offset from table start
00A02FD2                          8560  
00A02FD2                          8561  LAB_KEYT
00A02FD2= 45 01                   8562      dc.b    'E',1
00A02FD4= 0071                    8563      dc.w    KEY_END-TAB_STAR            * END
00A02FD6= 46 01                   8564      dc.b    'F',1
00A02FD8= 007C                    8565      dc.w    KEY_FOR-TAB_STAR            * FOR
00A02FDA= 4E 02                   8566      dc.b    'N',2
00A02FDC= 00E7                    8567      dc.w    KEY_NEXT-TAB_STAR           * NEXT
00A02FDE= 44 02                   8568      dc.b    'D',2
00A02FE0= 0054                    8569      dc.w    KEY_DATA-TAB_STAR           * DATA
00A02FE2= 49 03                   8570      dc.b    'I',3
00A02FE4= 009E                    8571      dc.w    KEY_INPUT-TAB_STAR      * INPUT
00A02FE6= 44 01                   8572      dc.b    'D',1
00A02FE8= 0063                    8573      dc.w    KEY_DIM-TAB_STAR            * DIM
00A02FEA= 52 02                   8574      dc.b    'R',2
00A02FEC= 0114                    8575      dc.w    KEY_READ-TAB_STAR           * READ
00A02FEE= 4C 01                   8576      dc.b    'L',1
00A02FF0= 00BE                    8577      dc.w    KEY_LET-TAB_STAR            * LET
00A02FF2= 44 01                   8578      dc.b    'D',1
00A02FF4= 0058                    8579      dc.w    KEY_DEC-TAB_STAR            * DEC
00A02FF6= 47 02                   8580      dc.b    'G',2
00A02FF8= 0089                    8581      dc.w    KEY_GOTO-TAB_STAR           * GOTO
00A02FFA= 52 01                   8582      dc.b    'R',1
00A02FFC= 0133                    8583      dc.w    KEY_RUN-TAB_STAR            * RUN
00A02FFE= 49 00                   8584      dc.b    'I',0
00A03000= 0099                    8585      dc.w    KEY_IF-TAB_STAR         * IF
00A03002= 52 05                   8586      dc.b    'R',5
00A03004= 011B                    8587      dc.w    KEY_RESTORE-TAB_STAR        * RESTORE
00A03006= 47 03                   8588      dc.b    'G',3
00A03008= 008D                    8589      dc.w    KEY_GOSUB-TAB_STAR      * GOSUB
00A0300A= 52 04                   8590      dc.b    'R',4
00A0300C= 0122                    8591      dc.w    KEY_RETURN-TAB_STAR     * RETURN
00A0300E= 52 01                   8592      dc.b    'R',1
00A03010= 0118                    8593      dc.w    KEY_REM-TAB_STAR            * REM
00A03012= 53 02                   8594      dc.b    'S',2
00A03014= 0154                    8595      dc.w    KEY_STOP-TAB_STAR           * STOP
00A03016= 4F 00                   8596      dc.b    'O',0
00A03018= 00F3                    8597      dc.w    KEY_ON-TAB_STAR         * ON
00A0301A= 4E 02                   8598      dc.b    'N',2
00A0301C= 00EE                    8599      dc.w    KEY_NULL-TAB_STAR           * NULL
00A0301E= 49 01                   8600      dc.b    'I',1
00A03020= 009B                    8601      dc.w    KEY_INC-TAB_STAR            * INC
00A03022= 57 02                   8602      dc.b    'W',2
00A03024= 019A                    8603      dc.w    KEY_WAIT-TAB_STAR           * WAIT
00A03026= 4C 02                   8604      dc.b    'L',2
00A03028= 00C5                    8605      dc.w    KEY_LOAD-TAB_STAR           * LOAD
00A0302A= 53 02                   8606      dc.b    'S',2
00A0302C= 013C                    8607      dc.w    KEY_SAVE-TAB_STAR           * SAVE
00A0302E= 44 01                   8608      dc.b    'D',1
00A03030= 0060                    8609      dc.w    KEY_DEF-TAB_STAR            * DEF
00A03032= 50 02                   8610      dc.b    'P',2
00A03034= 00FF                    8611      dc.w    KEY_POKE-TAB_STAR           * POKE
00A03036= 44 02                   8612      dc.b    'D',2
00A03038= 0066                    8613      dc.w    KEY_DOKE-TAB_STAR           * DOKE
00A0303A= 4C 02                   8614      dc.b    'L',2
00A0303C= 00CD                    8615      dc.w    KEY_LOKE-TAB_STAR           * LOKE
00A0303E= 43 02                   8616      dc.b    'C',2
00A03040= 003D                    8617      dc.w    KEY_CALL-TAB_STAR           * CALL
00A03042= 44 00                   8618      dc.b    'D',0
00A03044= 006A                    8619      dc.w    KEY_DO-TAB_STAR         * DO
00A03046= 4C 02                   8620      dc.b    'L',2
00A03048= 00D1                    8621      dc.w    KEY_LOOP-TAB_STAR           * LOOP
00A0304A= 50 03                   8622      dc.b    'P',3
00A0304C= 0107                    8623      dc.w    KEY_PRINT-TAB_STAR      * PRINT
00A0304E= 43 02                   8624      dc.b    'C',2
00A03050= 004B                    8625      dc.w    KEY_CONT-TAB_STAR           * CONT
00A03052= 4C 02                   8626      dc.b    'L',2
00A03054= 00C1                    8627      dc.w    KEY_LIST-TAB_STAR           * LIST
00A03056= 43 03                   8628      dc.b    'C',3
00A03058= 0046                    8629      dc.w    KEY_CLEAR-TAB_STAR      * CLEAR
00A0305A= 4E 01                   8630      dc.b    'N',1
00A0305C= 00E4                    8631      dc.w    KEY_NEW-TAB_STAR            * NEW
00A0305E= 57 03                   8632      dc.b    'W',3
00A03060= 01A3                    8633      dc.w    KEY_WIDTH-TAB_STAR      * WIDTH
00A03062= 47 01                   8634      dc.b    'G',1
00A03064= 0086                    8635      dc.w    KEY_GET-TAB_STAR            * GET
00A03066= 53 02                   8636      dc.b    'S',2
00A03068= 015D                    8637      dc.w    KEY_SWAP-TAB_STAR           * SWAP
00A0306A= 42 04                   8638      dc.b    'B',4
00A0306C= 002F                    8639      dc.w    KEY_BITSET-TAB_STAR     * BITSET
00A0306E= 42 04                   8640      dc.b    'B',4
00A03070= 0029                    8641      dc.w    KEY_BITCLR-TAB_STAR     * BITCLR
00A03072= 54 02                   8642      dc.b    'T',2
00A03074= 0162                    8643      dc.w    KEY_TAB-TAB_STAR            * TAB(
00A03076= 45 02                   8644      dc.b    'E',2
00A03078= 006D                    8645      dc.w    KEY_ELSE-TAB_STAR           * ELSE
00A0307A= 54 00                   8646      dc.b    'T',0
00A0307C= 016E                    8647      dc.w    KEY_TO-TAB_STAR         * TO
00A0307E= 46 00                   8648      dc.b    'F',0
00A03080= 007F                    8649      dc.w    KEY_FN-TAB_STAR         * FN
00A03082= 53 02                   8650      dc.b    'S',2
00A03084= 0148                    8651      dc.w    KEY_SPC-TAB_STAR            * SPC(
00A03086= 54 02                   8652      dc.b    'T',2
00A03088= 016A                    8653      dc.w    KEY_THEN-TAB_STAR           * THEN
00A0308A= 4E 01                   8654      dc.b    'N',1
00A0308C= 00EB                    8655      dc.w    KEY_NOT-TAB_STAR            * NOT
00A0308E= 53 02                   8656      dc.b    'S',2
00A03090= 0150                    8657      dc.w    KEY_STEP-TAB_STAR           * STEP
00A03092= 55 03                   8658      dc.b    'U',3
00A03094= 017D                    8659      dc.w    KEY_UNTIL-TAB_STAR      * UNTIL
00A03096= 57 03                   8660      dc.b    'W',3
00A03098= 019E                    8661      dc.w    KEY_WHILE-TAB_STAR      * WHILE
00A0309A                          8662  
00A0309A= 2B FF                   8663      dc.b    '+',-1
00A0309C= 0002                    8664      dc.w    KEY_PLUS-TAB_STAR           * +
00A0309E= 2D FF                   8665      dc.b    '-',-1
00A030A0= 0004                    8666      dc.w    KEY_MINUS-TAB_STAR      * -
00A030A2= 2A FF                   8667      dc.b    '*',-1
00A030A4= 0000                    8668      dc.w    KEY_MULT-TAB_STAR           * *
00A030A6= 2F FF                   8669      dc.b    '/',-1
00A030A8= 0006                    8670      dc.w    KEY_DIV-TAB_STAR            * /
00A030AA= 5E FF                   8671      dc.b    '^',-1
00A030AC= 01A9                    8672      dc.w    KEY_POWER-TAB_STAR      * ^
00A030AE= 41 01                   8673      dc.b    'A',1
00A030B0= 0018                    8674      dc.w    KEY_AND-TAB_STAR            * AND
00A030B2= 45 01                   8675      dc.b    'E',1
00A030B4= 0074                    8676      dc.w    KEY_EOR-TAB_STAR            * EOR
00A030B6= 4F 00                   8677      dc.b    'O',0
00A030B8= 00F5                    8678      dc.w    KEY_OR-TAB_STAR         * OR
00A030BA= 3E 00                   8679      dc.b    '>',0
00A030BC= 000E                    8680      dc.w    KEY_RSHIFT-TAB_STAR     * >>
00A030BE= 3C 00                   8681      dc.b    '<',0
00A030C0= 0008                    8682      dc.w    KEY_LSHIFT-TAB_STAR     * <<
00A030C2= 3E FF                   8683      dc.b    '>',-1
00A030C4= 0010                    8684      dc.w    KEY_GT-TAB_STAR         * >
00A030C6= 3D FF                   8685      dc.b    '=',-1
00A030C8= 000C                    8686      dc.w    KEY_EQUAL-TAB_STAR      * =
00A030CA= 3C FF                   8687      dc.b    '<',-1
00A030CC= 000A                    8688      dc.w    KEY_LT-TAB_STAR         * <
00A030CE                          8689  
00A030CE= 53 02                   8690      dc.b    'S',2
00A030D0= 0140                    8691      dc.w    KEY_SGN-TAB_STAR            * SGN(
00A030D2= 49 02                   8692      dc.b    'I',2
00A030D4= 00A3                    8693      dc.w    KEY_INT-TAB_STAR            * INT(
00A030D6= 41 02                   8694      dc.b    'A',2
00A030D8= 0014                    8695      dc.w    KEY_ABS-TAB_STAR            * ABS(
00A030DA= 55 02                   8696      dc.b    'U',2
00A030DC= 0189                    8697      dc.w    KEY_USR-TAB_STAR            * USR(
00A030DE= 46 02                   8698      dc.b    'F',2
00A030E0= 0081                    8699      dc.w    KEY_FRE-TAB_STAR            * FRE(
00A030E2= 50 02                   8700      dc.b    'P',2
00A030E4= 0103                    8701      dc.w    KEY_POS-TAB_STAR            * POS(
00A030E6= 53 02                   8702      dc.b    'S',2
00A030E8= 014C                    8703      dc.w    KEY_SQR-TAB_STAR            * SQR(
00A030EA= 52 02                   8704      dc.b    'R',2
00A030EC= 012F                    8705      dc.w    KEY_RND-TAB_STAR            * RND(
00A030EE= 4C 02                   8706      dc.b    'L',2
00A030F0= 00C9                    8707      dc.w    KEY_LOG-TAB_STAR            * LOG(
00A030F2= 45 02                   8708      dc.b    'E',2
00A030F4= 0077                    8709      dc.w    KEY_EXP-TAB_STAR            * EXP(
00A030F6= 43 02                   8710      dc.b    'C',2
00A030F8= 004F                    8711      dc.w    KEY_COS-TAB_STAR            * COS(
00A030FA= 53 02                   8712      dc.b    'S',2
00A030FC= 0144                    8713      dc.w    KEY_SIN-TAB_STAR            * SIN(
00A030FE= 54 02                   8714      dc.b    'T',2
00A03100= 0166                    8715      dc.w    KEY_TAN-TAB_STAR            * TAN(
00A03102= 41 02                   8716      dc.b    'A',2
00A03104= 001F                    8717      dc.w    KEY_ATN-TAB_STAR            * ATN(
00A03106= 50 03                   8718      dc.b    'P',3
00A03108= 00F8                    8719      dc.w    KEY_PEEK-TAB_STAR           * PEEK(
00A0310A= 44 03                   8720      dc.b    'D',3
00A0310C= 005B                    8721      dc.w    KEY_DEEK-TAB_STAR           * DEEK(
00A0310E= 4C 03                   8722      dc.b    'L',3
00A03110= 00AF                    8723      dc.w    KEY_LEEK-TAB_STAR           * LEEK(
00A03112= 4C 02                   8724      dc.b    'L',2
00A03114= 00BA                    8725      dc.w    KEY_LEN-TAB_STAR            * LEN(
00A03116= 53 03                   8726      dc.b    'S',3
00A03118= 0158                    8727      dc.w    KEY_STRS-TAB_STAR           * STR$(
00A0311A= 56 02                   8728      dc.b    'V',2
00A0311C= 018E                    8729      dc.w    KEY_VAL-TAB_STAR            * VAL(
00A0311E= 41 02                   8730      dc.b    'A',2
00A03120= 001B                    8731      dc.w    KEY_ASC-TAB_STAR            * ASC(
00A03122= 55 05                   8732      dc.b    'U',5
00A03124= 0176                    8733      dc.w    KEY_UCASES-TAB_STAR     * UCASE$(
00A03126= 4C 05                   8734      dc.b    'L',5
00A03128= 00A8                    8735      dc.w    KEY_LCASES-TAB_STAR     * LCASE$(
00A0312A= 43 03                   8736      dc.b    'C',3
00A0312C= 0041                    8737      dc.w    KEY_CHRS-TAB_STAR           * CHR$(
00A0312E= 48 03                   8738      dc.b    'H',3
00A03130= 0093                    8739      dc.w    KEY_HEXS-TAB_STAR           * HEX$(
00A03132= 42 03                   8740      dc.b    'B',3
00A03134= 0024                    8741      dc.w    KEY_BINS-TAB_STAR           * BIN$(
00A03136= 42 05                   8742      dc.b    'B',5
00A03138= 0035                    8743      dc.w    KEY_BITTST-TAB_STAR     * BITTST(
00A0313A= 4D 02                   8744      dc.b    'M',2
00A0313C= 00D6                    8745      dc.w    KEY_MAX-TAB_STAR            * MAX(
00A0313E= 4D 02                   8746      dc.b    'M',2
00A03140= 00DF                    8747      dc.w    KEY_MIN-TAB_STAR            * MIN(
00A03142= 52 05                   8748      dc.b    'R',5
00A03144= 010D                    8749      dc.w    KEY_RAM-TAB_STAR            * RAMBASE
00A03146= 50 00                   8750      dc.b    'P',0
00A03148= 00FD                    8751      dc.w    KEY_PI-TAB_STAR         * PI
00A0314A= 54 03                   8752      dc.b    'T',3
00A0314C= 0170                    8753      dc.w    KEY_TWOPI-TAB_STAR      * TWOPI
00A0314E= 56 05                   8754      dc.b    'V',5
00A03150= 0192                    8755      dc.w    KEY_VPTR-TAB_STAR           * VARPTR(
00A03152= 53 03                   8756      dc.b    'S',3
00A03154= 0137                    8757      dc.w    KEY_SADD-TAB_STAR           * SADD(
00A03156= 4C 04                   8758      dc.b    'L',4
00A03158= 00B4                    8759      dc.w    KEY_LEFTS-TAB_STAR      * LEFT$(
00A0315A= 52 05                   8760      dc.b    'R',5
00A0315C= 0128                    8761      dc.w    KEY_RIGHTS-TAB_STAR     * RIGHT$(
00A0315E= 4D 03                   8762      dc.b    'M',3
00A03160= 00DA                    8763      dc.w    KEY_MIDS-TAB_STAR           * MID$(
00A03162= 55 05                   8764      dc.b    'U',5
00A03164= 0182                    8765      dc.w    KEY_USINGS-TAB_STAR     * USING$(
00A03166                          8766  
00A03166                          8767  
00A03166                          8768  *************************************************************************************
00A03166                          8769  *
00A03166                          8770  * BASIC error messages
00A03166                          8771  
00A03166                          8772  LAB_BAER
00A03166= 0030                    8773      dc.w    LAB_NF-LAB_BAER         * $00 NEXT without FOR
00A03168= 0041                    8774      dc.w    LAB_SN-LAB_BAER         * $02 syntax
00A0316A= 0048                    8775      dc.w    LAB_RG-LAB_BAER         * $04 RETURN without GOSUB
00A0316C= 005D                    8776      dc.w    LAB_OD-LAB_BAER         * $06 out of data
00A0316E= 0069                    8777      dc.w    LAB_FC-LAB_BAER         * $08 function call
00A03170= 0077                    8778      dc.w    LAB_OV-LAB_BAER         * $0A overflow
00A03172= 0080                    8779      dc.w    LAB_OM-LAB_BAER         * $0C out of memory
00A03174= 008E                    8780      dc.w    LAB_US-LAB_BAER         * $0E undefined statement
00A03176= 00A2                    8781      dc.w    LAB_BS-LAB_BAER         * $10 array bounds
00A03178= 00AF                    8782      dc.w    LAB_DD-LAB_BAER         * $12 double dimension array
00A0317A= 00C0                    8783      dc.w    LAB_D0-LAB_BAER         * $14 divide by 0
00A0317C= 00CF                    8784      dc.w    LAB_ID-LAB_BAER         * $16 illegal direct
00A0317E= 00DE                    8785      dc.w    LAB_TM-LAB_BAER         * $18 type mismatch
00A03180= 00EC                    8786      dc.w    LAB_LS-LAB_BAER         * $1A long string
00A03182= 00FC                    8787      dc.w    LAB_ST-LAB_BAER         * $1C string too complex
00A03184= 010F                    8788      dc.w    LAB_CN-LAB_BAER         * $1E continue error
00A03186= 011E                    8789      dc.w    LAB_UF-LAB_BAER         * $20 undefined function
00A03188= 0131                    8790      dc.w    LAB_LD-LAB_BAER         * $22 LOOP without DO
00A0318A= 0141                    8791      dc.w    LAB_UV-LAB_BAER         * $24 undefined variable
00A0318C= 0154                    8792      dc.w    LAB_UA-LAB_BAER         * $26 undimensioned array
00A0318E= 0168                    8793      dc.w    LAB_WD-LAB_BAER         * $28 wrong dimensions
00A03190= 0179                    8794      dc.w    LAB_AD-LAB_BAER         * $2A address
00A03192= 0181                    8795      dc.w    LAB_FO-LAB_BAER         * $2C format
00A03194= 0188                    8796      dc.w    LAB_NI-LAB_BAER         * $2E not implemented
00A03196                          8797  
00A03196= 4E 45 58 54 20 77 ...   8798  LAB_NF  dc.b    'NEXT without FOR',$00
00A031A7= 53 79 6E 74 61 78 00    8799  LAB_SN  dc.b    'Syntax',$00
00A031AE= 52 45 54 55 52 4E ...   8800  LAB_RG  dc.b    'RETURN without GOSUB',$00
00A031C3= 4F 75 74 20 6F 66 ...   8801  LAB_OD  dc.b    'Out of DATA',$00
00A031CF= 46 75 6E 63 74 69 ...   8802  LAB_FC  dc.b    'Function call',$00
00A031DD= 4F 76 65 72 66 6C ...   8803  LAB_OV  dc.b    'Overflow',$00
00A031E6= 4F 75 74 20 6F 66 ...   8804  LAB_OM  dc.b    'Out of memory',$00
00A031F4= 55 6E 64 65 66 69 ...   8805  LAB_US  dc.b    'Undefined statement',$00
00A03208= 41 72 72 61 79 20 ...   8806  LAB_BS  dc.b    'Array bounds',$00
00A03215= 44 6F 75 62 6C 65 ...   8807  LAB_DD  dc.b    'Double dimension',$00
00A03226= 44 69 76 69 64 65 ...   8808  LAB_D0  dc.b    'Divide by zero',$00
00A03235= 49 6C 6C 65 67 61 ...   8809  LAB_ID  dc.b    'Illegal direct',$00
00A03244= 54 79 70 65 20 6D ...   8810  LAB_TM  dc.b    'Type mismatch',$00
00A03252= 53 74 72 69 6E 67 ...   8811  LAB_LS  dc.b    'String too long',$00
00A03262= 53 74 72 69 6E 67 ...   8812  LAB_ST  dc.b    'String too complex',$00
00A03275= 43 61 6E 27 74 20 ...   8813  LAB_CN  dc.b    'Can''t continue',$00
00A03284= 55 6E 64 65 66 69 ...   8814  LAB_UF  dc.b    'Undefined function',$00
00A03297= 4C 4F 4F 50 20 77 ...   8815  LAB_LD  dc.b    'LOOP without DO',$00
00A032A7= 55 6E 64 65 66 69 ...   8816  LAB_UV  dc.b    'Undefined variable',$00
00A032BA= 55 6E 64 69 6D 65 ...   8817  LAB_UA  dc.b    'Undimensioned array',$00
00A032CE= 57 72 6F 6E 67 20 ...   8818  LAB_WD  dc.b    'Wrong dimensions',$00
00A032DF= 41 64 64 72 65 73 ...   8819  LAB_AD  dc.b    'Address',$00
00A032E7= 46 6F 72 6D 61 74 00    8820  LAB_FO  dc.b    'Format',$00
00A032EE= 4E 6F 74 20 69 6D ...   8821  LAB_NI  dc.b    'Not implemented',$00
00A032FE                          8822  
00A032FE                          8823  
00A032FE                          8824  *************************************************************************************
00A032FE                          8825  *
00A032FE                          8826  * keyword table for line (un)crunching
00A032FE                          8827  
00A032FE                          8828  * [keyword,token
00A032FE                          8829  * [keyword,token]]
00A032FE                          8830  * end marker (#$00)
00A032FE                          8831  
00A032FE                          8832  TAB_STAR
00A032FE                          8833  KEY_MULT
00A032FE= B4 00                   8834      dc.b TK_MULT,$00                * *
00A03300                          8835  TAB_PLUS
00A03300                          8836  KEY_PLUS
00A03300= B2 00                   8837      dc.b TK_PLUS,$00                * +
00A03302                          8838  TAB_MNUS
00A03302                          8839  KEY_MINUS
00A03302= B3 00                   8840      dc.b TK_MINUS,$00               * -
00A03304                          8841  TAB_SLAS
00A03304                          8842  KEY_DIV
00A03304= B5 00                   8843      dc.b TK_DIV,$00             * /
00A03306                          8844  TAB_LESS
00A03306                          8845  KEY_LSHIFT
00A03306= 3C BB                   8846      dc.b    '<',TK_LSHIFT           * <<
00A03308                          8847  KEY_LT
00A03308= BE                      8848      dc.b TK_LT                  * <
00A03309= 00                      8849      dc.b    $00
00A0330A                          8850  TAB_EQUL
00A0330A                          8851  KEY_EQUAL
00A0330A= BD 00                   8852      dc.b TK_EQUAL,$00               * =
00A0330C                          8853  TAB_MORE
00A0330C                          8854  KEY_RSHIFT
00A0330C= 3E BA                   8855      dc.b    '>',TK_RSHIFT           * >>
00A0330E                          8856  KEY_GT
00A0330E= BC                      8857      dc.b TK_GT                  * >
00A0330F= 00                      8858      dc.b    $00
00A03310                          8859  TAB_QEST
00A03310= 9E 00                   8860      dc.b TK_PRINT,$00               * ?
00A03312                          8861  TAB_ASCA
00A03312                          8862  KEY_ABS
00A03312= 42 53 28 C1             8863      dc.b    'BS(',TK_ABS            * ABS(
00A03316                          8864  KEY_AND
00A03316= 4E 44 B7                8865      dc.b    'ND',TK_AND             * AND
00A03319                          8866  KEY_ASC
00A03319= 53 43 28 D3             8867      dc.b    'SC(',TK_ASC            * ASC(
00A0331D                          8868  KEY_ATN
00A0331D= 54 4E 28 CC             8869      dc.b    'TN(',TK_ATN            * ATN(
00A03321= 00                      8870      dc.b    $00
00A03322                          8871  TAB_ASCB
00A03322                          8872  KEY_BINS
00A03322= 49 4E 24 28 D8          8873      dc.b    'IN$(',TK_BINS          * BIN$(
00A03327                          8874  KEY_BITCLR
00A03327= 49 54 43 4C 52 A7       8875      dc.b    'ITCLR',TK_BITCLR           * BITCLR
00A0332D                          8876  KEY_BITSET
00A0332D= 49 54 53 45 54 A6       8877      dc.b    'ITSET',TK_BITSET           * BITSET
00A03333                          8878  KEY_BITTST
00A03333= 49 54 54 53 54 28 D9    8879      dc.b    'ITTST(',TK_BITTST      * BITTST(
00A0333A= 00                      8880      dc.b    $00
00A0333B                          8881  TAB_ASCC
00A0333B                          8882  KEY_CALL
00A0333B= 41 4C 4C 9B             8883      dc.b    'ALL',TK_CALL           * CALL
00A0333F                          8884  KEY_CHRS
00A0333F= 48 52 24 28 D6          8885      dc.b    'HR$(',TK_CHRS          * CHR$(
00A03344                          8886  KEY_CLEAR
00A03344= 4C 45 41 52 A1          8887      dc.b    'LEAR',TK_CLEAR         * CLEAR
00A03349                          8888  KEY_CONT
00A03349= 4F 4E 54 9F             8889      dc.b    'ONT',TK_CONT           * CONT
00A0334D                          8890  KEY_COS
00A0334D= 4F 53 28 C9             8891      dc.b    'OS(',TK_COS            * COS(
00A03351= 00                      8892      dc.b    $00
00A03352                          8893  TAB_ASCD
00A03352                          8894  KEY_DATA
00A03352= 41 54 41 83             8895      dc.b    'ATA',TK_DATA           * DATA
00A03356                          8896  KEY_DEC
00A03356= 45 43 88                8897      dc.b    'EC',TK_DEC             * DEC
00A03359                          8898  KEY_DEEK
00A03359= 45 45 4B 28 CE          8899      dc.b    'EEK(',TK_DEEK          * DEEK(
00A0335E                          8900  KEY_DEF
00A0335E= 45 46 97                8901      dc.b    'EF',TK_DEF             * DEF
00A03361                          8902  KEY_DIM
00A03361= 49 4D 85                8903      dc.b    'IM',TK_DIM             * DIM
00A03364                          8904  KEY_DOKE
00A03364= 4F 4B 45 99             8905      dc.b    'OKE',TK_DOKE           * DOKE
00A03368                          8906  KEY_DO
00A03368= 4F 9C                   8907      dc.b    'O',TK_DO               * DO
00A0336A= 00                      8908      dc.b    $00
00A0336B                          8909  TAB_ASCE
00A0336B                          8910  KEY_ELSE
00A0336B= 4C 53 45 A9             8911      dc.b    'LSE',TK_ELSE           * ELSE
00A0336F                          8912  KEY_END
00A0336F= 4E 44 80                8913      dc.b    'ND',TK_END             * END
00A03372                          8914  KEY_EOR
00A03372= 4F 52 B8                8915      dc.b    'OR',TK_EOR             * EOR
00A03375                          8916  KEY_EXP
00A03375= 58 50 28 C8             8917      dc.b    'XP(',TK_EXP            * EXP(
00A03379= 00                      8918      dc.b    $00
00A0337A                          8919  TAB_ASCF
00A0337A                          8920  KEY_FOR
00A0337A= 4F 52 81                8921      dc.b    'OR',TK_FOR             * FOR
00A0337D                          8922  KEY_FN
00A0337D= 4E AB                   8923      dc.b    'N',TK_FN               * FN
00A0337F                          8924  KEY_FRE
00A0337F= 52 45 28 C3             8925      dc.b    'RE(',TK_FRE            * FRE(
00A03383= 00                      8926      dc.b    $00
00A03384                          8927  TAB_ASCG
00A03384                          8928  KEY_GET
00A03384= 45 54 A4                8929      dc.b    'ET',TK_GET             * GET
00A03387                          8930  KEY_GOTO
00A03387= 4F 54 4F 89             8931      dc.b    'OTO',TK_GOTO           * GOTO
00A0338B                          8932  KEY_GOSUB
00A0338B= 4F 53 55 42 8D          8933      dc.b    'OSUB',TK_GOSUB         * GOSUB
00A03390= 00                      8934      dc.b    $00
00A03391                          8935  TAB_ASCH
00A03391                          8936  KEY_HEXS
00A03391= 45 58 24 28 D7 00       8937      dc.b    'EX$(',TK_HEXS,$00      * HEX$(
00A03397                          8938  TAB_ASCI
00A03397                          8939  KEY_IF
00A03397= 46 8B                   8940      dc.b    'F',TK_IF               * IF
00A03399                          8941  KEY_INC
00A03399= 4E 43 93                8942      dc.b    'NC',TK_INC             * INC
00A0339C                          8943  KEY_INPUT
00A0339C= 4E 50 55 54 84          8944      dc.b    'NPUT',TK_INPUT         * INPUT
00A033A1                          8945  KEY_INT
00A033A1= 4E 54 28 C0             8946      dc.b    'NT(',TK_INT            * INT(
00A033A5= 00                      8947      dc.b    $00
00A033A6                          8948  TAB_ASCL
00A033A6                          8949  KEY_LCASES
00A033A6= 43 41 53 45 24 28 D5    8950      dc.b    'CASE$(',TK_LCASES      * LCASE$(
00A033AD                          8951  KEY_LEEK
00A033AD= 45 45 4B 28 CF          8952      dc.b    'EEK(',TK_LEEK          * LEEK(
00A033B2                          8953  KEY_LEFTS
00A033B2= 45 46 54 24 28 E1       8954      dc.b    'EFT$(',TK_LEFTS            * LEFT$(
00A033B8                          8955  KEY_LEN
00A033B8= 45 4E 28 D0             8956      dc.b    'EN(',TK_LEN            * LEN(
00A033BC                          8957  KEY_LET
00A033BC= 45 54 87                8958      dc.b    'ET',TK_LET             * LET
00A033BF                          8959  KEY_LIST
00A033BF= 49 53 54 A0             8960      dc.b    'IST',TK_LIST           * LIST
00A033C3                          8961  KEY_LOAD
00A033C3= 4F 41 44 95             8962      dc.b    'OAD',TK_LOAD           * LOAD
00A033C7                          8963  KEY_LOG
00A033C7= 4F 47 28 C7             8964      dc.b    'OG(',TK_LOG            * LOG(
00A033CB                          8965  KEY_LOKE
00A033CB= 4F 4B 45 9A             8966      dc.b    'OKE',TK_LOKE           * LOKE
00A033CF                          8967  KEY_LOOP
00A033CF= 4F 4F 50 9D             8968      dc.b    'OOP',TK_LOOP           * LOOP
00A033D3= 00                      8969      dc.b    $00
00A033D4                          8970  TAB_ASCM
00A033D4                          8971  KEY_MAX
00A033D4= 41 58 28 DA             8972      dc.b    'AX(',TK_MAX            * MAX(
00A033D8                          8973  KEY_MIDS
00A033D8= 49 44 24 28 E3          8974      dc.b    'ID$(',TK_MIDS          * MID$(
00A033DD                          8975  KEY_MIN
00A033DD= 49 4E 28 DB             8976      dc.b    'IN(',TK_MIN            * MIN(
00A033E1= 00                      8977      dc.b    $00
00A033E2                          8978  TAB_ASCN
00A033E2                          8979  KEY_NEW
00A033E2= 45 57 A2                8980      dc.b    'EW',TK_NEW             * NEW
00A033E5                          8981  KEY_NEXT
00A033E5= 45 58 54 82             8982      dc.b    'EXT',TK_NEXT           * NEXT
00A033E9                          8983  KEY_NOT
00A033E9= 4F 54 AE                8984      dc.b    'OT',TK_NOT             * NOT
00A033EC                          8985  KEY_NULL
00A033EC= 55 4C 4C 92             8986      dc.b    'ULL',TK_NULL           * NULL
00A033F0= 00                      8987      dc.b    $00
00A033F1                          8988  TAB_ASCO
00A033F1                          8989  KEY_ON
00A033F1= 4E 91                   8990      dc.b    'N',TK_ON               * ON
00A033F3                          8991  KEY_OR
00A033F3= 52 B9                   8992      dc.b    'R',TK_OR               * OR
00A033F5= 00                      8993      dc.b    $00
00A033F6                          8994  TAB_ASCP
00A033F6                          8995  KEY_PEEK
00A033F6= 45 45 4B 28 CD          8996      dc.b    'EEK(',TK_PEEK          * PEEK(
00A033FB                          8997  KEY_PI
00A033FB= 49 DD                   8998      dc.b    'I',TK_PI               * PI
00A033FD                          8999  KEY_POKE
00A033FD= 4F 4B 45 98             9000      dc.b    'OKE',TK_POKE           * POKE
00A03401                          9001  KEY_POS
00A03401= 4F 53 28 C4             9002      dc.b    'OS(',TK_POS            * POS(
00A03405                          9003  KEY_PRINT
00A03405= 52 49 4E 54 9E          9004      dc.b    'RINT',TK_PRINT         * PRINT
00A0340A= 00                      9005      dc.b    $00
00A0340B                          9006  TAB_ASCR
00A0340B                          9007  KEY_RAM
00A0340B= 41 4D 42 41 53 45 DC    9008      dc.b    'AMBASE',TK_RAM         * RAMBASE
00A03412                          9009  KEY_READ
00A03412= 45 41 44 86             9010      dc.b    'EAD',TK_READ           * READ
00A03416                          9011  KEY_REM
00A03416= 45 4D 8F                9012      dc.b    'EM',TK_REM             * REM
00A03419                          9013  KEY_RESTORE
00A03419= 45 53 54 4F 52 45 8C    9014      dc.b    'ESTORE',TK_RESTORE     * RESTORE
00A03420                          9015  KEY_RETURN
00A03420= 45 54 55 52 4E 8E       9016      dc.b    'ETURN',TK_RETURN           * RETURN
00A03426                          9017  KEY_RIGHTS
00A03426= 49 47 48 54 24 28 E2    9018      dc.b    'IGHT$(',TK_RIGHTS      * RIGHT$(
00A0342D                          9019  KEY_RND
00A0342D= 4E 44 28 C6             9020      dc.b    'ND(',TK_RND            * RND(
00A03431                          9021  KEY_RUN
00A03431= 55 4E 8A                9022      dc.b    'UN',TK_RUN             * RUN
00A03434= 00                      9023      dc.b    $00
00A03435                          9024  TAB_ASCS
00A03435                          9025  KEY_SADD
00A03435= 41 44 44 28 E0          9026      dc.b    'ADD(',TK_SADD          * SADD(
00A0343A                          9027  KEY_SAVE
00A0343A= 41 56 45 96             9028      dc.b    'AVE',TK_SAVE           * SAVE
00A0343E                          9029  KEY_SGN
00A0343E= 47 4E 28 BF             9030      dc.b    'GN(',TK_SGN            * SGN(
00A03442                          9031  KEY_SIN
00A03442= 49 4E 28 CA             9032      dc.b    'IN(',TK_SIN            * SIN(
00A03446                          9033  KEY_SPC
00A03446= 50 43 28 AC             9034      dc.b    'PC(',TK_SPC            * SPC(
00A0344A                          9035  KEY_SQR
00A0344A= 51 52 28 C5             9036      dc.b    'QR(',TK_SQR            * SQR(
00A0344E                          9037  KEY_STEP
00A0344E= 54 45 50 AF             9038      dc.b    'TEP',TK_STEP           * STEP
00A03452                          9039  KEY_STOP
00A03452= 54 4F 50 90             9040      dc.b    'TOP',TK_STOP           * STOP
00A03456                          9041  KEY_STRS
00A03456= 54 52 24 28 D1          9042      dc.b    'TR$(',TK_STRS          * STR$(
00A0345B                          9043  KEY_SWAP
00A0345B= 57 41 50 A5             9044      dc.b    'WAP',TK_SWAP           * SWAP
00A0345F= 00                      9045      dc.b    $00
00A03460                          9046  TAB_ASCT
00A03460                          9047  KEY_TAB
00A03460= 41 42 28 A8             9048      dc.b    'AB(',TK_TAB            * TAB(
00A03464                          9049  KEY_TAN
00A03464= 41 4E 28 CB             9050      dc.b    'AN(',TK_TAN            * TAN
00A03468                          9051  KEY_THEN
00A03468= 48 45 4E AD             9052      dc.b    'HEN',TK_THEN           * THEN
00A0346C                          9053  KEY_TO
00A0346C= 4F AA                   9054      dc.b    'O',TK_TO               * TO
00A0346E                          9055  KEY_TWOPI
00A0346E= 57 4F 50 49 DE          9056      dc.b    'WOPI',TK_TWOPI         * TWOPI
00A03473= 00                      9057      dc.b    $00
00A03474                          9058  TAB_ASCU
00A03474                          9059  KEY_UCASES
00A03474= 43 41 53 45 24 28 D4    9060      dc.b    'CASE$(',TK_UCASES      * UCASE$(
00A0347B                          9061  KEY_UNTIL
00A0347B= 4E 54 49 4C B0          9062      dc.b    'NTIL',TK_UNTIL         * UNTIL
00A03480                          9063  KEY_USINGS
00A03480= 53 49 4E 47 24 28 E4    9064      dc.b    'SING$(',TK_USINGS      * USING$(
00A03487                          9065  KEY_USR
00A03487= 53 52 28 C2             9066      dc.b    'SR(',TK_USR            * USR(
00A0348B= 00                      9067      dc.b    $00
00A0348C                          9068  TAB_ASCV
00A0348C                          9069  KEY_VAL
00A0348C= 41 4C 28 D2             9070      dc.b    'AL(',TK_VAL            * VAL(
00A03490                          9071  KEY_VPTR
00A03490= 41 52 50 54 52 28 DF    9072      dc.b    'ARPTR(',TK_VPTR            * VARPTR(
00A03497= 00                      9073      dc.b    $00
00A03498                          9074  TAB_ASCW
00A03498                          9075  KEY_WAIT
00A03498= 41 49 54 94             9076      dc.b    'AIT',TK_WAIT           * WAIT
00A0349C                          9077  KEY_WHILE
00A0349C= 48 49 4C 45 B1          9078      dc.b    'HILE',TK_WHILE         * WHILE
00A034A1                          9079  KEY_WIDTH
00A034A1= 49 44 54 48 A3          9080      dc.b    'IDTH',TK_WIDTH         * WIDTH
00A034A6= 00                      9081      dc.b    $00
00A034A7                          9082  TAB_POWR
00A034A7                          9083  KEY_POWER
00A034A7= B6 00                   9084      dc.b    TK_POWER,$00            * ^
00A034A9                          9085  
00A034A9                          9086  
00A034A9                          9087  *************************************************************************************
00A034A9                          9088  *
00A034A9                          9089  * just messages
00A034A9                          9090  
00A034A9                          9091  LAB_BMSG
00A034A9= 0D 0A 42 72 65 61 ...   9092      dc.b    $0D,$0A,'Break',$00
00A034B1                          9093  LAB_EMSG
00A034B1= 20 45 72 72 6F 72 00    9094      dc.b    ' Error',$00
00A034B8                          9095  LAB_LMSG
00A034B8= 20 69 6E 20 6C 69 ...   9096      dc.b    ' in line ',$00
00A034C2                          9097  LAB_IMSG
00A034C2= 45 78 74 72 61 20 ...   9098      dc.b    'Extra ignored',$0D,$0A,$00
00A034D2                          9099  LAB_REDO
00A034D2= 52 65 64 6F 20 66 ...   9100      dc.b    'Redo from start',$0D,$0A,$00
00A034E4                          9101  LAB_RMSG
00A034E4= 0D 0A 52 65 61 64 ...   9102      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
00A034EE                          9103  LAB_SMSG
00A034EE= 20 42 79 74 65 73 ...   9104      dc.b    ' Bytes free',$0D,$0A,$0A
00A034FC= 4D 61 74 74 20 50 ...   9105      dc.b    'Matt Pearce Enhanced 68k BASIC Version 3.52',$0D,$0A,$00
00A0352A                          9106  
00A0352A                          9107  
00A0352A                          9108  *************************************************************************************
00A0352A                          9109  * EhBASIC keywords quick reference list                             *
00A0352A                          9110  *************************************************************************************
00A0352A                          9111  
00A0352A                          9112  * glossary
00A0352A                          9113  
00A0352A                          9114  *       <.>       required
00A0352A                          9115  *       {.|.}         one of required
00A0352A                          9116  *       [.]       optional
00A0352A                          9117  *       ...       may repeat as last
00A0352A                          9118  
00A0352A                          9119  *       any     = anything
00A0352A                          9120  *       num     = number
00A0352A                          9121  *       state       = statement
00A0352A                          9122  *       n       = positive integer
00A0352A                          9123  *       str     = string
00A0352A                          9124  *       var     = variable
00A0352A                          9125  *       nvar        = numeric variable
00A0352A                          9126  *       svar        = string variable
00A0352A                          9127  *       expr        = expression
00A0352A                          9128  *       nexpr       = numeric expression
00A0352A                          9129  *       sexpr       = string expression
00A0352A                          9130  
00A0352A                          9131  * statement separator
00A0352A                          9132  
00A0352A                          9133  * :     . [<state>] : [<state>]                     * done
00A0352A                          9134  
00A0352A                          9135  * number bases
00A0352A                          9136  
00A0352A                          9137  * %     . %<binary num>                         * done
00A0352A                          9138  * $     . $<hex num>                            * done
00A0352A                          9139  
00A0352A                          9140  * commands
00A0352A                          9141  
00A0352A                          9142  * END       . END                                   * done
00A0352A                          9143  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00A0352A                          9144  * NEXT  . NEXT [<nvar>[,<nvar>]...]                 * done
00A0352A                          9145  * DATA  . DATA [{num|["]str["]}[,{num|["]str["]}]...]       * done
00A0352A                          9146  * INPUT . INPUT [<">str<">;] <var>[,<var>[,<var>]...]       * done
00A0352A                          9147  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])            * done
00A0352A                          9148  * READ  . READ <var>[,<var>[,<var>]...]             * done
00A0352A                          9149  * LET       . [LET] <var>=<expr>                        * done
00A0352A                          9150  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]               * done
00A0352A                          9151  * GOTO  . GOTO <n>                              * done
00A0352A                          9152  * RUN       . RUN [<n>]                             * done
00A0352A                          9153  * IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00A0352A                          9154  * RESTORE   . RESTORE [<n>]                         * done
00A0352A                          9155  * GOSUB . GOSUB <n>                             * done
00A0352A                          9156  * RETURN    . RETURN                                * done
00A0352A                          9157  * REM       . REM [<any>]                           * done
00A0352A                          9158  * STOP  . STOP                              * done
00A0352A                          9159  * ON        . ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]      * done
00A0352A                          9160  * NULL  . NULL <nexpr>                          * done
00A0352A                          9161  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]               * done
00A0352A                          9162  * WAIT  . WAIT <nexpr>,<nexpr>[,<nexpr>]                * done
00A0352A                          9163  * LOAD  . LOAD [<sexpr>]                            * done for sim
00A0352A                          9164  * SAVE  . SAVE [<sexpr>][,[<n>][-<n>]]              * done for sim
00A0352A                          9165  * DEF       . DEF FN<var>(<var>)=<expr>                 * done
00A0352A                          9166  * POKE  . POKE <nexpr>,<nexpr>                      * done
00A0352A                          9167  * DOKE  . DOKE <nexpr>,<nexpr>                      * done
00A0352A                          9168  * LOKE  . LOKE <nexpr>,<nexpr>                      * done
00A0352A                          9169  * CALL  . CALL <nexpr>                          * done
00A0352A                          9170  * DO        . DO                                    * done
00A0352A                          9171  * LOOP  . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00A0352A                          9172  * PRINT . PRINT [{;|,}][<expr>][{;|,}[<expr>]...]           * done
00A0352A                          9173  * CONT  . CONT                              * done
00A0352A                          9174  * LIST  . LIST [<n>][-<n>]                      * done
00A0352A                          9175  * CLEAR . CLEAR                             * done
00A0352A                          9176  * NEW       . NEW                                   * done
00A0352A                          9177  * WIDTH . WIDTH [<n>][,<n>]                     * done
00A0352A                          9178  * GET       . GET <var>                             * done
00A0352A                          9179  * SWAP  . SWAP <var>,<var>                      * done
00A0352A                          9180  * BITSET    . BITSET <nexpr>,<nexpr>                    * done
00A0352A                          9181  * BITCLR    . BITCLR <nexpr>,<nexpr>                    * done
00A0352A                          9182  
00A0352A                          9183  * sub commands (may not start a statement)
00A0352A                          9184  
00A0352A                          9185  * TAB       . TAB(<nexpr>)                          * done
00A0352A                          9186  * ELSE  . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00A0352A                          9187  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00A0352A                          9188  * FN        . FN <var>(<expr>)                      * done
00A0352A                          9189  * SPC       . SPC(<nexpr>)                          * done
00A0352A                          9190  * THEN  . IF <nexpr> {THEN <{n|comm}>|GOTO <n>}         * done
00A0352A                          9191  * NOT       . NOT <nexpr>                           * done
00A0352A                          9192  * STEP  . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00A0352A                          9193  * UNTIL . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00A0352A                          9194  * WHILE . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00A0352A                          9195  
00A0352A                          9196  * operators
00A0352A                          9197  
00A0352A                          9198  * +     . [expr] + <expr>                           * done
00A0352A                          9199  * -     . [nexpr] - <nexpr>                     * done
00A0352A                          9200  * *     . <nexpr> * <nexpr>                     * done fast hardware
00A0352A                          9201  * /     . <nexpr> / <nexpr>                     * done fast hardware
00A0352A                          9202  * ^     . <nexpr> ^ <nexpr>                     * done
00A0352A                          9203  * AND       . <nexpr> AND <nexpr>                       * done
00A0352A                          9204  * EOR       . <nexpr> EOR <nexpr>                       * done
00A0352A                          9205  * OR        . <nexpr> OR <nexpr>                        * done
00A0352A                          9206  * >>        . <nexpr> >> <nexpr>                        * done
00A0352A                          9207  * <<        . <nexpr> << <nexpr>                        * done
00A0352A                          9208  
00A0352A                          9209  * compare functions
00A0352A                          9210  
00A0352A                          9211  * <     . <expr> < <expr>                           * done
00A0352A                          9212  * =     . <expr> = <expr>                           * done
00A0352A                          9213  * >     . <expr> > <expr>                           * done
00A0352A                          9214  
00A0352A                          9215  * functions
00A0352A                          9216  
00A0352A                          9217  * SGN       . SGN(<nexpr>)                          * done
00A0352A                          9218  * INT       . INT(<nexpr>)                          * done
00A0352A                          9219  * ABS       . ABS(<nexpr>)                          * done
00A0352A                          9220  * USR       . USR(<expr>)                           * done
00A0352A                          9221  * FRE       . FRE(<expr>)                           * done
00A0352A                          9222  * POS       . POS(<expr>)                           * done
00A0352A                          9223  * SQR       . SQR(<nexpr>)                          * done fast shift/sub
00A0352A                          9224  * RND       . RND(<nexpr>)                          * done 32 bit PRNG
00A0352A                          9225  * LOG       . LOG(<nexpr>)                          * done fast cordic
00A0352A                          9226  * EXP       . EXP(<nexpr>)                          * done fast cordic
00A0352A                          9227  * COS       . COS(<nexpr>)                          * done fast cordic
00A0352A                          9228  * SIN       . SIN(<nexpr>)                          * done fast cordic
00A0352A                          9229  * TAN       . TAN(<nexpr>)                          * done fast cordic
00A0352A                          9230  * ATN       . ATN(<nexpr>)                          * done fast cordic
00A0352A                          9231  * PEEK  . PEEK(<nexpr>)                         * done
00A0352A                          9232  * DEEK  . DEEK(<nexpr>)                         * done
00A0352A                          9233  * LEEK  . LEEK(<nexpr>)                         * done
00A0352A                          9234  * LEN       . LEN(<sexpr>)                          * done
00A0352A                          9235  * STR$  . STR$(<nexpr>)                         * done
00A0352A                          9236  * VAL       . VAL(<sexpr>)                          * done
00A0352A                          9237  * ASC       . ASC(<sexpr>)                          * done
00A0352A                          9238  * UCASE$    . UCASE$(<sexpr>)                           * done
00A0352A                          9239  * LCASE$    . LCASE$(<sexpr>)                           * done
00A0352A                          9240  * CHR$  . CHR$(<nexpr>)                         * done
00A0352A                          9241  * HEX$  . HEX$(<nexpr>)                         * done
00A0352A                          9242  * BIN$  . BIN$(<nexpr>)                         * done
00A0352A                          9243  * BTST  . BTST(<nexpr>,<nexpr>)                     * done
00A0352A                          9244  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00A0352A                          9245  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00A0352A                          9246  * PI        . PI                                    * done
00A0352A                          9247  * TWOPI . TWOPI                             * done
00A0352A                          9248  * VARPTR    . VARPTR(<var>)                         * done
00A0352A                          9249  * SADD  . SADD(<svar>)                          * done
00A0352A                          9250  * LEFT$ . LEFT$(<sexpr>,<nexpr>)                    * done
00A0352A                          9251  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   * done
00A0352A                          9252  * MID$  . MID$(<sexpr>,<nexpr>[,<nexpr>])               * done
00A0352A                          9253  * USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])         * done
00A0352A                          9254  
00A0352A                          9255  
00A0352A                          9256  *************************************************************************************
00A0352A                          9257  
00A0352A                          9258      END code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            A01AF8
ACIAC               F00009
ACIAD               F0000B
ASPTL               E0C
ASRCH               E3E
ASTRTL              E10
BHSEND              E3A
BIN2DEC             A02AB2
BINPR               A02698
BINSS               E1A
BLINEL              CBA
BREAKF              E40
CCBYTE              E4D
CCFLAG              E4C
CCNULL              E4E
CFLAG               E45
CLINEL              CB6
CODE_START          A00040
COMP_F              E47
COSOUT              E18
CPNTRL              CBE
CVARAL              CD2
D1X02               A02A8C
D1X10               A02AA2
D1X16               A02A7E
DECSS               E2A
DEFDIM              E18
DES_SK              CF2
DES_SK_E            CDA
DIMCNT              E3F
DLINEL              CC2
DOCMP               A00702
DOREST              A006EE
DPTRL               CC6
DTYPEF              E19
EARRYL              CA6
EMEML               CAE
ENDBHS              A02672
EVEN                E54
EXPCNT              E11
EXPNEG              E13
FAC1_E              DF8
FAC1_M              DF4
FAC1_S              DF9
FAC2_E              E00
FAC2_M              DFC
FAC2_S              E01
FAC_SC              E02
FEND                8
FILE_BYTE           E4F
FILE_ID             E50
FLAG                E03
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              E14
GCLCTD              E42
GETFIRST            A00ED2
GETPAIR             A00F8E
GOPR                A026A2
HEXSS               E32
IBUFFE              DF4
IBUFFS              CF4
ICLIM               E4B
IMODE               E44
INGET               A026F6
ITEMP               C8E
KEY_ABS             A03312
KEY_AND             A03316
KEY_ASC             A03319
KEY_ATN             A0331D
KEY_BINS            A03322
KEY_BITCLR          A03327
KEY_BITSET          A0332D
KEY_BITTST          A03333
KEY_CALL            A0333B
KEY_CHRS            A0333F
KEY_CLEAR           A03344
KEY_CONT            A03349
KEY_COS             A0334D
KEY_DATA            A03352
KEY_DEC             A03356
KEY_DEEK            A03359
KEY_DEF             A0335E
KEY_DIM             A03361
KEY_DIV             A03304
KEY_DO              A03368
KEY_DOKE            A03364
KEY_ELSE            A0336B
KEY_END             A0336F
KEY_EOR             A03372
KEY_EQUAL           A0330A
KEY_EXP             A03375
KEY_FN              A0337D
KEY_FOR             A0337A
KEY_FRE             A0337F
KEY_GET             A03384
KEY_GOSUB           A0338B
KEY_GOTO            A03387
KEY_GT              A0330E
KEY_HEXS            A03391
KEY_IF              A03397
KEY_INC             A03399
KEY_INPUT           A0339C
KEY_INT             A033A1
KEY_LCASES          A033A6
KEY_LEEK            A033AD
KEY_LEFTS           A033B2
KEY_LEN             A033B8
KEY_LET             A033BC
KEY_LIST            A033BF
KEY_LOAD            A033C3
KEY_LOG             A033C7
KEY_LOKE            A033CB
KEY_LOOP            A033CF
KEY_LSHIFT          A03306
KEY_LT              A03308
KEY_MAX             A033D4
KEY_MIDS            A033D8
KEY_MIN             A033DD
KEY_MINUS           A03302
KEY_MULT            A032FE
KEY_NEW             A033E2
KEY_NEXT            A033E5
KEY_NOT             A033E9
KEY_NULL            A033EC
KEY_ON              A033F1
KEY_OR              A033F3
KEY_PEEK            A033F6
KEY_PI              A033FB
KEY_PLUS            A03300
KEY_POKE            A033FD
KEY_POS             A03401
KEY_POWER           A034A7
KEY_PRINT           A03405
KEY_RAM             A0340B
KEY_READ            A03412
KEY_REM             A03416
KEY_RESTORE         A03419
KEY_RETURN          A03420
KEY_RIGHTS          A03426
KEY_RND             A0342D
KEY_RSHIFT          A0330C
KEY_RUN             A03431
KEY_SADD            A03435
KEY_SAVE            A0343A
KEY_SGN             A0343E
KEY_SIN             A03442
KEY_SPC             A03446
KEY_SQR             A0344A
KEY_STEP            A0344E
KEY_STOP            A03452
KEY_STRS            A03456
KEY_SWAP            A0345B
KEY_TAB             A03460
KEY_TAN             A03464
KEY_THEN            A03468
KEY_TO              A0346C
KEY_TWOPI           A0346E
KEY_UCASES          A03474
KEY_UNTIL           A0347B
KEY_USINGS          A03480
KEY_USR             A03487
KEY_VAL             A0348C
KEY_VPTR            A03490
KEY_WAIT            A03498
KEY_WHILE           A0349C
KEY_WIDTH           A034A1
KFCTSEED            26A3D110
LAB_11A5            A00BA2
LAB_11A6            A00BA4
LAB_11BD            A00BB0
LAB_1269            A00194
LAB_1274            A001A2
LAB_127D            A001AA
LAB_127E            A001B8
LAB_1295            A001CC
LAB_12AE            A001EE
LAB_12B0            A001F0
LAB_12E6            A00210
LAB_12FF            A00242
LAB_1301            A00244
LAB_1303            A00262
LAB_1325            A0027A
LAB_132E            A0026A
LAB_1330            A0026C
LAB_134B            A00288
LAB_1357            A002A6
LAB_1359            A002AC
LAB_1374            A002CC
LAB_1378            A002D2
LAB_137F            A002DE
LAB_138E            A002E4
LAB_1392            A002E8
LAB_13A6            A0031C
LAB_13AC            A00324
LAB_13C6            A0034E
LAB_13CC            A00354
LAB_13D6            A00376
LAB_13D8            A0037C
LAB_13EA            A00388
LAB_13EC            A0038A
LAB_13FF            A003A2
LAB_1401            A003A6
LAB_1408            A003B2
LAB_1410            A003BE
LAB_1417            A003C8
LAB_141B            A003CA
LAB_141F            A003DA
LAB_142A            A003E0
LAB_142C            A003EC
LAB_145E            A00406
LAB_145F            A003F8
LAB_1463            A0040E
LAB_1477            A0041A
LAB_147A            A00420
LAB_1480            A0043A
LAB_1491            A00444
LAB_14BD            A00474
LAB_14C0            A00478
LAB_14D4            A00498
LAB_14E2            A004B4
LAB_150C            A004C2
LAB_1519            A004D2
LAB_152E            A004DE
LAB_1540            A0050A
LAB_15B3            A0056A
LAB_15C2            A00594
LAB_15D1            A005A0
LAB_15DC            A0057C
LAB_15F6            A0058E
LAB_15FF            A005AE
LAB_1602            A005B2
LAB_1624            A00636
LAB_1629            A005D6
LAB_1636            A005DA
LAB_1639            A005E0
LAB_163B            A005EC
LAB_1647            A005F8
LAB_164F            A005FE
LAB_16B0            A00696
LAB_16D0            A006BA
LAB_1723            A00754
LAB_1725            A00758
LAB_172C            A00744
LAB_172D            A0074C
LAB_174B            A00780
LAB_174E            A007A4
LAB_1750            A007AC
LAB_1752            A007B8
LAB_1754            A007D0
LAB_1756            A007BC
LAB_176C            A007EE
LAB_1773            A007F8
LAB_1785            A00814
LAB_1786            A00840
LAB_17B7            A00856
LAB_17B8            A00852
LAB_17D5            A008D0
LAB_17D6            A008D4
LAB_1810            A008E6
LAB_1811            A008F6
LAB_1813            A008FC
LAB_1829            A00934
LAB_182C            A00938
LAB_1831            A0093E
LAB_185E            A0097E
LAB_1866            A00982
LAB_1880            A00A44
LAB_1886            A00A4E
LAB_188A            A00A52
LAB_188B            A00990
LAB_1898            A0099E
LAB_18A2            A009A8
LAB_18B7            A009CA
LAB_18B8            A009D6
LAB_18BD            A009DC
LAB_18C3            A009E6
LAB_18C6            A009EA
LAB_18CD            A009F4
LAB_18E3            A009FE
LAB_18F0            A00A1E
LAB_18F7            A00A2C
LAB_18F9            A00A30
LAB_1904            A00A56
LAB_1913            A00A68
LAB_1934            A00A8E
LAB_1953            A00AA2
LAB_195B            A00AAA
LAB_1961            A00AB4
LAB_1984            A00AD4
LAB_1985            A00AD8
LAB_1986            A00ADC
LAB_1999            A00AF0
LAB_19B0            A00B02
LAB_19B6            A00B12
LAB_19C2            A00B22
LAB_19DD            A00B36
LAB_19F6            A00B56
LAB_1A03            A00B64
LAB_1A0E            A00B74
LAB_1A1B            A00B7A
LAB_1A46            A00B94
LAB_1A90            A00C12
LAB_1A9B            A00C20
LAB_1ABA            A00C4A
LAB_1ACD            A00C76
LAB_1ADB            A00C82
LAB_1ADE            A00C86
LAB_1AE0            A00C9C
LAB_1AFA            A00CB6
LAB_1B0B            A00CCC
LAB_1B13            A00CD4
LAB_1B1C            A00CE4
LAB_1B1D            A00CE6
LAB_1B2A            A00CF8
LAB_1B3C            A00D14
LAB_1B43            A00C5A
LAB_1B78            A00D20
LAB_1B7B            A00D24
LAB_1B7D            A00D26
LAB_1B84            A00D30
LAB_1B86            A00D34
LAB_1B9D            A00D58
LAB_1BC1            A00D88
LAB_1BD0            A00DF6
LAB_1BE7            A00E10
LAB_1BF3            A00D94
LAB_1BF7            A00D9A
LAB_1BFB            A00D9E
LAB_1C01            A00DA6
LAB_1C11            A00DCE
LAB_1C13            A00DD4
LAB_1C18            A00DDC
LAB_1C19            A00DE0
LAB_1C1A            A00DF0
LAB_1C2A            A00E4E
LAB_1CAE            A00EF6
LAB_1CB5            A00F14
LAB_1CD4            A00F1E
LAB_1CD5            A00F24
LAB_1CD6            A00F26
LAB_1CDB            A00F36
LAB_1CE6            A00F28
LAB_1CF2            A00F38
LAB_1CFE            A00F4E
LAB_1D10            A00FC6
LAB_1D12            A00FCA
LAB_1D2D            A00FDC
LAB_1D2E            A00FE8
LAB_1D44            A01004
LAB_1D45            A01014
LAB_1D48            A01028
LAB_1D49            A01030
LAB_1D4A            A01034
LAB_1D4B            A01044
LAB_1D5D            A0104C
LAB_1D5E            A01052
LAB_1D83            A00FB6
LAB_1D8A            A00FB0
LAB_1D94            A01066
LAB_1D96            A02DA8
LAB_1D98            A01070
LAB_1DAC            A0108A
LAB_1DAE            A0108C
LAB_1DAF            A01098
LAB_1DB0            A010A6
LAB_1DB1            A010AA
LAB_1DB2            A010AE
LAB_1DD7            A010C6
LAB_1DE6            A010E0
LAB_1E17            A01122
LAB_1E1F            A01128
LAB_1E5C            A01162
LAB_1E8D            A0117E
LAB_1EA1            A0119A
LAB_1EC0            A011C2
LAB_1ED6            A011EE
LAB_1ED8            A011FC
LAB_1EDF            A011B6
LAB_1F07            A0120E
LAB_1F28            A01228
LAB_1F2C            A0122E
LAB_1F5A            A0123C
LAB_1F6A            A01264
LAB_1F6B            A01270
LAB_1F7C            A01276
LAB_1FB4            A012A4
LAB_1FD0            A012D0
LAB_201E            A0132A
LAB_2043            A01378
LAB_2044            A013AA
LAB_2045            A013B4
LAB_204S            A0137A
LAB_204T            A013A8
LAB_20AE            A013C6
LAB_20B4            A013CA
LAB_20BE            A013D0
LAB_20C9            A013F4
LAB_20CB            A013E0
LAB_20D0            A013E8
LAB_20D8            A013FE
LAB_20E0            A01406
LAB_2115            A01426
LAB_2117            A0143E
LAB_2128            A01458
LAB_2137            A0145C
LAB_214B            A0147C
LAB_2161            A01492
LAB_2176            A0149A
LAB_217E            A014A8
LAB_2183            A014C2
LAB_218B            A014CA
LAB_218F            A014CC
LAB_21C2            A014D8
LAB_21C4            A014DE
LAB_21D1            A01512
LAB_2206            A01518
LAB_2212            A01540
LAB_2216            A01502
LAB_2240            A0150A
LAB_224D            A01546
LAB_224E            A0155C
LAB_229E            A015A0
LAB_22A0            A015AC
LAB_22B6            A015BA
LAB_22BA            A015BE
LAB_22BD            A015C8
LAB_22E6            A015E2
LAB_2316            A01622
LAB_2317            A01624
LAB_231C            A01628
LAB_2358            A0165C
LAB_2368            A0167C
LAB_2441            A0186E
LAB_2445            A01872
LAB_2467            A018C2
LAB_2468            A018C6
LAB_249C            A018B4
LAB_24A8            A018CA
LAB_24B4            A018F4
LAB_24D0            A01900
LAB_24D5            A0190C
LAB_24D6            A01926
LAB_24D7            A01934
LAB_24D8            A0193A
LAB_24D9            A0191A
LAB_24DA            A01940
LAB_24F7            A018E4
LAB_24F8            A018EA
LAB_2778            A01BA8
LAB_277C            A01BAA
LAB_279B            A01BCE
LAB_27BA            A01BDC
LAB_27C3            A01BF8
LAB_27C4            A01C02
LAB_27CA            A01C08
LAB_27CE            A01C10
LAB_27D0            A01C14
LAB_27DB            A01C22
LAB_27F0            A01EDE
LAB_27F1            A01EF4
LAB_27F2            A01EFA
LAB_27F3            A01EFC
LAB_27FA            A01C3A
LAB_2828            A01C5A
LAB_282E            A01C60
LAB_282F            A01C62
LAB_2831            A01C66
LAB_284G            A01C88
LAB_284H            A01C9A
LAB_284J            A01C9C
LAB_284L            A01C90
LAB_2887            A028A0
LAB_289A            A028CA
LAB_289C            A028D0
LAB_289D            A028D6
LAB_28FD            A028F2
LAB_28FE            A028F8
LAB_28FF            A028FE
LAB_2900            A0290C
LAB_2901            A02912
LAB_2902            A02964
LAB_2903            A0296C
LAB_2904            A0296E
LAB_2953            A01CBC
LAB_295E            A01CC8
LAB_2967            A01CD4
LAB_2968            A01CDC
LAB_2969            A01CEE
LAB_296A            A01CF8
LAB_2970            A01D0E
LAB_2978            A01D1E
LAB_2989            A01D2E
LAB_299C            A01D82
LAB_29A7            A01DAA
LAB_29B7            A01DC2
LAB_29B9            A01D5A
LAB_29C0            A01DD0
LAB_29C3            A01DE8
LAB_29D9            A01E02
LAB_29E4            A01E14
LAB_29F7            A01E28
LAB_29FB            A01E2C
LAB_29FD            A01E34
LAB_2A18            A01E44
LAB_2A1A            A01E46
LAB_2A21            A01E4E
LAB_2A3B            A01E6E
LAB_2A4B            A01E7C
LAB_2A58            A01E90
LAB_2A68            A01EA8
LAB_2A74            A01EB4
LAB_2A89            A01ED0
LAB_2A8C            A01ED4
LAB_2A91            A01EDA
LAB_2A9A            A02F4C
LAB_2A9B            A02F68
LAB_2X01            A0292A
LAB_2X02            A02932
LAB_2X03            A02940
LAB_2X04            A02946
LAB_2X05            A0295C
LAB_2Y01            A0297C
LAB_2Y02            A02984
LAB_2Y03            A02990
LAB_2Y04            A02996
LAB_3216            A01B42
LAB_32_16           A01B40
LAB_ABER            A00156
LAB_ABS             A01C32
LAB_AD              A032DF
LAB_ADD             A01890
LAB_ADER            A00122
LAB_AND             A00ECA
LAB_ASC             A01706
LAB_ATCD            A0227C
LAB_ATGO            A0223A
LAB_ATLE            A02258
LAB_ATN             A0221C
LAB_ATNP            A02276
LAB_AYFC            A012B0
LAB_BAER            A03166
LAB_BHCB            A00EB0
LAB_BHSS            A00E8A
LAB_BINS            A02654
LAB_BITCLR          A022DE
LAB_BITSET          A022CE
LAB_BMSG            A034A9
LAB_BS              A03208
LAB_BTST            A022EE
LAB_CALL            A0184E
LAB_CASC            A00FA0
LAB_CATN            A02282
LAB_CAUC            A00FA6
LAB_CBIN            A02A50
LAB_CBX1            A02A6A
LAB_CBXN            A02A58
LAB_CCER            A0013A
LAB_CHEX            A029EE
LAB_CHRS            A015EC
LAB_CHX1            A02A14
LAB_CHX2            A02A38
LAB_CHX3            A02A30
LAB_CHXX            A029F6
LAB_CKRN            A012D8
LAB_CKTM            A00C3C
LAB_CLEAR           A0045C
LAB_CN              A03275
LAB_COLD            A0005C
LAB_CONT            A00648
LAB_CORD            A021AE
LAB_COS             A0213E
LAB_CRLF            A00988
LAB_CTBL            A02E30
LAB_CTNM            A00C3A
LAB_D0              A03226
LAB_D002            A025B8
LAB_D00A            A025C8
LAB_D00E            A025D8
LAB_DATA            A00736
LAB_DD              A03215
LAB_DDER            A00152
LAB_DEC             A00846
LAB_DECI            A008A4
LAB_DEEK            A017CC
LAB_DEF             A012E2
LAB_DIM             A00F52
LAB_DIV0            A01B3A
LAB_DIVIDE          A01AC0
LAB_DIVX            A01B10
LAB_DO              A0067A
LAB_DOKE            A017F6
LAB_DUPFMT          A025A0
LAB_DZER            A0014E
LAB_EMSG            A034B1
LAB_END             A005E2
LAB_EOR             A00EBA
LAB_EQUAL           A00EE0
LAB_ESML            A02054
LAB_EVBY            A0171E
LAB_EVEX            A00C50
LAB_EVEZ            A00C52
LAB_EVIN            A010EC
LAB_EVIR            A010FC
LAB_EVNM            A00C38
LAB_EVPI            A010F4
LAB_EX1             A01F8C
LAB_EXAD            A020DE
LAB_EXCC            A020C4
LAB_EXCM            A01FF6
LAB_EXNN            A020B0
LAB_EXOF            A01FB0
LAB_EXOL            A01FC6
LAB_EXOU            A01F9C
LAB_EXP             A01FD0
LAB_EXPL            A020AA
LAB_EXPS            A02008
LAB_EXRN            A020B6
LAB_EXXF            A02A3E
LAB_FB95            A02706
LAB_FBA0            A026EA
LAB_FC              A031CF
LAB_FCER            A00166
LAB_FO              A032E7
LAB_FOER            A0011E
LAB_FOR             A00516
LAB_FRE             A0129A
LAB_FTBL            A02ECC
LAB_FTPP            A02E80
LAB_FVAR            A00FBE
LAB_GADB            A01770
LAB_GADW            A01784
LAB_GARB            A01472
LAB_GBYT            A00DB2
LAB_GEAD            A017A4
LAB_GET             A00902
LAB_GETS            A0091C
LAB_GFPN            A00808
LAB_GOSUB           A0068C
LAB_GOTO            A0069E
LAB_GOTS            A006AE
LAB_GSCH            A0062E
LAB_GTBY            A0171A
LAB_GTHAN           A01F7E
LAB_GTWO            A0172E
LAB_GVAL            A00D5E
LAB_GVAR            A00FC0
LAB_HEXS            A026A6
LAB_ID              A03235
LAB_IDER            A0014A
LAB_IF              A0075E
LAB_IGBY            A00DB0
LAB_IMSG            A034C2
LAB_INC             A0084C
LAB_INCI            A0089A
LAB_INCT            A0088C
LAB_INLN            A0029C
LAB_INPUT           A00A76
LAB_INT             A01CA2
LAB_IRTS            A01CBA
LAB_ISHN            A02A10
LAB_KEYT            A02FD2
LAB_LAAD            A019BA
LAB_LCASE           A01684
LAB_LD              A03297
LAB_LDER            A00132
LAB_LEEK            A017E2
LAB_LEFT            A015FC
LAB_LENS            A016FE
LAB_LET             A008A8
LAB_LIST            A00460
LAB_LMSG            A034B8
LAB_LOAD            A01846
LAB_LOCC            A019C0
LAB_LOCX            A019DC
LAB_LOG             A01942
LAB_LOKE            A017FC
LAB_LOLP            A019CA
LAB_LONE            A019F8
LAB_LONN            A019E0
LAB_LOOP            A006CC
LAB_LOWZ            A01A32
LAB_LOXO            A019FE
LAB_LOXP            A019EE
LAB_LRMS            A00E68
LAB_LS              A03252
LAB_LSHIFT          A00F5E
LAB_LTHAN           A00EEA
LAB_LTPF            A021BE
LAB_LTPT            A021CE
LAB_LT_1            A01B4E
LAB_MADD            A01A60
LAB_MAN1            A01B34
LAB_MAX             A02712
LAB_MAXN            A0271E
LAB_MIDS            A01640
LAB_MIN             A02728
LAB_MINN            A02734
LAB_MKCHR           A015F0
LAB_MMEC            A0273E
LAB_MNOC            A01A5A
LAB_MUEX            A01AAE
LAB_MUF1            A01A8A
LAB_MUF2            A01A94
LAB_MUF3            A01AAA
LAB_MULTIPLY        A01A34
LAB_MUUF            A01AB4
LAB_NB1T            A01B86
LAB_NEW             A0040C
LAB_NEXT            A00B82
LAB_NF              A03196
LAB_NFER            A00176
LAB_NI              A032EE
LAB_NOST            A0092E
LAB_NSTT            A027A4
LAB_NULL            A0063E
LAB_OD              A031C3
LAB_ODER            A0016A
LAB_OFER            A00162
LAB_OM              A031E6
LAB_OMER            A0015E
LAB_ON              A007D4
LAB_OPPT            A02F18
LAB_OR              A00EC2
LAB_OV              A031DD
LAB_P004            A025F6
LAB_P008            A0260C
LAB_P00C            A02614
LAB_P00E            A02620
LAB_P010            A02624
LAB_P018            A0263E
LAB_P01A            A02642
LAB_P01E            A0264A
LAB_PEEK            A017BA
LAB_PFAC            A01B90
LAB_PHFA            A0274E
LAB_PI              A02880
LAB_POKE            A017C6
LAB_POON            A01EFE
LAB_POS             A012CC
LAB_POWER           A01F1A
LAB_POWP            A01F4C
LAB_POZE            A01F0E
LAB_PPBI            A00E5E
LAB_PPFN            A00E50
LAB_PPFS            A00E42
LAB_PRINT           A0093C
LAB_PRNA            A00A00
LAB_PROCFO          A025DE
LAB_P_10            A02BC2
LAB_RAM             A02876
LAB_READ            A00A9C
LAB_REDO            A034D2
LAB_REM             A007CC
LAB_REMM            A01B66
LAB_RESS            A00622
LAB_RESTORE         A00610
LAB_RET0            A029DC
LAB_RETURN          A00722
LAB_RG              A031AE
LAB_RGER            A0016E
LAB_RIGHT           A01610
LAB_RMSG            A034E4
LAB_RND             A020EA
LAB_RSED            A02ADA
LAB_RSHIFT          A00F6E
LAB_RTN0            A029DE
LAB_RTST            A0140C
LAB_RUN             A00666
LAB_RUNN            A00674
LAB_SADD            A016E6
LAB_SAVE            A0184A
LAB_SCCA            A00DA8
LAB_SCER            A0013E
LAB_SCGB            A00DA2
LAB_SCL0            A021A4
LAB_SCLN            A003FA
LAB_SCZE            A02196
LAB_SET1            A01B18
LAB_SGBY            A01716
LAB_SGN             A01C20
LAB_SIN             A02156
LAB_SIZOK           A0006C
LAB_SLER            A00142
LAB_SMSG            A034EE
LAB_SN              A031A7
LAB_SNBS            A0073C
LAB_SNER            A00172
LAB_SQE1            A02828
LAB_SQE2            A0282E
LAB_SQNA            A02856
LAB_SQNS            A02840
LAB_SQR             A02804
LAB_SSLN            A003F2
LAB_ST              A03262
LAB_STOP            A005EA
LAB_STRS            A013C2
LAB_SUBTRACT        A0187C
LAB_SVAR            A00FBC
LAB_SVTB            A027D6
LAB_SWAP            A01810
LAB_TAN             A0211C
LAB_TBSZ            A027B6
LAB_TM              A03244
LAB_TMER            A00146
LAB_TWOPI           A02890
LAB_U002            A02346
LAB_U004            A0239C
LAB_U005            A023AC
LAB_U006            A023AE
LAB_U008            A023C2
LAB_U009            A023E4
LAB_U00A            A023EC
LAB_U00B            A023F6
LAB_U00C            A0240A
LAB_U00D            A0240E
LAB_U00E            A02420
LAB_U00F            A0242C
LAB_U010            A02430
LAB_U014            A02436
LAB_U018            A0243E
LAB_U01C            A02454
LAB_U020            A02460
LAB_U022            A02466
LAB_U026            A02476
LAB_U02A            A02480
LAB_U02B            A02498
LAB_U02C            A0249E
LAB_U02E            A024B0
LAB_U030            A024B4
LAB_U034            A024CA
LAB_U036            A024D0
LAB_U038            A024D8
LAB_U03C            A024E0
LAB_U03E            A024E6
LAB_U040            A024FE
LAB_U044            A0250E
LAB_U046            A02536
LAB_U048            A02538
LAB_U04A            A02542
LAB_U04C            A02574
LAB_UA              A032BA
LAB_UCASE           A016B4
LAB_UDER            A0012A
LAB_UF              A03284
LAB_UFAC            A01B74
LAB_UFER            A00136
LAB_US              A031F4
LAB_USER            A0015A
LAB_USINGS          A0231C
LAB_USR             A0183E
LAB_UV              A032A7
LAB_UVER            A0012E
LAB_VAL             A01742
LAB_VALZ            A0176A
LAB_VARCALL         A02868
LAB_VARPTR          A02866
LAB_WAIT            A01858
LAB_WARM            C64
LAB_WD              A032CE
LAB_WDER            A00126
LAB_WDLP            A027EA
LAB_WDTH            A02784
LAB_XDIV            A01B28
LAB_XERR            A00178
LAB_XGADW           A0179E
LC_LOOP             A0169A
LOOPALWAYS          A00708
LOOPDONE            A0071C
LVARPL              CD6
L_DDIV              A01B6E
L_DIVRND            A01B1C
MAINLOOP            A021E6
N                   2
NEXTA               A021F8
NEXTB1              A02664
NEXTB2              A0268A
NEXTH1              A026B6
NEXTPRN             A020F8
NINC0               A02100
NINC1               A02106
NOBRK               0
NOLCASE             A016DC
NOSHIFT             A00F6A
NOSTRING            A016E2
NOT2BIG             A00F82
NOUCASE             A016AC
NOVAR               0
NULLCT              E48
NUMEXP              E10
OFCHR               23
OQUOTE              E41
OUTLOOP             A02206
PRG_STRT            E54
PRNLWORD            E04
PRSTK               E3C
RAM_ADDR            1000
RAM_BASE            C64
RAM_SIZE            6000
RAM_STRT            64
RDPTRL              CCA
RDRF                0
RETCHR              A00024
RTS_001             A00DCC
RTS_005             A0045A
RTS_006             A0063C
RTS_007             A0073A
RTS_007A            A00750
RTS_008             A00900
RTS_009             A009FC
RTS_011             A01274
RTS_012             A01544
RTS_013             A015B8
RTS_015             A0180E
RTS_016             A018E8
RTS_017             A01C06
RTS_020             A01F8A
RTS_021             A022CC
RTS_022             A026F4
RTS_023             A02802
RTS_024             A02A4E
RTS_025             A02AB0
SARRYL              CA2
SFNCL               C96
SMEML               C92
SSTORL              CAA
SSTRL               C9E
SUBEXIT             A02210
SUBLOOP             A021DE
SUFNXF              E43
SUTILL              CB2
SVARL               C9A
TABSIZ              E46
TAB_ASCA            A03312
TAB_ASCB            A03322
TAB_ASCC            A0333B
TAB_ASCD            A03352
TAB_ASCE            A0336B
TAB_ASCF            A0337A
TAB_ASCG            A03384
TAB_ASCH            A03391
TAB_ASCI            A03397
TAB_ASCL            A033A6
TAB_ASCM            A033D4
TAB_ASCN            A033E2
TAB_ASCO            A033F1
TAB_ASCP            A033F6
TAB_ASCR            A0340B
TAB_ASCS            A03435
TAB_ASCT            A03460
TAB_ASCU            A03474
TAB_ASCV            A0348C
TAB_ASCW            A03498
TAB_ATNC            A02D30
TAB_CHRT            A02F68
TAB_EQUL            A0330A
TAB_HTHET           A02DB0
TAB_LESS            A03306
TAB_MNUS            A03302
TAB_MORE            A0330C
TAB_PLUS            A03300
TAB_POWR            A034A7
TAB_QEST            A03310
TAB_SLAS            A03304
TAB_SNCO            A02CB0
TAB_STAR            A032FE
TDRE                1
TK_ABS              C1
TK_AND              B7
TK_ASC              D3
TK_ATN              CC
TK_BINS             D8
TK_BITCLR           A7
TK_BITSET           A6
TK_BITTST           D9
TK_CALL             9B
TK_CHRS             D6
TK_CLEAR            A1
TK_CONT             9F
TK_COS              C9
TK_DATA             83
TK_DEC              88
TK_DEEK             CE
TK_DEF              97
TK_DIM              85
TK_DIV              B5
TK_DO               9C
TK_DOKE             99
TK_ELSE             A9
TK_END              80
TK_EOR              B8
TK_EQUAL            BD
TK_EXP              C8
TK_FN               AB
TK_FOR              81
TK_FRE              C3
TK_GET              A4
TK_GOSUB            8D
TK_GOTO             89
TK_GT               BC
TK_HEXS             D7
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              C0
TK_LCASES           D5
TK_LEEK             CF
TK_LEFTS            E1
TK_LEN              D0
TK_LET              87
TK_LIST             A0
TK_LOAD             95
TK_LOG              C7
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           BB
TK_LT               BE
TK_MAX              DA
TK_MIDS             E3
TK_MIN              DB
TK_MINUS            B3
TK_MULT             B4
TK_NEW              A2
TK_NEXT             82
TK_NOT              AE
TK_NULL             92
TK_ON               91
TK_OR               B9
TK_PEEK             CD
TK_PI               DD
TK_PLUS             B2
TK_POKE             98
TK_POS              C4
TK_POWER            B6
TK_PRINT            9E
TK_RAM              DC
TK_READ             86
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           E2
TK_RND              C6
TK_RSHIFT           BA
TK_RUN              8A
TK_SADD             E0
TK_SAVE             96
TK_SGN              BF
TK_SIN              CA
TK_SPC              AC
TK_SQR              C5
TK_STEP             AF
TK_STOP             90
TK_STRS             D1
TK_SWAP             A5
TK_TAB              A8
TK_TAN              CB
TK_THEN             AD
TK_TO               AA
TK_TWOPI            DE
TK_UCASES           D4
TK_UNTIL            B0
TK_USINGS           E4
TK_USR              C2
TK_VAL              D2
TK_VPTR             DF
TK_WAIT             94
TK_WHILE            B1
TK_WIDTH            A3
TOOBIG              A00F88
TPOS                E49
TPOWER              E3D
TWIDTH              E4A
UC_LOOP             A016CA
USDSS               E30
USRJMP              C6A
USRJPV              C6C
UT1_PL              E08
VARNAME             CCE
VEC_CC              A026D0
VEC_IN              A00014
VEC_LD              A00034
VEC_OUT             A00004
VEC_SV              A0003A
V_CTLC              C88
V_CTLCV             C8A
V_INPT              C70
V_INPTV             C72
V_LOAD              C7C
V_LOADV             C7E
V_OUTP              C76
V_OUTPV             C78
V_SAVE              C82
V_SAVEV             C84
WEXIT               A027DA
WRMJPV              C66
