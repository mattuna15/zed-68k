00B0003E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 16/08/2020 07:51:09

00000000                             1  *************************************************************************************
00000000                             2  *                                           *
00000000                             3  *   Enhanced BASIC for the Motorola MC680xx                     *
00000000                             4  *                                           *
00000000                             5  *   This version is for the TS2 single board computer.                  *
00000000                             6  *   Jeff Tranter (tranter@pobox.com)                        *
00000000                             7  *                                           *
00000000                             8  *************************************************************************************
00000000                             9  *                                           *
00000000                            10  *   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
00000000                            11  *   for personal use only. All commercial rights are reserved.          *
00000000                            12  *                                           *
00000000                            13  *   More 68000 and other projects can be found on my website at ..          *
00000000                            14  *                                           *
00000000                            15  *    http://mycorner.no-ip.org/index.html                       *
00000000                            16  *                                           *
00000000                            17  *   mail : leeedavison@googlemail.com                       *
00000000                            18  *                                           *
00000000                            19  *************************************************************************************
00000000                            20  
00000000                            21  * Ver 3.52
00000000                            22  
00000000                            23  * Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            24  * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            25  * Ver 3.50 unary minus in concatenate generates a type mismatch error
00000000                            26  * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            27  * Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            28  * Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            29  * Ver 3.46 updates function and function variable handling
00000000                            30  
00000000                            31  *************************************************************************************
00000000                            32  *
00000000                            33  * Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            34  * option of not returning an error for a non existant variable. If this is the
00000000                            35  * behaviour you want just change novar to some non zero value
00000000                            36  
00000000  =00000000                 37  novar       EQU 0               * non existant variables cause errors
00000000                            38  
00000000                            39  
00000000                            40  *************************************************************************************
00000000                            41  
00000000                            42  * Ver 3.44 adds overflow indication to the USING$() function
00000000                            43  * Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            44  * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            45  * Ver 3.41 removes undocumented features of the USING$() function
00000000                            46  * Ver 3.40 adds the USING$() function
00000000                            47  * Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            48  * Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            49  
00000000                            50  *************************************************************************************
00000000                            51  *
00000000                            52  * Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            53  * response does not cause a program break. If this is the behaviour you want just
00000000                            54  * change nobrk to some non zero value.
00000000                            55  
00000000  =00000000                 56  nobrk       EQU 0               * null response to INPUT causes a break
00000000                            57  
00000000                            58  
00000000                            59  *************************************************************************************
00000000                            60  *
00000000                            61  * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                            62  * pointer in a3. this means that this could now be run as a task on a multitasking
00000000                            63  * system where memory resources may change.
00000000                            64  
00000000                            65  
00000000                            66  *************************************************************************************
00000000                            67  
00000000                            68  
00000000                            69      INCLUDE "basic68k.inc"
00000000                            70  
00000000                            71  
00000064                            72          ORG     100         * start of RAM
00000064                            73   
00000064                            74  ram_strt    ds.l    $100            * allow 1K for the stack, this should be plenty
00000464                            75                          * for any BASIC program that doesn't do something
00000464                            76                          * silly, it could even be much less.
00000464                            77  ram_base
00000464                            78  LAB_WARM    ds.w    1           * BASIC warm start entry point
00000466                            79  Wrmjpv  ds.l    1           * BASIC warm start jump vector
0000046A                            80  
0000046A                            81  Usrjmp  ds.w    1           * USR function JMP address
0000046C                            82  Usrjpv  ds.l    1           * USR function JMP vector
00000470                            83  
00000470                            84  
00000470                            85  V_INPT  ds.w    1           * non halting scan input device entry point
00000472                            86  V_INPTv ds.l    1           * non halting scan input device jump vector
00000476                            87  
00000476                            88  V_OUTP  ds.w    1           * send byte to output device entry point
00000478                            89  V_OUTPv ds.l    1           * send byte to output device jump vector
0000047C                            90  
0000047C                            91  V_LOAD  ds.w    1           * load BASIC program entry point
0000047E                            92  V_LOADv ds.l    1           * load BASIC program jump vector
00000482                            93  
00000482                            94  V_SAVE  ds.w    1           * save BASIC program entry point
00000484                            95  V_SAVEv ds.l    1           * save BASIC program jump vector
00000488                            96  
00000488                            97  V_CTLC  ds.w    1           * save CTRL-C check entry point
0000048A                            98  V_CTLCv ds.l    1           * save CTRL-C check jump vector
0000048E                            99  
0000048E                           100  Itemp       ds.l    1           * temporary integer (for GOTO etc)
00000492                           101  
00000492                           102  Smeml       ds.l    1           * start of memory       (start of program)
00000496                           103  
00000496                           104  
00000496                           105  Sfncl       ds.l    1           * start of functions    (end of Program)
0000049A                           106  
0000049A                           107  
0000049A                           108  Svarl       ds.l    1           * start of variables    (end of functions)
0000049E                           109  
0000049E                           110  
0000049E                           111  Sstrl       ds.l    1           * start of strings  (end of variables)
000004A2                           112  
000004A2                           113  
000004A2                           114  Sarryl  ds.l    1           * start of arrays       (end of strings)
000004A6                           115  
000004A6                           116  
000004A6                           117  Earryl  ds.l    1           * end of arrays     (start of free mem)
000004AA                           118  Sstorl  ds.l    1           * string storage        (moving down)
000004AE                           119  Ememl       ds.l    1           * end of memory     (upper bound of RAM)
000004B2                           120  Sutill  ds.l    1           * string utility ptr
000004B6                           121  Clinel  ds.l    1           * current line      (Basic line number)
000004BA                           122  Blinel  ds.l    1           * break line        (Basic line number)
000004BE                           123  
000004BE                           124  Cpntrl  ds.l    1           * continue pointer
000004C2                           125  Dlinel  ds.l    1           * current DATA line
000004C6                           126  Dptrl       ds.l    1           * DATA pointer
000004CA                           127  Rdptrl  ds.l    1           * read pointer
000004CE                           128  Varname ds.l    1           * current var name
000004D2                           129  Cvaral  ds.l    1           * current var address
000004D6                           130  Lvarpl  ds.l    1           * variable pointer for LET and FOR/NEXT
000004DA                           131  
000004DA                           132  des_sk_e    ds.l    6           * descriptor stack end address
000004F2                           133  des_sk                  * descriptor stack start address
000004F2                           134                          * use a4 for the descriptor pointer
000004F2                           135          ds.w    1           
000004F4                           136  Ibuffs  ds.l    $40         * start of input buffer
000005F4                           137  Ibuffe
000005F4                           138                          * end of input buffer
000005F4                           139  
000005F4                           140  FAC1_m  ds.l    1           * FAC1 mantissa1
000005F8                           141  FAC1_e  ds.w    1           * FAC1 exponent
000005FA  =000005F9                142  FAC1_s  EQU FAC1_e+1        * FAC1 sign (b7)
000005FA                           143          ds.w    1           
000005FC                           144  
000005FC                           145  FAC2_m  ds.l    1           * FAC2 mantissa1
00000600                           146  FAC2_e  ds.l    1           * FAC2 exponent
00000604  =00000601                147  FAC2_s  EQU FAC2_e+1        * FAC2 sign (b7)
00000604  =00000602                148  FAC_sc  EQU FAC2_e+2        * FAC sign comparison, Acc#1 vs #2
00000604  =00000603                149  flag        EQU FAC2_e+3        * flag byte for divide routine
00000604                           150  
00000604                           151  PRNlword    ds.l    1           * PRNG seed long word
00000608                           152  
00000608                           153  ut1_pl  ds.l    1           * utility pointer 1
0000060C                           154  
0000060C                           155  Asptl       ds.l    1           * array size/pointer
00000610                           156  Astrtl  ds.l    1           * array start pointer
00000614                           157  
00000614  =00000610                158  numexp  EQU Astrtl      * string to float number exponent count
00000614  =00000611                159  expcnt  EQU Astrtl+1        * string to float exponent count
00000614                           160  
00000614  =00000613                161  expneg  EQU Astrtl+3        * string to float eval exponent -ve flag
00000614                           162  
00000614                           163  func_l  ds.l    1           * function pointer
00000618                           164  
00000618                           165  
00000618                           166                          * these two need to be a word aligned pair !
00000618                           167  Defdim  ds.w    1           * default DIM flag
0000061A  =00000618                168  cosout  EQU Defdim      * flag which CORDIC output (re-use byte)
0000061A  =00000619                169  Dtypef  EQU Defdim+1        * data type flag, $80=string, $40=integer, $00=float
0000061A                           170  
0000061A                           171  
0000061A                           172  Binss       ds.l    4           * number to bin string start (32 chrs)
0000062A                           173  
0000062A                           174  Decss       ds.l    1           * number to decimal string start (16 chrs)
0000062E                           175          ds.w    1           *
00000630                           176  Usdss       ds.w    1           * unsigned decimal string start (10 chrs)
00000632                           177  
00000632                           178  Hexss       ds.l    2           * number to hex string start (8 chrs)
0000063A                           179  
0000063A                           180  BHsend  ds.w    1           * bin/decimal/hex string end
0000063C                           181  
0000063C                           182  
0000063C                           183  prstk       ds.b    1           * stacked function index
0000063D                           184  
0000063D                           185  tpower  ds.b    1           * remember CORDIC power
0000063E                           186  
0000063E                           187  Asrch       ds.b    1           * scan-between-quotes flag, alt search character
0000063F                           188  
0000063F                           189  Dimcnt  ds.b    1           * # of dimensions
00000640                           190  
00000640                           191  Breakf  ds.b    1           * break flag, $00=END else=break
00000641                           192  Oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
00000642                           193  Gclctd  ds.b    1           * garbage collected flag
00000643                           194  Sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00000644                           195  Imode       ds.b    1           * input mode flag, $00=INPUT, $98=READ
00000645                           196  
00000645                           197  Cflag       ds.b    1           * comparison evaluation flag
00000646                           198  
00000646                           199  TabSiz  ds.b    1           * TAB step size
00000647                           200  
00000647                           201  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
00000648                           202                          * bit 2 set if >
00000648                           203                          * bit 1 set if =
00000648                           204                          * bit 0 set if <
00000648                           205  
00000648                           206  Nullct  ds.b    1           * nulls output after each line
00000649                           207  TPos        ds.b    1           * BASIC terminal position byte
0000064A                           208  TWidth  ds.b    1           * BASIC terminal width byte
0000064B                           209  Iclim       ds.b    1           * input column limit
0000064C                           210  ccflag  ds.b    1           * CTRL-C check flag
0000064D                           211  ccbyte  ds.b    1           * CTRL-C last received byte
0000064E                           212  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
0000064F                           213  
0000064F                           214  
0000064F                           215  file_byte   ds.b    1           * load/save data byte
00000650                           216  file_id ds.l    1           * load/save file ID
00000654                           217  
00000654                           218  even                    * dummy even value and zero pad byte
00000654                           219  
00000654                           220  -------------------- end include --------------------
00000654                           221                              * RAM offset definitions
00000654                           222  prg_strt
00000654                           223  * Use this value to run out of ROM
00B00000                           224      ORG $B00000         * past the vectors in a real system
00B00000                           225  * Use this value to run out of RAM
00B00000                           226  *   ORG     $000800         * past the vectors in a real system
00B00000                           227  
00B00000                           228  
00B00000                           229  
00B00000                           230  * Use these two lines when running from RAM
00B00000                           231  *ram_addr   EQU $04000      * RAM start address
00B00000                           232  *ram_size   EQU $04000      * RAM size
00B00000                           233  
00B00000                           234  * Use these two lines when running from ROM
00B00000  =00002000                235  ram_addr    EQU $02000      * RAM start address
00B00000  =00008000                236  ram_size    EQU $08000      * RAM size
00B00000                           237  
00B00000  =00F00009                238  ACIAC    EQU $F00009
00B00000  =00F0000B                239  ACIAD    EQU ACIAC+2
00B00000  =00000000                240  RDRF     EQU 0           ; ACIAC Receive Data Register Full
00B00000  =00000001                241  TDRE     EQU 1           ; ACIAC Transmit Data Register Empty
00B00000                           242  
00B00000  6000 003C                243           BRA    code_start       * For convenience, so you can start from first address
00B00004                           244  
00B00004                           245  *************************************************************************************
00B00004                           246  *
00B00004                           247  * the following code is simulator specific, change to suit your system
00B00004                           248  * output character to the console from register d0.b
00B00004                           249  
00B00004                           250  
00B00004                           251  VEC_OUT
00B00004  0839 0001 00F00009       252          BTST.B #TDRE,ACIAC.L
00B0000C  67F6                     253          BEQ.S  VEC_OUT
00B0000E  13C0 00F0000B            254          MOVE.B D0,ACIAD.L
00B00014  4E75                     255          RTS
00B00016                           256  
00B00016                           257  *************************************************************************************
00B00016                           258  *
00B00016                           259  * input a character from the console into register d0
00B00016                           260  * else return Cb=0 if theres no character available
00B00016                           261  
00B00016                           262  
00B00016                           263  VEC_IN
00B00016  0839 0000 00F00009       264          BTST.B #RDRF,ACIAC.L
00B0001E  670C                     265          BEQ.S  RXNOTREADY
00B00020  1039 00F0000B            266          MOVE.B ACIAD.L,D0
00B00026  003C 0001                267          ORI.b    #1,CCR         * Set the carry, flag we got a byte
00B0002A  4E75                     268          RTS                     * Return
00B0002C                           269  RXNOTREADY
00B0002C  023C 00FE                270          ANDI.b  #$FE,CCR    * Clear the carry, flag character available
00B00030  4E75                     271          RTS
00B00032                           272  
00B00032                           273  *************************************************************************************
00B00032                           274  *
00B00032                           275  * LOAD routine for the TS2 computer (not implemented)
00B00032                           276  
00B00032                           277  VEC_LD
00B00032  7E2E                     278      MOVEQ       #$2E,d7                 * error code $2E "Not implemented" error
00B00034  6000 013A                279      BRA     LAB_XERR            * do error #d7, then warm start
00B00038                           280  
00B00038                           281  *************************************************************************************
00B00038                           282  *
00B00038                           283  * SAVE routine for the TS2 computer (not implemented)
00B00038                           284  
00B00038                           285  VEC_SV
00B00038  7E2E                     286      MOVEQ       #$2E,d7                 * error code $2E "Not implemented" error
00B0003A  6000 0134                287      BRA     LAB_XERR            * do error #d7, then warm start
00B0003E                           288  
00B0003E                           289  *************************************************************************************
00B0003E                           290  *
00B0003E                           291  * turn off simulator key echo
00B0003E                           292  
00B0003E                           293  code_start
00B0003E                           294                                  * Set up ACIA parameters
00B0003E  41F9 00F00009            295          LEA.L   ACIAC,A0       * A0 points to console ACIA
00B00044  10BC 0015                296          MOVE.B  #$15,(A0)       * Set up ACIA1 constants (no IRQ,
00B00048                           297                                  * RTS* low, 8 bit, no parity, 1 stop)
00B00048                           298  
00B00048                           299  * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
00B00048                           300  * in d0. these values are at the end of the .inc file
00B00048                           301  
00B00048  207C 00002000            302      MOVEA.l #ram_addr,a0        * tell BASIC where RAM starts
00B0004E  203C 00008000            303      MOVE.l  #ram_size,d0        * tell BASIC how big RAM is
00B00054                           304  
00B00054                           305  * end of simulator specific code
00B00054                           306  
00B00054                           307  
00B00054                           308  ****************************************************************************************
00B00054                           309  ****************************************************************************************
00B00054                           310  ****************************************************************************************
00B00054                           311  ****************************************************************************************
00B00054                           312  *
00B00054                           313  * Register use :- (must improve this !!)
00B00054                           314  *
00B00054                           315  *   a6 -    temp Bpntr              * temporary BASIC execute pointer
00B00054                           316  *   a5 -    Bpntr                   * BASIC execute (get byte) pointer
00B00054                           317  *   a4 -    des_sk                      * descriptor stack pointer
00B00054                           318  *   a3 -    ram_strt                * start of RAM. all RAM references are offsets
00B00054                           319  *                           * from this value
00B00054                           320  *
00B00054                           321  
00B00054                           322  *************************************************************************************
00B00054                           323  *
00B00054                           324  * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
00B00054                           325  * in d0
00B00054                           326  
00B00054                           327  LAB_COLD
00B00054  B0BC 00004000            328      CMP.l       #$4000,d0           * compare size with 16k
00B0005A  6C08                     329      BGE.s       LAB_sizok           * branch if >= 16k
00B0005C                           330  
00B0005C  7005                     331      MOVEQ       #5,d0               * error 5 - not enough RAM
00B0005E  1E3C 00E4                332          move.b          #228,D7                         * Go to TUTOR function
00B00062  4E4E                     333          trap            #14                             * Call TRAP14 handler
00B00064                           334  
00B00064                           335  LAB_sizok
00B00064  2648                     336      MOVEA.l a0,a3               * copy RAM base to a3
00B00066  D1C0                     337      ADDA.l  d0,a0               * a0 is top of RAM
00B00068  2748 04AE                338      MOVE.l  a0,Ememl(a3)        * set end of mem
00B0006C  4FEB 0464                339      LEA     ram_base(a3),sp     * set stack to RAM start + 1k
00B00070                           340  
00B00070  303C 4EF9                341      MOVE.w  #$4EF9,d0           * JMP opcode
00B00074  204F                     342      MOVEA.l sp,a0               * point to start of vector table
00B00076                           343  
00B00076  30C0                     344      MOVE.w  d0,(a0)+            * LAB_WARM
00B00078  43FA FFDA                345      LEA     LAB_COLD(pc),a1     * initial warm start vector
00B0007C  20C9                     346      MOVE.l  a1,(a0)+            * set vector
00B0007E                           347  
00B0007E  30C0                     348      MOVE.w  d0,(a0)+            * Usrjmp
00B00080  43FA 00DC                349      LEA     LAB_FCER(pc),a1     * initial user function vector
00B00084                           350                              * "Function call" error
00B00084  20C9                     351      MOVE.l  a1,(a0)+            * set vector
00B00086                           352  
00B00086  30C0                     353      MOVE.w  d0,(a0)+            * V_INPT JMP opcode
00B00088  43FA FF8C                354      LEA     VEC_IN(pc),a1       * get byte from input device vector
00B0008C  20C9                     355      MOVE.l  a1,(a0)+            * set vector
00B0008E                           356  
00B0008E  30C0                     357      MOVE.w  d0,(a0)+            * V_OUTP JMP opcode
00B00090  43FA FF72                358      LEA     VEC_OUT(pc),a1      * send byte to output device vector
00B00094  20C9                     359      MOVE.l  a1,(a0)+            * set vector
00B00096                           360  
00B00096  30C0                     361      MOVE.w  d0,(a0)+            * V_LOAD JMP opcode
00B00098  43FA FF98                362      LEA     VEC_LD(pc),a1       * load BASIC program vector
00B0009C  20C9                     363      MOVE.l  a1,(a0)+            * set vector
00B0009E                           364  
00B0009E  30C0                     365      MOVE.w  d0,(a0)+            * V_SAVE JMP opcode
00B000A0  43FA FF96                366      LEA     VEC_SV(pc),a1       * save BASIC program vector
00B000A4  20C9                     367      MOVE.l  a1,(a0)+            * set vector
00B000A6                           368  
00B000A6  30C0                     369      MOVE.w  d0,(a0)+            * V_CTLC JMP opcode
00B000A8  43FA 261E                370      LEA     VEC_CC(pc),a1       * save CTRL-C check vector
00B000AC  20C9                     371      MOVE.l  a1,(a0)+            * set vector
00B000AE                           372  
00B000AE                           373  * set-up start values
00B000AE                           374  
00B000AE                           375  *##LAB_GMEM
00B000AE  7000                     376      MOVEQ       #$00,d0         * clear d0
00B000B0  1740 0648                377      MOVE.b  d0,Nullct(a3)       * default NULL count
00B000B4  1740 0649                378      MOVE.b  d0,TPos(a3)         * clear terminal position
00B000B8  1740 064C                379      MOVE.b  d0,ccflag(a3)       * allow CTRL-C check
00B000BC  3740 0652                380      MOVE.w  d0,prg_strt-2(a3)       * clear start word
00B000C0  3740 063A                381      MOVE.w  d0,BHsend(a3)       * clear value to string end word
00B000C4                           382  
00B000C4  177C 0050 064A           383      MOVE.b  #$50,TWidth(a3)     * default terminal width byte for simulator
00B000CA  177C 000E 0646           384      MOVE.b  #$0E,TabSiz(a3)     * save default tab size = 14
00B000D0                           385  
00B000D0  177C 0038 064B           386      MOVE.b  #$38,Iclim(a3)      * default limit for TAB = 14 for simulator
00B000D6                           387  
00B000D6  49EB 04F2                388      LEA     des_sk(a3),a4       * set descriptor stack start
00B000DA                           389  
00B000DA  41EB 0654                390      LEA     prg_strt(a3),a0     * get start of mem
00B000DE  2748 0492                391      MOVE.l  a0,Smeml(a3)        * save start of mem
00B000E2                           392  
00B000E2  6100 0322                393      BSR     LAB_1463            * do "NEW" and "CLEAR"
00B000E6  6100 0898                394      BSR     LAB_CRLF            * print CR/LF
00B000EA  202B 04AE                395      MOVE.l  Ememl(a3),d0        * get end of mem
00B000EE  90AB 0492                396      SUB.l       Smeml(a3),d0        * subtract start of mem
00B000F2                           397  
00B000F2  6100 1BCC                398      BSR     LAB_295E            * print d0 as unsigned integer (bytes free)
00B000F6  41FA 33EE                399      LEA     LAB_SMSG(pc),a0     * point to start message
00B000FA  6100 08E2                400      BSR     LAB_18C3            * print null terminated string from memory
00B000FE                           401  
00B000FE  41FA 29D2                402      LEA     LAB_RSED(pc),a0     * get pointer to value
00B00102  6100 1A68                403      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00B00106                           404  
00B00106  41FA 0092                405      LEA     LAB_1274(pc),a0     * get warm start vector
00B0010A  2748 0466                406      MOVE.l  a0,Wrmjpv(a3)       * set warm start vector
00B0010E  6100 1FD2                407      BSR     LAB_RND         * initialise
00B00112  4EEB 0464                408      JMP     LAB_WARM(a3)        * go do warm start
00B00116                           409  
00B00116                           410  
00B00116                           411  *************************************************************************************
00B00116                           412  *
00B00116                           413  * do format error
00B00116                           414  
00B00116                           415  LAB_FOER
00B00116  7E2C                     416      MOVEQ       #$2C,d7         * error code $2C "Format" error
00B00118  6056                     417      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0011A                           418  
00B0011A                           419  
00B0011A                           420  *************************************************************************************
00B0011A                           421  *
00B0011A                           422  * do address error
00B0011A                           423  
00B0011A                           424  LAB_ADER
00B0011A  7E2A                     425      MOVEQ       #$2A,d7         * error code $2A "Address" error
00B0011C  6052                     426      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0011E                           427  
00B0011E                           428  
00B0011E                           429  *************************************************************************************
00B0011E                           430  *
00B0011E                           431  * do wrong dimensions error
00B0011E                           432  
00B0011E                           433  LAB_WDER
00B0011E  7E28                     434      MOVEQ       #$28,d7         * error code $28 "Wrong dimensions" error
00B00120  604E                     435      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00122                           436  
00B00122                           437  
00B00122                           438  *************************************************************************************
00B00122                           439  *
00B00122                           440  * do undimensioned array error
00B00122                           441  
00B00122                           442  LAB_UDER
00B00122  7E26                     443      MOVEQ       #$26,d7         * error code $26 "undimensioned array" error
00B00124  604A                     444      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00126                           445  
00B00126                           446  
00B00126                           447  *************************************************************************************
00B00126                           448  *
00B00126                           449  * do undefined variable error
00B00126                           450  
00B00126                           451  LAB_UVER
00B00126                           452  
00B00126                           453  * if you do want a non existant variable to return an error then leave the novar
00B00126                           454  * value at the top of this file set to zero
00B00126                           455  
00B00126                 TRUE      456   ifeq   novar
00B00126                           457  
00B00126  7E24                     458      MOVEQ       #$24,d7         * error code $24 "undefined variable" error
00B00128  6046                     459      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0012A                           460  
00B0012A                           461   endc
00B0012A                           462  
00B0012A                           463  * if you want a non existant variable to return a null value then set the novar
00B0012A                           464  * value at the top of this file to some non zero value
00B0012A                           465  
00B0012A                 FALSE     466   ifne   novar
00B0012A                           467   endc
00B0012A                           468  
00B0012A                           469  
00B0012A                           470  *************************************************************************************
00B0012A                           471  *
00B0012A                           472  * do loop without do error
00B0012A                           473  
00B0012A                           474  LAB_LDER
00B0012A  7E22                     475      MOVEQ       #$22,d7         * error code $22 "LOOP without DO" error
00B0012C  6042                     476      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0012E                           477  
00B0012E                           478  
00B0012E                           479  *************************************************************************************
00B0012E                           480  *
00B0012E                           481  * do undefined function error
00B0012E                           482  
00B0012E                           483  LAB_UFER
00B0012E  7E20                     484      MOVEQ       #$20,d7         * error code $20 "Undefined function" error
00B00130  603E                     485      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00132                           486  
00B00132                           487  
00B00132                           488  *************************************************************************************
00B00132                           489  *
00B00132                           490  * do can't continue error
00B00132                           491  
00B00132                           492  LAB_CCER
00B00132  7E1E                     493      MOVEQ       #$1E,d7         * error code $1E "Can't continue" error
00B00134  603A                     494      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00136                           495  
00B00136                           496  
00B00136                           497  *************************************************************************************
00B00136                           498  *
00B00136                           499  * do string too complex error
00B00136                           500  
00B00136                           501  LAB_SCER
00B00136  7E1C                     502      MOVEQ       #$1C,d7         * error code $1C "String too complex" error
00B00138  6036                     503      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0013A                           504  
00B0013A                           505  
00B0013A                           506  *************************************************************************************
00B0013A                           507  *
00B0013A                           508  * do string too long error
00B0013A                           509  
00B0013A                           510  LAB_SLER
00B0013A  7E1A                     511      MOVEQ       #$1A,d7         * error code $1A "String too long" error
00B0013C  6032                     512      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0013E                           513  
00B0013E                           514  
00B0013E                           515  *************************************************************************************
00B0013E                           516  *
00B0013E                           517  * do type missmatch error
00B0013E                           518  
00B0013E                           519  LAB_TMER
00B0013E  7E18                     520      MOVEQ       #$18,d7         * error code $18 "Type mismatch" error
00B00140  602E                     521      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00142                           522  
00B00142                           523  
00B00142                           524  *************************************************************************************
00B00142                           525  *
00B00142                           526  * do illegal direct error
00B00142                           527  
00B00142                           528  LAB_IDER
00B00142  7E16                     529      MOVEQ       #$16,d7         * error code $16 "Illegal direct" error
00B00144  602A                     530      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00146                           531  
00B00146                           532  
00B00146                           533  *************************************************************************************
00B00146                           534  *
00B00146                           535  * do divide by zero error
00B00146                           536  
00B00146                           537  LAB_DZER
00B00146  7E14                     538      MOVEQ       #$14,d7         * error code $14 "Divide by zero" error
00B00148  6026                     539      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0014A                           540  
00B0014A                           541  
00B0014A                           542  *************************************************************************************
00B0014A                           543  *
00B0014A                           544  * do double dimension error
00B0014A                           545  
00B0014A                           546  LAB_DDER
00B0014A  7E12                     547      MOVEQ       #$12,d7         * error code $12 "Double dimension" error
00B0014C  6022                     548      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0014E                           549  
00B0014E                           550  
00B0014E                           551  *************************************************************************************
00B0014E                           552  *
00B0014E                           553  * do array bounds error
00B0014E                           554  
00B0014E                           555  LAB_ABER
00B0014E  7E10                     556      MOVEQ       #$10,d7         * error code $10 "Array bounds" error
00B00150  601E                     557      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00152                           558  
00B00152                           559  
00B00152                           560  *************************************************************************************
00B00152                           561  *
00B00152                           562  * do undefined satement error
00B00152                           563  
00B00152                           564  LAB_USER
00B00152  7E0E                     565      MOVEQ       #$0E,d7         * error code $0E "Undefined statement" error
00B00154  601A                     566      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00156                           567  
00B00156                           568  
00B00156                           569  *************************************************************************************
00B00156                           570  *
00B00156                           571  * do out of memory error
00B00156                           572  
00B00156                           573  LAB_OMER
00B00156  7E0C                     574      MOVEQ       #$0C,d7         * error code $0C "Out of memory" error
00B00158  6016                     575      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0015A                           576  
00B0015A                           577  
00B0015A                           578  *************************************************************************************
00B0015A                           579  *
00B0015A                           580  * do overflow error
00B0015A                           581  
00B0015A                           582  LAB_OFER
00B0015A  7E0A                     583      MOVEQ       #$0A,d7         * error code $0A "Overflow" error
00B0015C  6012                     584      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0015E                           585  
00B0015E                           586  
00B0015E                           587  *************************************************************************************
00B0015E                           588  *
00B0015E                           589  * do function call error
00B0015E                           590  
00B0015E                           591  LAB_FCER
00B0015E  7E08                     592      MOVEQ       #$08,d7         * error code $08 "Function call" error
00B00160  600E                     593      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00162                           594  
00B00162                           595  
00B00162                           596  *************************************************************************************
00B00162                           597  *
00B00162                           598  * do out of data error
00B00162                           599  
00B00162                           600  LAB_ODER
00B00162  7E06                     601      MOVEQ       #$06,d7         * error code $06 "Out of DATA" error
00B00164  600A                     602      BRA.s       LAB_XERR            * do error #d7, then warm start
00B00166                           603  
00B00166                           604  
00B00166                           605  *************************************************************************************
00B00166                           606  *
00B00166                           607  * do return without gosub error
00B00166                           608  
00B00166                           609  LAB_RGER
00B00166  7E04                     610      MOVEQ       #$04,d7         * error code $04 "RETURN without GOSUB" error
00B00168  6006                     611      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0016A                           612  
00B0016A                           613  
00B0016A                           614  *************************************************************************************
00B0016A                           615  *
00B0016A                           616  * do syntax error
00B0016A                           617  
00B0016A                           618  LAB_SNER
00B0016A  7E02                     619      MOVEQ       #$02,d7         * error code $02 "Syntax" error
00B0016C  6002                     620      BRA.s       LAB_XERR            * do error #d7, then warm start
00B0016E                           621  
00B0016E                           622  
00B0016E                           623  *************************************************************************************
00B0016E                           624  *
00B0016E                           625  * do next without for error
00B0016E                           626  
00B0016E                           627  LAB_NFER
00B0016E  7E00                     628      MOVEQ       #$00,d7         * error code $00 "NEXT without FOR" error
00B00170                           629  
00B00170                           630  
00B00170                           631  *************************************************************************************
00B00170                           632  *
00B00170                           633  * do error #d7, then warm start
00B00170                           634  
00B00170                           635  LAB_XERR
00B00170  6100 02CA                636      BSR     LAB_1491            * flush stack & clear continue flag
00B00174  6100 080A                637      BSR     LAB_CRLF            * print CR/LF
00B00178  43FA 2FE4                638      LEA     LAB_BAER(pc),a1     * start of error message pointer table
00B0017C  3E31 7000                639      MOVE.w  (a1,d7.w),d7        * get error message offset
00B00180  41F1 7000                640      LEA     (a1,d7.w),a0        * get error message address
00B00184  6100 0858                641      BSR     LAB_18C3            * print null terminated string from memory
00B00188  41FA 331F                642      LEA     LAB_EMSG(pc),a0     * point to " Error" message
00B0018C                           643  LAB_1269
00B0018C  6100 0850                644      BSR     LAB_18C3            * print null terminated string from memory
00B00190  202B 04B6                645      MOVE.l  Clinel(a3),d0       * get current line
00B00194  6B04                     646      BMI.s       LAB_1274            * go do warm start if -ve # (was immediate mode)
00B00196                           647  
00B00196                           648                              * else print line number
00B00196  6100 1B1C                649      BSR     LAB_2953            * print " in line [LINE #]"
00B0019A                           650  
00B0019A                           651  * BASIC warm start entry point, wait for Basic command
00B0019A                           652  
00B0019A                           653  LAB_1274
00B0019A  41FA 3340                654      LEA     LAB_RMSG(pc),a0     * point to "Ready" message
00B0019E  6100 083E                655      BSR     LAB_18C3            * go do print string
00B001A2                           656  
00B001A2                           657  * wait for Basic command - no "Ready"
00B001A2                           658  
00B001A2                           659  LAB_127D
00B001A2  72FF                     660      MOVEQ       #-1,d1          * set to -1
00B001A4  2741 04B6                661      MOVE.l  d1,Clinel(a3)       * set current line #
00B001A8  1741 0640                662      MOVE.b  d1,Breakf(a3)       * set break flag
00B001AC  4BEB 04F4                663      LEA     Ibuffs(a3),a5       * set basic execute pointer ready for new line
00B001B0                           664  LAB_127E
00B001B0  6100 00EC                665      BSR     LAB_1357            * call for BASIC input
00B001B4  6100 0BF4                666      BSR     LAB_GBYT            * scan memory
00B001B8  67F6                     667      BEQ.s       LAB_127E            * loop while null
00B001BA                           668  
00B001BA                           669  * got to interpret input line now ....
00B001BA                           670  
00B001BA  6508                     671      BCS.s       LAB_1295            * branch if numeric character, handle new
00B001BC                           672                              * BASIC line
00B001BC                           673  
00B001BC                           674                              * no line number so do immediate mode, a5
00B001BC                           675                              * points to the buffer start
00B001BC  6100 0156                676      BSR     LAB_13A6            * crunch keywords into Basic tokens
00B001C0                           677                              * crunch from (a5), output to (a0)
00B001C0                           678                              * returns ..
00B001C0                           679                              * d2 is length, d1 trashed, d0 trashed,
00B001C0                           680                              * a1 trashed
00B001C0  6000 03C4                681      BRA     LAB_15F6            * go scan & interpret code
00B001C4                           682  
00B001C4                           683  
00B001C4                           684  *************************************************************************************
00B001C4                           685  *
00B001C4                           686  * handle a new BASIC line
00B001C4                           687  
00B001C4                           688  LAB_1295
00B001C4  6100 063A                689      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00B001C8  6100 014A                690      BSR     LAB_13A6            * crunch keywords into Basic tokens
00B001CC                           691                              * crunch from (a5), output to (a0)
00B001CC                           692                              * returns .. d2 is length,
00B001CC                           693                              * d1 trashed, d0 trashed, a1 trashed
00B001CC  222B 048E                694      MOVE.l  Itemp(a3),d1        * get required line #
00B001D0  6100 0218                695      BSR     LAB_SSLN            * search BASIC for d1 line number
00B001D4                           696                              * returns pointer in a0
00B001D4  6532                     697      BCS.s       LAB_12E6            * branch if not found
00B001D6                           698  
00B001D6                           699                              * aroooogah! line # already exists! delete it
00B001D6  2250                     700      MOVEA.l (a0),a1         * get start of block (next line pointer)
00B001D8  202B 0496                701      MOVE.l  Sfncl(a3),d0        * get end of block (start of functions)
00B001DC  9089                     702      SUB.l       a1,d0               * subtract start of block ( = bytes to move)
00B001DE  E288                     703      LSR.l       #1,d0               * /2 (word move)
00B001E0  5380                     704      SUBQ.l  #1,d0               * adjust for DBF loop
00B001E2  4840                     705      SWAP        d0              * swap high word to low word
00B001E4  2448                     706      MOVEA.l a0,a2               * copy destination
00B001E6                           707  LAB_12AE
00B001E6  4840                     708      SWAP        d0              * swap high word to low word
00B001E8                           709  LAB_12B0
00B001E8  34D9                     710      MOVE.w  (a1)+,(a2)+         * copy word
00B001EA  51C8 FFFC                711      DBF     d0,LAB_12B0         * decrement low count and loop until done
00B001EE                           712  
00B001EE  4840                     713      SWAP        d0              * swap high word to low word
00B001F0  51C8 FFF4                714      DBF     d0,LAB_12AE         * decrement high count and loop until done
00B001F4                           715  
00B001F4  274A 0496                716      MOVE.l  a2,Sfncl(a3)        * start of functions
00B001F8  274A 049A                717      MOVE.l  a2,Svarl(a3)        * save start of variables
00B001FC  274A 049E                718      MOVE.l  a2,Sstrl(a3)        * start of strings
00B00200  274A 04A2                719      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00B00204  274A 04A6                720      MOVE.l  a2,Earryl(a3)       * save end of arrays
00B00208                           721  
00B00208                           722                              * got new line in buffer and no existing same #
00B00208                           723  LAB_12E6
00B00208  102B 04F4                724      MOVE.b  Ibuffs(a3),d0       * get byte from start of input buffer
00B0020C  6764                     725      BEQ.s       LAB_1325            * if null line go do line chaining
00B0020E                           726  
00B0020E                           727                              * got new line and it isn't empty line
00B0020E  226B 0496                728      MOVEA.l Sfncl(a3),a1        * get start of functions (end of block to move)
00B00212  45F1 2008                729      LEA     8(a1,d2),a2         * copy it, add line length and add room for
00B00216                           730                              * pointer and line number
00B00216                           731  
00B00216  274A 0496                732      MOVE.l  a2,Sfncl(a3)        * start of functions
00B0021A  274A 049A                733      MOVE.l  a2,Svarl(a3)        * save start of variables
00B0021E  274A 049E                734      MOVE.l  a2,Sstrl(a3)        * start of strings
00B00222  274A 04A2                735      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00B00226  274A 04A6                736      MOVE.l  a2,Earryl(a3)       * save end of arrays
00B0022A  276B 04AE 04AA           737      MOVE.l  Ememl(a3),Sstorl(a3)    * copy end of mem to start of strings, clear
00B00230                           738                              * strings
00B00230                           739  
00B00230  2209                     740      MOVE.l  a1,d1               * copy end of block to move
00B00232  9288                     741      SUB.l       a0,d1               * subtract start of block to move
00B00234  E289                     742      LSR.l       #1,d1               * /2 (word copy)
00B00236  5381                     743      SUBQ.l  #1,d1               * correct for loop end on -1
00B00238  4841                     744      SWAP        d1              * swap high word to low word
00B0023A                           745  LAB_12FF
00B0023A  4841                     746      SWAP        d1              * swap high word to low word
00B0023C                           747  LAB_1301
00B0023C  3521                     748      MOVE.w  -(a1),-(a2)         * decrement pointers and copy word
00B0023E  51C9 FFFC                749      DBF     d1,LAB_1301         * decrement & loop
00B00242                           750  
00B00242  4841                     751      SWAP        d1              * swap high word to low word
00B00244  51C9 FFF4                752      DBF     d1,LAB_12FF         * decrement high count and loop until done
00B00248                           753  
00B00248                           754  * space is opened up, now copy the crunched line from the input buffer into the space
00B00248                           755  
00B00248  43EB 04F4                756      LEA     Ibuffs(a3),a1       * source is input buffer
00B0024C  2448                     757      MOVEA.l a0,a2               * copy destination
00B0024E  72FF                     758      MOVEQ       #-1,d1          * set to allow re-chaining
00B00250  24C1                     759      MOVE.l  d1,(a2)+            * set next line pointer (allow re-chaining)
00B00252  24EB 048E                760      MOVE.l  Itemp(a3),(a2)+     * save line number
00B00256  E24A                     761      LSR.w       #1,d2               * /2 (word copy)
00B00258  5342                     762      SUBQ.w  #1,d2               * correct for loop end on -1
00B0025A                           763  LAB_1303
00B0025A  34D9                     764      MOVE.w  (a1)+,(a2)+         * copy word
00B0025C  51CA FFFC                765      DBF     d2,LAB_1303         * decrement & loop
00B00260                           766  
00B00260  6010                     767      BRA.s       LAB_1325            * go test for end of prog
00B00262                           768  
00B00262                           769  * rebuild chaining of BASIC lines
00B00262                           770  
00B00262                           771  LAB_132E
00B00262  5048                     772      ADDQ.w  #8,a0               * point to first code byte of line, there is
00B00264                           773                              * always 1 byte + [EOL] as null entries are
00B00264                           774                              * deleted
00B00264                           775  LAB_1330
00B00264  4A18                     776      TST.b       (a0)+               * test byte 
00B00266  66FC                     777      BNE.s       LAB_1330            * loop if not [EOL]
00B00268                           778  
00B00268                           779                              * was [EOL] so get next line start
00B00268  3208                     780      MOVE.w  a0,d1               * past pad byte(s)
00B0026A  0241 0001                781      ANDI.w  #1,d1               * mask odd bit
00B0026E  D0C1                     782      ADD.w       d1,a0               * add back to ensure even
00B00270  2288                     783      MOVE.l  a0,(a1)         * save next line pointer to current line
00B00272                           784  LAB_1325
00B00272  2248                     785      MOVEA.l a0,a1               * copy pointer for this line
00B00274  4A90                     786      TST.l       (a0)                * test pointer to next line
00B00276  66EA                     787      BNE.s       LAB_132E            * not end of program yet so we must
00B00278                           788                              * go and fix the pointers
00B00278                           789  
00B00278  6100 0198                790      BSR     LAB_1477            * reset execution to start, clear variables
00B0027C                           791                              * and flush stack
00B0027C  6000 FF24                792      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
00B00280                           793  
00B00280                           794  
00B00280                           795  *************************************************************************************
00B00280                           796  *
00B00280                           797  * receive a line from the keyboard
00B00280                           798                              * character $08 as delete key, BACKSPACE on
00B00280                           799                              * standard keyboard
00B00280                           800  LAB_134B
00B00280  6100 0776                801      BSR     LAB_PRNA            * go print the character
00B00284  7020                     802      MOVEQ       #' ',d0         * load [SPACE]
00B00286  6100 0770                803      BSR     LAB_PRNA            * go print
00B0028A  7008                     804      MOVEQ       #$08,d0         * load [BACKSPACE]
00B0028C  6100 076A                805      BSR     LAB_PRNA            * go print
00B00290  5341                     806      SUBQ.w  #$01,d1         * decrement the buffer index (delete)
00B00292  6010                     807      BRA.s       LAB_1359            * re-enter loop
00B00294                           808  
00B00294                           809  * print "? " and get BASIC input
00B00294                           810  * return a0 pointing to the buffer start
00B00294                           811  
00B00294                           812  LAB_INLN
00B00294  6100 0760                813      BSR     LAB_18E3            * print "?" character
00B00298  7020                     814      MOVEQ       #' ',d0         * load " "
00B0029A  6100 075C                815      BSR     LAB_PRNA            * go print
00B0029E                           816  
00B0029E                           817  * call for BASIC input (main entry point)
00B0029E                           818  * return a0 pointing to the buffer start
00B0029E                           819  
00B0029E                           820  LAB_1357
00B0029E  7200                     821      MOVEQ       #$00,d1         * clear buffer index
00B002A0  41EB 04F4                822      LEA     Ibuffs(a3),a0       * set buffer base pointer
00B002A4                           823  LAB_1359
00B002A4  4EAB 0470                824      JSR     V_INPT(a3)          * call scan input device
00B002A8  64FA                     825      BCC.s       LAB_1359            * loop if no byte
00B002AA                           826  
00B002AA  67F8                     827      BEQ.s       LAB_1359            * loop if null byte
00B002AC                           828  
00B002AC  B03C 0007                829      CMP.b       #$07,d0         * compare with [BELL]
00B002B0  6718                     830      BEQ.s       LAB_1378            * branch if [BELL]
00B002B2                           831  
00B002B2  B03C 000D                832      CMP.b       #$0D,d0         * compare with [CR]
00B002B6  6700 06C2                833      BEQ     LAB_1866            * do CR/LF exit if [CR]
00B002BA                           834  
00B002BA  4A41                     835      TST.w       d1              * set flags on buffer index
00B002BC  6606                     836      BNE.s       LAB_1374            * branch if not empty
00B002BE                           837  
00B002BE                           838  * the next two lines ignore any non printing character and [SPACE] if the input buffer
00B002BE                           839  * is empty
00B002BE                           840  
00B002BE  B03C 0020                841      CMP.b       #' ',d0         * compare with [SP]+1
00B002C2  63E0                     842      BLS.s       LAB_1359            * if < ignore character
00B002C4                           843  
00B002C4                           844  *## CMP.b       #' '+1,d0           * compare with [SP]+1
00B002C4                           845  *## BCS.s       LAB_1359            * if < ignore character
00B002C4                           846  
00B002C4                           847  LAB_1374
00B002C4  B03C 0008                848      CMP.b       #$08,d0         * compare with [BACKSPACE]
00B002C8  67B6                     849      BEQ.s       LAB_134B            * go delete last character
00B002CA                           850  
00B002CA                           851  LAB_1378
00B002CA  B27C 00FF                852      CMP.w       #(Ibuffe-Ibuffs-1),d1   * compare character count with max-1
00B002CE  640C                     853      BCC.s       LAB_138E            * skip store & do [BELL] if buffer full
00B002D0                           854  
00B002D0  1180 1000                855      MOVE.b  d0,(a0,d1.w)        * else store in buffer
00B002D4  5241                     856      ADDQ.w  #$01,d1         * increment index
00B002D6                           857  LAB_137F
00B002D6  6100 0720                858      BSR     LAB_PRNA            * go print the character
00B002DA  60C8                     859      BRA.s       LAB_1359            * always loop for next character
00B002DC                           860  
00B002DC                           861  * announce buffer full
00B002DC                           862  
00B002DC                           863  LAB_138E
00B002DC  7007                     864      MOVEQ       #$07,d0         * [BELL] character into d0
00B002DE  60F6                     865      BRA.s       LAB_137F            * go print the [BELL] but ignore input character
00B002E0                           866  
00B002E0                           867  
00B002E0                           868  *************************************************************************************
00B002E0                           869  *
00B002E0                           870  * copy a hex value without crunching
00B002E0                           871  
00B002E0                           872  LAB_1392
00B002E0  1180 2000                873      MOVE.b  d0,(a0,d2.w)        * save the byte to the output
00B002E4  5242                     874      ADDQ.w  #1,d2               * increment the buffer save index
00B002E6                           875  
00B002E6  5241                     876      ADDQ.w  #1,d1               * increment the buffer read index
00B002E8  1035 1000                877      MOVE.b  (a5,d1.w),d0        * get a byte from the input buffer
00B002EC  6700 0094                878      BEQ     LAB_13EC            * if [EOL] go save it without crunching
00B002F0                           879  
00B002F0  B03C 0020                880      CMP.b       #' ',d0         * compare the character with " "
00B002F4  67EA                     881      BEQ.s       LAB_1392            * if [SPACE] just go save it and get another
00B002F6                           882  
00B002F6  B03C 0030                883      CMP.b       #'0',d0         * compare the character with "0"
00B002FA  654A                     884      BCS.s       LAB_13C6            * if < "0" quit the hex save loop
00B002FC                           885  
00B002FC  B03C 0039                886      CMP.b       #'9',d0         * compare with "9"
00B00300  63DE                     887      BLS.s       LAB_1392            * if it is "0" to "9" save it and get another
00B00302                           888  
00B00302  7ADF                     889      MOVEQ       #-33,d5         * mask xx0x xxxx, ASCII upper case
00B00304  CA00                     890      AND.b       d0,d5               * mask the character
00B00306                           891  
00B00306  BA3C 0041                892      CMP.b       #'A',d5         * compare with "A"
00B0030A  6540                     893      BCS.s       LAB_13CC            * if < "A" quit the hex save loop
00B0030C                           894  
00B0030C  BA3C 0046                895      CMP.b       #'F',d5         * compare with "F"
00B00310  63CE                     896      BLS.s       LAB_1392            * if it is "A" to "F" save it and get another
00B00312                           897  
00B00312  6038                     898      BRA.s       LAB_13CC            * else continue crunching
00B00314                           899  
00B00314                           900  * crunch keywords into Basic tokens
00B00314                           901  * crunch from (a5), output to (a0)
00B00314                           902  * returns ..
00B00314                           903  * d4 trashed
00B00314                           904  * d3 trashed
00B00314                           905  * d2 is length
00B00314                           906  * d1 trashed
00B00314                           907  * d0 trashed
00B00314                           908  * a1 trashed
00B00314                           909  
00B00314                           910  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00B00314                           911  * old list search
00B00314                           912  
00B00314                           913  LAB_13A6
00B00314  7200                     914      MOVEQ       #0,d1               * clear the read index
00B00316  2401                     915      MOVE.l  d1,d2               * clear the save index
00B00318  1741 0641                916      MOVE.b  d1,Oquote(a3)       * clear the open quote/DATA flag
00B0031C                           917  LAB_13AC
00B0031C  7000                     918      MOVEQ       #0,d0               * clear word
00B0031E  1035 1000                919      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00B00322  675E                     920      BEQ.s       LAB_13EC            * if null save byte then continue crunching
00B00324                           921  
00B00324  B03C 005F                922      CMP.b       #'_',d0         * compare with "_"
00B00328  6458                     923      BCC.s       LAB_13EC            * if >= "_" save byte then continue crunching
00B0032A                           924  
00B0032A  B03C 003C                925      CMP.b       #'<',d0         * compare with "<"
00B0032E  641C                     926      BCC.s       LAB_13CC            * if >= "<" go crunch
00B00330                           927  
00B00330  B03C 0030                928      CMP.b       #'0',d0         * compare with "0"
00B00334  644C                     929      BCC.s       LAB_13EC            * if >= "0" save byte then continue crunching
00B00336                           930  
00B00336  1740 063E                931      MOVE.b  d0,Asrch(a3)        * save buffer byte as search character
00B0033A  B03C 0022                932      CMP.b       #$22,d0         * is it quote character?
00B0033E  6776                     933      BEQ.s       LAB_1410            * branch if so (copy quoted string)
00B00340                           934  
00B00340  B03C 0024                935      CMP.b       #'$',d0         * is it the hex value character?
00B00344  679A                     936      BEQ.s       LAB_1392            * if so go copy a hex value
00B00346                           937  
00B00346                           938  LAB_13C6
00B00346  B03C 002A                939      CMP.b       #'*',d0         * compare with "*"
00B0034A  6536                     940      BCS.s       LAB_13EC            * if <= "*" save byte then continue crunching
00B0034C                           941  
00B0034C                           942                              * crunch rest
00B0034C                           943  LAB_13CC
00B0034C  082B 0006 0641           944      BTST.b  #6,Oquote(a3)       * test open quote/DATA token flag
00B00352  662E                     945      BNE.s       LAB_13EC            * branch if b6 of Oquote set (was DATA)
00B00354                           946                              * go save byte then continue crunching
00B00354                           947  
00B00354  0400 002A                948      SUB.b       #$2A,d0         * normalise byte
00B00358  D040                     949      ADD.w       d0,d0               * *2 makes word offset (high byte=$00)
00B0035A  43FA 2C04                950      LEA     TAB_CHRT(pc),a1     * get keyword offset table address
00B0035E  3031 0000                951      MOVE.w  (a1,d0.w),d0        * get offset into keyword table
00B00362  6B6E                     952      BMI.s       LAB_141F            * branch if no keywords for character
00B00364                           953  
00B00364  43FA 2F90                954      LEA     TAB_STAR(pc),a1     * get keyword table address
00B00368  D2C0                     955      ADDA.w  d0,a1               * add keyword offset
00B0036A  76FF                     956      MOVEQ       #-1,d3          * clear index
00B0036C  3801                     957      MOVE.w  d1,d4               * copy read index
00B0036E                           958  LAB_13D6
00B0036E  5243                     959      ADDQ.w  #1,d3               * increment table index
00B00370  1031 3000                960      MOVE.b  (a1,d3.w),d0        * get byte from table
00B00374                           961  LAB_13D8
00B00374  6B0A                     962      BMI.s       LAB_13EA            * branch if token, save token and continue
00B00376                           963                              * crunching
00B00376                           964  
00B00376  5244                     965      ADDQ.w  #1,d4               * increment read index
00B00378  B035 4000                966      CMP.b       (a5,d4.w),d0        * compare byte from input buffer
00B0037C  67F0                     967      BEQ.s       LAB_13D6            * loop if character match
00B0037E                           968  
00B0037E  6040                     969      BRA.s       LAB_1417            * branch if no match
00B00380                           970  
00B00380                           971  LAB_13EA
00B00380  3204                     972      MOVE.w  d4,d1               * update read index
00B00382                           973  LAB_13EC
00B00382  1180 2000                974      MOVE.b  d0,(a0,d2.w)        * save byte to output
00B00386  5242                     975      ADDQ.w  #1,d2               * increment buffer save index
00B00388  5241                     976      ADDQ.w  #1,d1               * increment buffer read index
00B0038A  4A00                     977      TST.b       d0              * set flags
00B0038C  674A                     978      BEQ.s       LAB_142A            * branch if was null [EOL]
00B0038E                           979  
00B0038E                           980                              * d0 holds token or byte here
00B0038E  0400 003A                981      SUB.b       #$3A,d0         * subtract ":"
00B00392  6706                     982      BEQ.s       LAB_13FF            * branch if it was ":" (is now $00)
00B00394                           983  
00B00394                           984                              * d0 now holds token-$3A
00B00394  B03C 0049                985      CMP.b       #(TK_DATA-$3A),d0       * compare with DATA token - $3A
00B00398  6604                     986      BNE.s       LAB_1401            * branch if not DATA
00B0039A                           987  
00B0039A                           988                              * token was : or DATA
00B0039A                           989  LAB_13FF
00B0039A  1740 0641                990      MOVE.b  d0,Oquote(a3)       * save token-$3A ($00 for ":", TK_DATA-$3A for
00B0039E                           991                              * DATA)
00B0039E                           992  LAB_1401
00B0039E  0400 0055                993      SUB.b       #(TK_REM-$3A),d0        * subtract REM token offset
00B003A2  6600 FF78                994      BNE     LAB_13AC            * If wasn't REM then go crunch rest of line
00B003A6                           995  
00B003A6  1740 063E                996      MOVE.b  d0,Asrch(a3)        * else was REM so set search for [EOL]
00B003AA                           997  
00B003AA                           998                              * loop for REM, "..." etc.
00B003AA                           999  LAB_1408
00B003AA  1035 1000               1000      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00B003AE  67D2                    1001      BEQ.s       LAB_13EC            * branch if null [EOL]
00B003B0                          1002  
00B003B0  B02B 063E               1003      CMP.b       Asrch(a3),d0        * compare with stored character
00B003B4  67CC                    1004      BEQ.s       LAB_13EC            * branch if match (end quote, REM, :, or DATA)
00B003B6                          1005  
00B003B6                          1006                              * entry for copy string in quotes, don't crunch
00B003B6                          1007  LAB_1410
00B003B6  1180 2000               1008      MOVE.b  d0,(a0,d2.w)        * save byte to output
00B003BA  5242                    1009      ADDQ.w  #1,d2               * increment buffer save index
00B003BC  5241                    1010      ADDQ.w  #1,d1               * increment buffer read index
00B003BE  60EA                    1011      BRA.s       LAB_1408            * loop
00B003C0                          1012  
00B003C0                          1013  * not found keyword this go so find the end of this word in the table
00B003C0                          1014  
00B003C0                          1015  LAB_1417
00B003C0  3801                    1016      MOVE.w  d1,d4               * reset read pointer
00B003C2                          1017  LAB_141B
00B003C2  5243                    1018      ADDQ.w  #1,d3               * increment keyword table pointer, flag
00B003C4                          1019                              * unchanged
00B003C4  1031 3000               1020      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00B003C8  6AF8                    1021      BPL.s       LAB_141B            * if not end of keyword go do next byte
00B003CA                          1022  
00B003CA  5243                    1023      ADDQ.w  #1,d3               * increment keyword table pointer flag
00B003CC                          1024                              * unchanged
00B003CC  1031 3000               1025      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00B003D0  66A2                    1026      BNE.s       LAB_13D8            * go test next word if not zero byte (table end)
00B003D2                          1027  
00B003D2                          1028                              * reached end of table with no match
00B003D2                          1029  LAB_141F
00B003D2  1035 1000               1030      MOVE.b  (a5,d1.w),d0        * restore byte from input buffer
00B003D6  60AA                    1031      BRA.s       LAB_13EC            * go save byte in output and continue crunching
00B003D8                          1032  
00B003D8                          1033                              * reached [EOL]
00B003D8                          1034  LAB_142A
00B003D8  7000                    1035      MOVEQ       #0,d0               * ensure longword clear
00B003DA  0102                    1036      BTST        d0,d2               * test odd bit (fastest)
00B003DC  6706                    1037      BEQ.s       LAB_142C            * branch if no bytes to fill
00B003DE                          1038  
00B003DE  1180 2000               1039      MOVE.b  d0,(a0,d2.w)        * clear next byte
00B003E2  5242                    1040      ADDQ.w  #1,d2               * increment buffer save index
00B003E4                          1041  LAB_142C
00B003E4  2180 2000               1042      MOVE.l  d0,(a0,d2.w)        * clear next line pointer, EOT in immediate mode
00B003E8  4E75                    1043      RTS
00B003EA                          1044  
00B003EA                          1045  
00B003EA                          1046  *************************************************************************************
00B003EA                          1047  *
00B003EA                          1048  * search Basic for d1 line number from start of mem
00B003EA                          1049  
00B003EA                          1050  LAB_SSLN
00B003EA  206B 0492               1051      MOVEA.l Smeml(a3),a0        * get start of program mem
00B003EE  6002                    1052      BRA.s       LAB_SCLN            * go search for required line from a0
00B003F0                          1053  
00B003F0                          1054  LAB_145F
00B003F0  2040                    1055      MOVEA.l d0,a0               * copy next line pointer
00B003F2                          1056  
00B003F2                          1057  * search Basic for d1 line number from a0
00B003F2                          1058  * returns Cb=0 if found
00B003F2                          1059  * returns a0 pointer to found or next higher (not found) line
00B003F2                          1060  
00B003F2                          1061  LAB_SCLN
00B003F2  2018                    1062      MOVE.l  (a0)+,d0            * get next line pointer and point to line #
00B003F4  6708                    1063      BEQ.s       LAB_145E            * is end marker so we're done, do 'no line' exit
00B003F6                          1064  
00B003F6  B290                    1065      CMP.l       (a0),d1         * compare this line # with required line #
00B003F8  6EF6                    1066      BGT.s       LAB_145F            * loop if required # > this #
00B003FA                          1067  
00B003FA  5948                    1068      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00B003FC  4E75                    1069      RTS
00B003FE                          1070  
00B003FE                          1071  LAB_145E
00B003FE  5948                    1072      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00B00400  5380                    1073      SUBQ.l  #1,d0               * make end program found = -1, set carry
00B00402  4E75                    1074      RTS
00B00404                          1075  
00B00404                          1076  
00B00404                          1077  *************************************************************************************
00B00404                          1078  *
00B00404                          1079  * perform NEW
00B00404                          1080  
00B00404                          1081  LAB_NEW
00B00404  664C                    1082      BNE.s       RTS_005         * exit if not end of statement (do syntax error)
00B00406                          1083  
00B00406                          1084  LAB_1463
00B00406  206B 0492               1085      MOVEA.l Smeml(a3),a0        * point to start of program memory
00B0040A  7000                    1086      MOVEQ       #0,d0               * clear longword
00B0040C  20C0                    1087      MOVE.l  d0,(a0)+            * clear first line, next line pointer
00B0040E  2748 0496               1088      MOVE.l  a0,Sfncl(a3)        * set start of functions
00B00412                          1089  
00B00412                          1090  * reset execution to start, clear variables and flush stack
00B00412                          1091  
00B00412                          1092  LAB_1477
00B00412  2A6B 0492               1093      MOVEA.l Smeml(a3),a5        * reset BASIC execute pointer
00B00416  534D                    1094      SUBQ.w  #1,a5               * -1 (as end of previous line)
00B00418                          1095  
00B00418                          1096  * "CLEAR" command gets here
00B00418                          1097  
00B00418                          1098  LAB_147A
00B00418  276B 04AE 04AA          1099      MOVE.l  Ememl(a3),Sstorl(a3)    * save end of mem as bottom of string space
00B0041E  202B 0496               1100      MOVE.l  Sfncl(a3),d0        * get start of functions
00B00422  2740 049A               1101      MOVE.l  d0,Svarl(a3)        * start of variables
00B00426  2740 049E               1102      MOVE.l  d0,Sstrl(a3)        * start of strings
00B0042A  2740 04A2               1103      MOVE.l  d0,Sarryl(a3)       * set start of arrays
00B0042E  2740 04A6               1104      MOVE.l  d0,Earryl(a3)       * set end of arrays
00B00432                          1105  LAB_1480
00B00432  7000                    1106      MOVEQ       #0,d0               * set Zb
00B00434  1740 064E               1107      MOVE.b  d0,ccnull(a3)       * clear get byte countdown
00B00438  6100 01CE               1108      BSR     LAB_RESTORE         * perform RESTORE command
00B0043C                          1109  
00B0043C                          1110  * flush stack & clear continue flag
00B0043C                          1111  
00B0043C                          1112  LAB_1491
00B0043C  49EB 04F2               1113      LEA     des_sk(a3),a4       * reset descriptor stack pointer
00B00440                          1114  
00B00440  201F                    1115      MOVE.l  (sp)+,d0            * pull return address
00B00442  4FEB 0464               1116      LEA     ram_base(a3),sp     * set stack to RAM start + 1k, flush stack
00B00446  2F00                    1117      MOVE.l  d0,-(sp)            * restore return address
00B00448                          1118  
00B00448  7000                    1119      MOVEQ       #0,d0               * clear longword
00B0044A  2740 04BE               1120      MOVE.l  d0,Cpntrl(a3)       * clear continue pointer
00B0044E  1740 0643               1121      MOVE.b  d0,Sufnxf(a3)       * clear subscript/FNX flag
00B00452                          1122  RTS_005
00B00452  4E75                    1123      RTS
00B00454                          1124  
00B00454                          1125  
00B00454                          1126  *************************************************************************************
00B00454                          1127  *
00B00454                          1128  * perform CLEAR
00B00454                          1129  
00B00454                          1130  LAB_CLEAR
00B00454  67C2                    1131      BEQ.s       LAB_147A            * if no following byte go do "CLEAR"
00B00456                          1132  
00B00456  4E75                    1133      RTS                     * was following byte (go do syntax error)
00B00458                          1134  
00B00458                          1135  
00B00458                          1136  *************************************************************************************
00B00458                          1137  *
00B00458                          1138  * perform LIST [n][-m]
00B00458                          1139  
00B00458                          1140  LAB_LIST
00B00458  6512                    1141      BCS.s       LAB_14BD            * branch if next character numeric (LIST n...)
00B0045A                          1142  
00B0045A  72FF                    1143      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00B0045C  2741 048E               1144      MOVE.l  d1,Itemp(a3)        * save to Itemp
00B00460                          1145  
00B00460  7200                    1146      MOVEQ       #0,d1               * set start to $00000000
00B00462  4A00                    1147      TST.b       d0              * test next byte
00B00464  670A                    1148      BEQ.s       LAB_14C0            * branch if next character [NULL] (LIST)
00B00466                          1149  
00B00466  B03C 00B3               1150      CMP.b       #TK_MINUS,d0        * compare with token for -
00B0046A  66E6                    1151      BNE.s       RTS_005         * exit if not - (LIST -m)
00B0046C                          1152  
00B0046C                          1153                              * LIST [[n]-[m]] this sets the n, if present,
00B0046C                          1154                              * as the start and end
00B0046C                          1155  LAB_14BD
00B0046C  6100 0392               1156      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00B00470                          1157  LAB_14C0
00B00470  6100 FF78               1158      BSR     LAB_SSLN            * search BASIC for d1 line number
00B00474                          1159                              * (pointer in a0)
00B00474  6100 0934               1160      BSR     LAB_GBYT            * scan memory
00B00478  6716                    1161      BEQ.s       LAB_14D4            * branch if no more characters
00B0047A                          1162  
00B0047A                          1163                              * this bit checks the - is present
00B0047A  B03C 00B3               1164      CMP.b       #TK_MINUS,d0        * compare with token for -
00B0047E  66D2                    1165      BNE.s       RTS_005         * return if not "-" (will be Syntax error)
00B00480                          1166  
00B00480  72FF                    1167      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00B00482  2741 048E               1168      MOVE.l  d1,Itemp(a3)        * save Itemp
00B00486                          1169  
00B00486                          1170                              * LIST [n]-[m] the - was there so see if
00B00486                          1171                              * there is an m to set as the end value
00B00486  6100 0920               1172      BSR     LAB_IGBY            * increment & scan memory
00B0048A  6704                    1173      BEQ.s       LAB_14D4            * branch if was [NULL] (LIST n-)
00B0048C                          1174  
00B0048C  6100 0372               1175      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00B00490                          1176  LAB_14D4
00B00490  177C 0000 0641          1177      MOVE.b  #$00,Oquote(a3)     * clear open quote flag
00B00496  6100 04E8               1178      BSR     LAB_CRLF            * print CR/LF
00B0049A  2018                    1179      MOVE.l  (a0)+,d0            * get next line pointer
00B0049C  67B4                    1180      BEQ.s       RTS_005         * if null all done so exit
00B0049E                          1181  
00B0049E  2240                    1182      MOVEA.l d0,a1               * copy next line pointer
00B004A0  6100 012C               1183      BSR     LAB_1629            * do CRTL-C check vector
00B004A4                          1184  
00B004A4  2018                    1185      MOVE.l  (a0)+,d0            * get this line #
00B004A6  B0AB 048E               1186      CMP.l       Itemp(a3),d0        * compare end line # with this line #
00B004AA  62A6                    1187      BHI.s       RTS_005         * if this line greater all done so exit
00B004AC                          1188  
00B004AC                          1189  LAB_14E2
00B004AC  48E7 00C0               1190      MOVEM.l a0-a1,-(sp)         * save registers
00B004B0  6100 180E               1191      BSR     LAB_295E            * print d0 as unsigned integer
00B004B4  4CDF 0300               1192      MOVEM.l (sp)+,a0-a1         * restore registers
00B004B8  7020                    1193      MOVEQ       #$20,d0         * space is the next character
00B004BA                          1194  LAB_150C
00B004BA  6100 053C               1195      BSR     LAB_PRNA            * go print the character
00B004BE  B03C 0022               1196      CMP.b       #$22,d0         * was it " character
00B004C2  6606                    1197      BNE.s       LAB_1519            * branch if not
00B004C4                          1198  
00B004C4                          1199                              * we're either entering or leaving quotes
00B004C4  0A2B 00FF 0641          1200      EOR.b       #$FF,Oquote(a3)     * toggle open quote flag
00B004CA                          1201  LAB_1519
00B004CA  1018                    1202      MOVE.b  (a0)+,d0            * get byte and increment pointer
00B004CC  6608                    1203      BNE.s       LAB_152E            * branch if not [EOL] (go print)
00B004CE                          1204  
00B004CE                          1205                              * was [EOL]
00B004CE  2049                    1206      MOVEA.l a1,a0               * copy next line pointer
00B004D0  2008                    1207      MOVE.l  a0,d0               * copy to set flags
00B004D2  66BC                    1208      BNE.s       LAB_14D4            * go do next line if not [EOT]
00B004D4                          1209  
00B004D4  4E75                    1210      RTS
00B004D6                          1211  
00B004D6                          1212  LAB_152E
00B004D6  6AE2                    1213      BPL.s       LAB_150C            * just go print it if not token byte
00B004D8                          1214  
00B004D8                          1215                              * else it was a token byte so maybe uncrunch it
00B004D8  4A2B 0641               1216      TST.b       Oquote(a3)          * test the open quote flag
00B004DC  6BDC                    1217      BMI.s       LAB_150C            * just go print character if open quote set
00B004DE                          1218  
00B004DE                          1219                              * else uncrunch BASIC token
00B004DE  45FA 2AEA               1220      LEA     LAB_KEYT(pc),a2     * get keyword table address
00B004E2  727F                    1221      MOVEQ       #$7F,d1         * mask into d1
00B004E4  C200                    1222      AND.b       d0,d1               * copy and mask token
00B004E6  E549                    1223      LSL.w       #2,d1               * *4
00B004E8  45F2 1000               1224      LEA     (a2,d1.w),a2        * get keyword entry address
00B004EC  101A                    1225      MOVE.b  (a2)+,d0            * get byte from keyword table
00B004EE  6100 0508               1226      BSR     LAB_PRNA            * go print the first character
00B004F2  7200                    1227      MOVEQ       #0,d1               * clear d1
00B004F4  121A                    1228      MOVE.b  (a2)+,d1            * get remaining length byte from keyword table
00B004F6  6BD2                    1229      BMI.s       LAB_1519            * if -ve done so go get next byte
00B004F8                          1230  
00B004F8  3012                    1231      MOVE.w  (a2),d0         * get offset to rest
00B004FA  45FA 2DFA               1232      LEA     TAB_STAR(pc),a2     * get keyword table address
00B004FE  45F2 0000               1233      LEA     (a2,d0.w),a2        * get address of rest
00B00502                          1234  LAB_1540
00B00502  101A                    1235      MOVE.b  (a2)+,d0            * get byte from keyword table
00B00504  6100 04F2               1236      BSR     LAB_PRNA            * go print the character
00B00508  51C9 FFF8               1237      DBF     d1,LAB_1540         * decrement and loop if more to do
00B0050C                          1238  
00B0050C  60BC                    1239      BRA.s       LAB_1519            * go get next byte
00B0050E                          1240  
00B0050E                          1241  
00B0050E                          1242  *************************************************************************************
00B0050E                          1243  *
00B0050E                          1244  * perform FOR
00B0050E                          1245  
00B0050E                          1246  LAB_FOR
00B0050E  6100 0390               1247      BSR     LAB_LET         * go do LET
00B00512                          1248  
00B00512  202B 04D6               1249      MOVE.l  Lvarpl(a3),d0       * get the loop variable pointer
00B00516  B0AB 049E               1250      CMP.l       Sstrl(a3),d0        * compare it with the end of vars memory
00B0051A  6C00 FC22               1251      BGE     LAB_TMER            * if greater go do type mismatch error
00B0051E                          1252  
00B0051E                          1253  * test for not less than the start of variables memory if needed
00B0051E                          1254  *
00B0051E                          1255  *   CMP.l       Svarl(a3),d0        * compare it with the start of variables memory
00B0051E                          1256  *   BLT     LAB_TMER            * if not variables memory do type mismatch error
00B0051E                          1257  
00B0051E                          1258  *   MOVEQ       #28,d0          * we need 28 bytes !
00B0051E                          1259  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00B0051E                          1260  
00B0051E  6100 0214               1261      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00B00522                          1262                              * returns a0 as pointer to [:] or [EOL]
00B00522  2E88                    1263      MOVE.l  a0,(sp)         * push onto stack (and dump the return address)
00B00524  2F2B 04B6               1264      MOVE.l  Clinel(a3),-(sp)        * push current line onto stack
00B00528                          1265  
00B00528  70AA                    1266      MOVEQ       #TK_TO-$100,d0      * set "TO" token
00B0052A  6100 0874               1267      BSR     LAB_SCCA            * scan for CHR$(d0) else syntax error/warm start
00B0052E  6100 0702               1268      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00B00532  1F2B 0619               1269      MOVE.b  Dtypef(a3),-(sp)        * push the FOR variable data type onto stack
00B00536  6100 06F8               1270      BSR     LAB_EVNM            * evaluate expression and check is numeric else
00B0053A                          1271                              * do type mismatch
00B0053A                          1272  
00B0053A  2F2B 05F4               1273      MOVE.l  FAC1_m(a3),-(sp)        * push TO value mantissa
00B0053E  3F2B 05F8               1274      MOVE.w  FAC1_e(a3),-(sp)        * push TO value exponent and sign
00B00542                          1275  
00B00542  277C 80000000 05F4      1276      MOVE.l  #$80000000,FAC1_m(a3)   * set default STEP size mantissa
00B0054A  377C 8100 05F8          1277      MOVE.w  #$8100,FAC1_e(a3)       * set default STEP size exponent and sign
00B00550                          1278  
00B00550  6100 0858               1279      BSR     LAB_GBYT            * scan memory
00B00554  B03C 00AF               1280      CMP.b       #TK_STEP,d0         * compare with STEP token
00B00558  6608                    1281      BNE.s       LAB_15B3            * jump if not "STEP"
00B0055A                          1282  
00B0055A                          1283                              * was STEP token so ....
00B0055A  6100 084C               1284      BSR     LAB_IGBY            * increment & scan memory
00B0055E  6100 06D0               1285      BSR     LAB_EVNM            * evaluate expression & check is numeric
00B00562                          1286                              * else do type mismatch
00B00562                          1287  LAB_15B3
00B00562  2F2B 05F4               1288      MOVE.l  FAC1_m(a3),-(sp)        * push STEP value mantissa
00B00566  3F2B 05F8               1289      MOVE.w  FAC1_e(a3),-(sp)        * push STEP value exponent and sign
00B0056A                          1290  
00B0056A  2F2B 04D6               1291      MOVE.l  Lvarpl(a3),-(sp)        * push variable pointer for FOR/NEXT
00B0056E  3F3C 0081               1292      MOVE.w  #TK_FOR,-(sp)       * push FOR token on stack
00B00572                          1293  
00B00572  6018                    1294      BRA.s       LAB_15C2            * go do interpreter inner loop
00B00574                          1295  
00B00574                          1296  LAB_15DC                        * have reached [EOL]+1
00B00574  300D                    1297      MOVE.w  a5,d0               * copy BASIC execute pointer
00B00576  C07C 0001               1298      AND.w       #1,d0               * and make line start address even
00B0057A  DAC0                    1299      ADD.w       d0,a5               * add to BASIC execute pointer
00B0057C  201D                    1300      MOVE.l  (a5)+,d0            * get next line pointer
00B0057E  6700 FC1A               1301      BEQ     LAB_1274            * if null go to immediate mode, no "BREAK"
00B00582                          1302                              * message (was immediate or [EOT] marker)
00B00582                          1303  
00B00582  275D 04B6               1304      MOVE.l  (a5)+,Clinel(a3)        * save (new) current line #
00B00586                          1305  LAB_15F6
00B00586  6100 0822               1306      BSR     LAB_GBYT            * get BASIC byte
00B0058A  611A                    1307      BSR.s       LAB_15FF            * go interpret BASIC code from (a5)
00B0058C                          1308  
00B0058C                          1309  * interpreter inner loop (re)entry point
00B0058C                          1310  
00B0058C                          1311  LAB_15C2
00B0058C  6140                    1312      BSR.s       LAB_1629            * do CRTL-C check vector
00B0058E  4A2B 04B6               1313      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00B00592  6B04                    1314      BMI.s       LAB_15D1            * branch if immediate mode
00B00594                          1315  
00B00594  274D 04BE               1316      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00B00598                          1317  LAB_15D1
00B00598  101D                    1318      MOVE.b  (a5)+,d0            * get this byte & increment pointer
00B0059A  67D8                    1319      BEQ.s       LAB_15DC            * loop if [EOL]
00B0059C                          1320  
00B0059C  B03C 003A               1321      CMP.b       #$3A,d0         * compare with ":"
00B005A0  67E4                    1322      BEQ.s       LAB_15F6            * loop if was statement separator
00B005A2                          1323  
00B005A2  6000 FBC6               1324      BRA     LAB_SNER            * else syntax error, then warm start
00B005A6                          1325  
00B005A6                          1326  
00B005A6                          1327  *************************************************************************************
00B005A6                          1328  *
00B005A6                          1329  * interpret BASIC code from (a5)
00B005A6                          1330  
00B005A6                          1331  LAB_15FF
00B005A6  6700 008C               1332      BEQ     RTS_006         * exit if zero [EOL]
00B005AA                          1333  
00B005AA                          1334  LAB_1602
00B005AA  0A00 0080               1335      EORI.b  #$80,d0         * normalise token
00B005AE  6B00 02F0               1336      BMI     LAB_LET         * if not token, go do implied LET
00B005B2                          1337  
00B005B2  B03C 0028               1338      CMP.b       #(TK_TAB-$80),d0        * compare normalised token with TAB
00B005B6  6400 FBB2               1339      BCC     LAB_SNER            * branch if d0>=TAB, syntax error/warm start
00B005BA                          1340                              * only tokens before TAB can start a statement
00B005BA                          1341  
00B005BA  4880                    1342      EXT.w       d0              * byte to word (clear high byte)
00B005BC  D040                    1343      ADD.w       d0,d0               * *2
00B005BE  41FA 2868               1344      LEA     LAB_CTBL(pc),a0     * get vector table base address
00B005C2  3030 0000               1345      MOVE.w  (a0,d0.w),d0        * get offset to vector
00B005C6  4870 0000               1346      PEA     (a0,d0.w)           * push vector
00B005CA  6000 07DC               1347      BRA     LAB_IGBY            * get following byte & execute vector
00B005CE                          1348  
00B005CE                          1349  
00B005CE                          1350  *************************************************************************************
00B005CE                          1351  *
00B005CE                          1352  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00B005CE                          1353  * key press is detected.
00B005CE                          1354  
00B005CE                          1355  LAB_1629
00B005CE  4EEB 0488               1356      JMP     V_CTLC(a3)          * ctrl c check vector
00B005D2                          1357  
00B005D2                          1358  * if there was a key press it gets back here .....
00B005D2                          1359  
00B005D2                          1360  LAB_1636
00B005D2  B03C 0003               1361      CMP.b       #$03,d0         * compare with CTRL-C
00B005D6  670C                    1362      BEQ.s       LAB_163B            * STOP if was CTRL-C
00B005D8                          1363  
00B005D8                          1364  LAB_1639
00B005D8  4E75                    1365      RTS                     *
00B005DA                          1366  
00B005DA                          1367  
00B005DA                          1368  *************************************************************************************
00B005DA                          1369  *
00B005DA                          1370  * perform END
00B005DA                          1371  
00B005DA                          1372  LAB_END
00B005DA  66FC                    1373      BNE.s       LAB_1639            * exit if something follows STOP
00B005DC  177C 0000 0640          1374      MOVE.b  #0,Breakf(a3)       * clear break flag, indicate program end
00B005E2                          1375  
00B005E2                          1376  
00B005E2                          1377  *************************************************************************************
00B005E2                          1378  *
00B005E2                          1379  * perform STOP
00B005E2                          1380  
00B005E2                          1381  LAB_STOP
00B005E2  66F4                    1382      BNE.s       LAB_1639            * exit if something follows STOP
00B005E4                          1383  
00B005E4                          1384  LAB_163B
00B005E4  43EB 05F4               1385      LEA     Ibuffe(a3),a1       * get buffer end
00B005E8  BBC9                    1386      CMPA.l  a1,a5               * compare execute address with buffer end
00B005EA  650A                    1387      BCS.s       LAB_164F            * branch if BASIC pointer is in buffer
00B005EC                          1388                              * can't continue in immediate mode
00B005EC                          1389  
00B005EC                          1390                              * else...
00B005EC  274D 04BE               1391      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00B005F0                          1392  LAB_1647
00B005F0  276B 04B6 04BA          1393      MOVE.l  Clinel(a3),Blinel(a3)   * save break line
00B005F6                          1394  LAB_164F
00B005F6  584F                    1395      ADDQ.w  #4,sp               * dump return address, don't return to execute
00B005F8                          1396                              * loop
00B005F8  102B 0640               1397      MOVE.b  Breakf(a3),d0       * get break flag
00B005FC  6700 FB9C               1398      BEQ     LAB_1274            * go do warm start if was program end
00B00600                          1399  
00B00600  41FA 2E9F               1400      LEA     LAB_BMSG(pc),a0     * point to "Break"
00B00604  6000 FB86               1401      BRA     LAB_1269            * print "Break" and do warm start
00B00608                          1402  
00B00608                          1403  
00B00608                          1404  *************************************************************************************
00B00608                          1405  *
00B00608                          1406  * perform RESTORE
00B00608                          1407  
00B00608                          1408  LAB_RESTORE
00B00608  206B 0492               1409      MOVEA.l Smeml(a3),a0        * copy start of memory
00B0060C  6720                    1410      BEQ.s       LAB_1624            * branch if next character null (RESTORE)
00B0060E                          1411  
00B0060E  6100 01F0               1412      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00B00612  B2AB 04B6               1413      CMP.l       Clinel(a3),d1       * compare current line # with required line #
00B00616  630E                    1414      BLS.s       LAB_GSCH            * branch if >= (start search from beginning)
00B00618                          1415  
00B00618  204D                    1416      MOVEA.l a5,a0               * copy BASIC execute pointer
00B0061A                          1417  LAB_RESs
00B0061A  4A18                    1418      TST.b       (a0)+               * test next byte & increment pointer
00B0061C  66FC                    1419      BNE.s       LAB_RESs            * loop if not EOL
00B0061E                          1420  
00B0061E  3008                    1421      MOVE.w  a0,d0               * copy pointer
00B00620  C07C 0001               1422      AND.w       #1,d0               * mask odd bit
00B00624  D0C0                    1423      ADD.w       d0,a0               * add pointer
00B00626                          1424                              * search for line in Itemp from (a0)
00B00626                          1425  LAB_GSCH
00B00626  6100 FDCA               1426      BSR     LAB_SCLN            * search for d1 line number from a0
00B0062A                          1427                              * returns Cb=0 if found
00B0062A  6500 FB26               1428      BCS     LAB_USER            * go do "Undefined statement" error if not found
00B0062E                          1429  
00B0062E                          1430  LAB_1624
00B0062E  4A20                    1431      TST.b       -(a0)               * decrement pointer (faster)
00B00630  2748 04C6               1432      MOVE.l  a0,Dptrl(a3)        * save DATA pointer
00B00634                          1433  RTS_006
00B00634  4E75                    1434      RTS
00B00636                          1435  
00B00636                          1436  
00B00636                          1437  *************************************************************************************
00B00636                          1438  *
00B00636                          1439  * perform NULL
00B00636                          1440  
00B00636                          1441  LAB_NULL
00B00636  6100 10DA               1442      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00B0063A  1740 0648               1443      MOVE.b  d0,Nullct(a3)       * save new NULL count
00B0063E  4E75                    1444      RTS
00B00640                          1445  
00B00640                          1446  
00B00640                          1447  *************************************************************************************
00B00640                          1448  *
00B00640                          1449  * perform CONT
00B00640                          1450  
00B00640                          1451  LAB_CONT
00B00640  6600 FB28               1452      BNE     LAB_SNER            * if following byte exit to do syntax error
00B00644                          1453  
00B00644  4A2B 04B6               1454      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00B00648  6A00 FAE8               1455      BPL     LAB_CCER            * if running go do can't continue error
00B0064C                          1456  
00B0064C  202B 04BE               1457      MOVE.l  Cpntrl(a3),d0       * get continue pointer
00B00650  6700 FAE0               1458      BEQ     LAB_CCER            * go do can't continue error if we can't
00B00654                          1459  
00B00654                          1460                              * we can continue so ...
00B00654  2A40                    1461      MOVEA.l d0,a5               * save continue pointer as BASIC execute pointer
00B00656  276B 04BA 04B6          1462      MOVE.l  Blinel(a3),Clinel(a3)   * set break line as current line
00B0065C  4E75                    1463      RTS
00B0065E                          1464  
00B0065E                          1465  
00B0065E                          1466  *************************************************************************************
00B0065E                          1467  *
00B0065E                          1468  * perform RUN
00B0065E                          1469  
00B0065E                          1470  LAB_RUN
00B0065E  660C                    1471      BNE.s       LAB_RUNn            * if following byte do RUN n
00B00660                          1472  
00B00660  6100 FDB0               1473      BSR     LAB_1477            * execution to start, clear vars & flush stack
00B00664  274D 04BE               1474      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00B00668  6000 FF22               1475      BRA     LAB_15C2            * go do interpreter inner loop
00B0066C                          1476                              * (can't RTS, we flushed the stack!)
00B0066C                          1477  
00B0066C                          1478  LAB_RUNn
00B0066C  6100 FDAA               1479      BSR     LAB_147A            * go do "CLEAR"
00B00670  601C                    1480      BRA.s       LAB_16B0            * get n and do GOTO n
00B00672                          1481  
00B00672                          1482  
00B00672                          1483  *************************************************************************************
00B00672                          1484  *
00B00672                          1485  * perform DO
00B00672                          1486  
00B00672                          1487  LAB_DO
00B00672                          1488  *   MOVE.l  #$05,d0         * need 5 bytes for DO
00B00672                          1489  *   BSR.s       LAB_1212            * check room on stack for A bytes
00B00672  2F0D                    1490      MOVE.l  a5,-(sp)            * push BASIC execute pointer on stack
00B00674  2F2B 04B6               1491      MOVE.l  Clinel(a3),-(sp)        * push current line on stack
00B00678  3F3C 009C               1492      MOVE.w  #TK_DO,-(sp)        * push token for DO on stack
00B0067C  487A FF0E               1493      PEA     LAB_15C2(pc)        * set return address
00B00680  6000 0728               1494      BRA     LAB_GBYT            * scan memory & return to interpreter inner loop
00B00684                          1495  
00B00684                          1496  
00B00684                          1497  *************************************************************************************
00B00684                          1498  *
00B00684                          1499  * perform GOSUB
00B00684                          1500  
00B00684                          1501  LAB_GOSUB
00B00684                          1502  *   MOVE.l  #10,d0          * need 10 bytes for GOSUB
00B00684                          1503  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00B00684  2F0D                    1504      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00B00686  2F2B 04B6               1505      MOVE.l  Clinel(a3),-(sp)        * push current line
00B0068A  3F3C 008D               1506      MOVE.w  #TK_GOSUB,-(sp)     * push token for GOSUB
00B0068E                          1507  LAB_16B0
00B0068E  6100 071A               1508      BSR     LAB_GBYT            * scan memory
00B00692  487A FEF8               1509      PEA     LAB_15C2(pc)        * return to interpreter inner loop after GOTO n
00B00696                          1510  
00B00696                          1511  * this PEA is needed because either we just cleared the stack and have nowhere to return
00B00696                          1512  * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00B00696                          1513  * we whould have returned to is buried. This burried return address will be unstacked by
00B00696                          1514  * the corresponding RETURN command
00B00696                          1515  
00B00696                          1516  
00B00696                          1517  *************************************************************************************
00B00696                          1518  *
00B00696                          1519  * perform GOTO
00B00696                          1520  
00B00696                          1521  LAB_GOTO
00B00696  6100 0168               1522      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00B0069A  206B 0492               1523      MOVEA.l Smeml(a3),a0        * get start of memory
00B0069E  B2AB 04B6               1524      CMP.l       Clinel(a3),d1       * compare current line with wanted #
00B006A2  630E                    1525      BLS.s       LAB_16D0            * branch if current # => wanted #
00B006A4                          1526  
00B006A4  204D                    1527      MOVEA.l a5,a0               * copy BASIC execute pointer
00B006A6                          1528  LAB_GOTs
00B006A6  4A18                    1529      TST.b       (a0)+               * test next byte & increment pointer
00B006A8  66FC                    1530      BNE.s       LAB_GOTs            * loop if not EOL
00B006AA                          1531  
00B006AA  3008                    1532      MOVE.w  a0,d0               * past pad byte(s)
00B006AC  C07C 0001               1533      AND.w       #1,d0               * mask odd bit
00B006B0  D0C0                    1534      ADD.w       d0,a0               * add to pointer
00B006B2                          1535  
00B006B2                          1536  LAB_16D0
00B006B2  6100 FD3E               1537      BSR     LAB_SCLN            * search for d1 line number from a0
00B006B6                          1538                              * returns Cb=0 if found
00B006B6  6500 FA9A               1539      BCS     LAB_USER            * if carry set go do "Undefined statement" error
00B006BA                          1540  
00B006BA  2A48                    1541      MOVEA.l a0,a5               * copy to basic execute pointer
00B006BC  534D                    1542      SUBQ.w  #1,a5               * decrement pointer
00B006BE  274D 04BE               1543      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00B006C2  4E75                    1544      RTS
00B006C4                          1545  
00B006C4                          1546  
00B006C4                          1547  *************************************************************************************
00B006C4                          1548  *
00B006C4                          1549  * perform LOOP
00B006C4                          1550  
00B006C4                          1551  LAB_LOOP
00B006C4  0C6F 009C 0004          1552      CMP.w       #TK_DO,4(sp)        * compare token on stack with DO token
00B006CA  6600 FA5E               1553      BNE     LAB_LDER            * branch if no matching DO
00B006CE                          1554  
00B006CE  1E00                    1555      MOVE.b  d0,d7               * copy following token (byte)
00B006D0  672E                    1556      BEQ.s       LoopAlways          * if no following token loop forever
00B006D2                          1557  
00B006D2  BE3C 003A               1558      CMP.b       #':',d7         * compare with ":"
00B006D6  6728                    1559      BEQ.s       LoopAlways          * if no following token loop forever
00B006D8                          1560  
00B006D8  0407 00B0               1561      SUB.b       #TK_UNTIL,d7        * subtract token for UNTIL
00B006DC  6708                    1562      BEQ.s       DoRest          * branch if was UNTIL
00B006DE                          1563  
00B006DE  5307                    1564      SUBQ.b  #1,d7               * decrement result
00B006E0  6600 FA88               1565      BNE     LAB_SNER            * if not WHILE go do syntax error & warm start
00B006E4                          1566                              * only if the token was WHILE will this fail
00B006E4                          1567  
00B006E4  7EFF                    1568      MOVEQ       #-1,d7          * set invert result longword
00B006E6                          1569  DoRest
00B006E6  6100 06C0               1570      BSR     LAB_IGBY            * increment & scan memory
00B006EA  6100 055C               1571      BSR     LAB_EVEX            * evaluate expression
00B006EE  4A2B 05F8               1572      TST.b       FAC1_e(a3)          * test FAC1 exponent
00B006F2  6706                    1573      BEQ.s       DoCmp               * if = 0 go do straight compare
00B006F4                          1574  
00B006F4  177C 00FF 05F8          1575      MOVE.b  #$FF,FAC1_e(a3)     * else set all bits
00B006FA                          1576  DoCmp
00B006FA  BF2B 05F8               1577      EOR.b       d7,FAC1_e(a3)       * EOR with invert byte
00B006FE  6614                    1578      BNE.s       LoopDone            * if <> 0 clear stack & back to interpreter loop
00B00700                          1579  
00B00700                          1580                              * loop condition wasn't met so do it again
00B00700                          1581  LoopAlways
00B00700  276F 0006 04B6          1582      MOVE.l  6(sp),Clinel(a3)        * copy DO current line
00B00706  2A6F 000A               1583      MOVE.l  10(sp),a5           * save BASIC execute pointer
00B0070A                          1584  
00B0070A  41FA FE80               1585      LEA     LAB_15C2(pc),a0     * get return address
00B0070E  2E88                    1586      MOVE.l  a0,(sp)         * dump the call to this routine and set the
00B00710                          1587                              * return address
00B00710  6000 0698               1588      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00B00714                          1589                              * loop
00B00714                          1590  
00B00714                          1591                              * clear stack & back to interpreter loop
00B00714                          1592  LoopDone
00B00714  4FEF 000E               1593      LEA     14(sp),sp           * dump structure and call from stack
00B00718  6014                    1594      BRA.s       LAB_DATA            * go perform DATA (find : or [EOL])
00B0071A                          1595  
00B0071A                          1596  
00B0071A                          1597  *************************************************************************************
00B0071A                          1598  *
00B0071A                          1599  * perform RETURN
00B0071A                          1600  
00B0071A                          1601  LAB_RETURN
00B0071A  6616                    1602      BNE.s       RTS_007         * exit if following token to allow syntax error
00B0071C                          1603  
00B0071C  0C6F 008D 0004          1604      CMP.w       #TK_GOSUB,4(sp)     * compare token from stack with GOSUB
00B00722  6600 FA42               1605      BNE     LAB_RGER            * do RETURN without GOSUB error if no matching
00B00726                          1606                              * GOSUB
00B00726                          1607  
00B00726  5C4F                    1608      ADDQ.w  #6,sp               * dump calling address & token
00B00728  275F 04B6               1609      MOVE.l  (sp)+,Clinel(a3)        * pull current line
00B0072C  2A5F                    1610      MOVE.l  (sp)+,a5            * pull BASIC execute pointer
00B0072E                          1611                              * now do perform "DATA" statement as we could be
00B0072E                          1612                              * returning into the middle of an ON <var> GOSUB
00B0072E                          1613                              * n,m,p,q line (the return address used by the
00B0072E                          1614                              * DATA statement is the one pushed before the
00B0072E                          1615                              * GOSUB was executed!)
00B0072E                          1616  
00B0072E                          1617  
00B0072E                          1618  *************************************************************************************
00B0072E                          1619  *
00B0072E                          1620  * perform DATA
00B0072E                          1621  
00B0072E                          1622  LAB_DATA
00B0072E  6104                    1623      BSR.s       LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00B00730                          1624                              * returns a0 as pointer to [:] or [EOL]
00B00730  2A48                    1625      MOVEA.l a0,a5               * skip rest of statement
00B00732                          1626  RTS_007
00B00732  4E75                    1627      RTS
00B00734                          1628  
00B00734                          1629  
00B00734                          1630  *************************************************************************************
00B00734                          1631  *
00B00734                          1632  * scan for next BASIC statement ([:] or [EOL])
00B00734                          1633  * returns a0 as pointer to [:] or [EOL]
00B00734                          1634  
00B00734                          1635  LAB_SNBS
00B00734  204D                    1636      MOVEA.l a5,a0               * copy BASIC execute pointer
00B00736  7222                    1637      MOVEQ       #$22,d1         * set string quote character
00B00738  743A                    1638      MOVEQ       #$3A,d2         * set look for character = ":"
00B0073A  6008                    1639      BRA.s       LAB_172D            * go do search
00B0073C                          1640  
00B0073C                          1641  LAB_172C
00B0073C  B400                    1642      CMP.b       d0,d2               * compare with ":"
00B0073E  6708                    1643      BEQ.s       RTS_007a            * exit if found
00B00740                          1644  
00B00740  B200                    1645      CMP.b       d0,d1               * compare with '"'
00B00742  670C                    1646      BEQ.s       LAB_1725            * if found go search for [EOL]
00B00744                          1647  
00B00744                          1648  LAB_172D
00B00744  1018                    1649      MOVE.b  (a0)+,d0            * get next byte
00B00746  66F4                    1650      BNE.s       LAB_172C            * loop if not null [EOL]
00B00748                          1651  
00B00748                          1652  RTS_007a
00B00748  5348                    1653      SUBQ.w  #1,a0               * correct pointer
00B0074A  4E75                    1654      RTS
00B0074C                          1655  
00B0074C                          1656  LAB_1723
00B0074C  B200                    1657      CMP.b       d0,d1               * compare with '"'
00B0074E  67F4                    1658      BEQ.s       LAB_172D            * if found go search for ":" or [EOL]
00B00750                          1659  
00B00750                          1660  LAB_1725
00B00750  1018                    1661      MOVE.b  (a0)+,d0            * get next byte
00B00752  66F8                    1662      BNE.s       LAB_1723            * loop if not null [EOL]
00B00754                          1663  
00B00754  60F2                    1664      BRA.s       RTS_007a            * correct pointer & return
00B00756                          1665  
00B00756                          1666  
00B00756                          1667  *************************************************************************************
00B00756                          1668  *
00B00756                          1669  * perform IF
00B00756                          1670  
00B00756                          1671  LAB_IF
00B00756  6100 04F0               1672      BSR     LAB_EVEX            * evaluate expression
00B0075A  6100 064E               1673      BSR     LAB_GBYT            * scan memory
00B0075E  B03C 00AD               1674      CMP.b       #TK_THEN,d0         * compare with THEN token
00B00762  6714                    1675      BEQ.s       LAB_174B            * if it was THEN then continue
00B00764                          1676  
00B00764                          1677                              * wasn't IF .. THEN so must be IF .. GOTO
00B00764  B03C 0089               1678      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00B00768  6600 FA00               1679      BNE     LAB_SNER            * if not GOTO token do syntax error/warm start
00B0076C                          1680  
00B0076C                          1681                              * was GOTO so check for GOTO <n>
00B0076C  204D                    1682      MOVE.l  a5,a0               * save the execute pointer
00B0076E  6100 0638               1683      BSR     LAB_IGBY            * scan memory, test for a numeric character
00B00772  2A48                    1684      MOVE.l  a0,a5               * restore the execute pointer
00B00774  6400 F9F4               1685      BCC     LAB_SNER            * if not numeric do syntax error/warm start
00B00778                          1686  
00B00778                          1687  LAB_174B
00B00778  102B 05F8               1688      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B0077C  671E                    1689      BEQ.s       LAB_174E            * if result was zero go look for an ELSE
00B0077E                          1690  
00B0077E  6100 0628               1691      BSR     LAB_IGBY            * increment & scan memory
00B00782  6500 FF12               1692      BCS     LAB_GOTO            * if numeric do GOTO n
00B00786                          1693                              * a GOTO <n> will never return to the IF
00B00786                          1694                              * statement so there is no need to return
00B00786                          1695                              * to this code
00B00786                          1696  
00B00786  B03C 008E               1697      CMP.b       #TK_RETURN,d0       * compare with RETURN token
00B0078A  6700 FE1E               1698      BEQ     LAB_1602            * if RETURN then interpret BASIC code from (a5)
00B0078E                          1699                              * and don't return here
00B0078E                          1700  
00B0078E  6100 FE16               1701      BSR     LAB_15FF            * else interpret BASIC code from (a5)
00B00792                          1702  
00B00792                          1703  * the IF was executed and there may be a following ELSE so the code needs to return
00B00792                          1704  * here to check and ignore the ELSE if present
00B00792                          1705  
00B00792  1015                    1706      MOVE.b  (a5),d0         * get the next basic byte
00B00794  B03C 00A9               1707      CMP.b       #TK_ELSE,d0         * compare it with the token for ELSE
00B00798  6794                    1708      BEQ     LAB_DATA            * if ELSE ignore the following statement
00B0079A                          1709  
00B0079A                          1710  * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00B0079A                          1711  * following ELSE will, correctly, cause a syntax error
00B0079A                          1712  
00B0079A  4E75                    1713      RTS                     * else return to interpreter inner loop
00B0079C                          1714  
00B0079C                          1715  * perform ELSE after IF
00B0079C                          1716  
00B0079C                          1717  LAB_174E
00B0079C  101D                    1718      MOVE.b  (a5)+,d0            * faster increment past THEN
00B0079E  76A9                    1719      MOVEQ       #TK_ELSE,d3         * set search for ELSE token
00B007A0  788B                    1720      MOVEQ       #TK_IF,d4           * set search for IF token
00B007A2  7A00                    1721      MOVEQ       #0,d5               * clear the nesting depth
00B007A4                          1722  LAB_1750
00B007A4  101D                    1723      MOVE.b  (a5)+,d0            * get next BASIC byte & increment ptr
00B007A6  6720                    1724      BEQ.s       LAB_1754            * if EOL correct the pointer and return
00B007A8                          1725  
00B007A8  B004                    1726      CMP.b       d4,d0               * compare with "IF" token
00B007AA  6604                    1727      BNE.s       LAB_1752            * skip if not nested IF
00B007AC                          1728  
00B007AC  5245                    1729      ADDQ.w  #1,d5               * else increment the nesting depth ..
00B007AE  60F4                    1730      BRA.s       LAB_1750            * .. and continue looking
00B007B0                          1731  
00B007B0                          1732  LAB_1752
00B007B0  B003                    1733      CMP.b       d3,d0               * compare with ELSE token
00B007B2  66F0                    1734      BNE.s       LAB_1750            * if not ELSE continue looking
00B007B4                          1735  
00B007B4                          1736  LAB_1756
00B007B4  51CD FFEE               1737      DBF     d5,LAB_1750         * loop if still nested
00B007B8                          1738  
00B007B8                          1739  * found the matching ELSE, now do <{n|statement}>
00B007B8                          1740  
00B007B8  6100 05F0               1741      BSR     LAB_GBYT            * scan memory
00B007BC  6500 FED8               1742      BCS     LAB_GOTO            * if numeric do GOTO n
00B007C0                          1743                              * code will return to the interpreter loop
00B007C0                          1744                              * at the tail end of the GOTO <n>
00B007C0                          1745  
00B007C0  6000 FDE4               1746      BRA     LAB_15FF            * else interpret BASIC code from (a5)
00B007C4                          1747                              * code will return to the interpreter loop
00B007C4                          1748                              * at the tail end of the <statement>
00B007C4                          1749  
00B007C4                          1750  
00B007C4                          1751  *************************************************************************************
00B007C4                          1752  *
00B007C4                          1753  * perform REM, skip (rest of) line
00B007C4                          1754  
00B007C4                          1755  LAB_REM
00B007C4  4A1D                    1756      TST.b       (a5)+               * test byte & increment pointer
00B007C6  66FC                    1757      BNE.s       LAB_REM         * loop if not EOL
00B007C8                          1758  
00B007C8                          1759  LAB_1754
00B007C8  534D                    1760      SUBQ.w  #1,a5               * correct the execute pointer
00B007CA  4E75                    1761      RTS
00B007CC                          1762  
00B007CC                          1763  
00B007CC                          1764  *************************************************************************************
00B007CC                          1765  *
00B007CC                          1766  * perform ON
00B007CC                          1767  
00B007CC                          1768  LAB_ON
00B007CC  6100 0F44               1769      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00B007D0  1400                    1770      MOVE.b  d0,d2               * copy byte
00B007D2  6100 05D6               1771      BSR     LAB_GBYT            * restore BASIC byte
00B007D6  3F00                    1772      MOVE.w  d0,-(sp)            * push GOTO/GOSUB token
00B007D8  B03C 008D               1773      CMP.b       #TK_GOSUB,d0        * compare with GOSUB token
00B007DC  6708                    1774      BEQ.s       LAB_176C            * branch if GOSUB
00B007DE                          1775  
00B007DE  B03C 0089               1776      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00B007E2  6600 F986               1777      BNE     LAB_SNER            * if not GOTO do syntax error, then warm start
00B007E6                          1778  
00B007E6                          1779  * next character was GOTO or GOSUB
00B007E6                          1780  
00B007E6                          1781  LAB_176C
00B007E6  5302                    1782      SUBQ.b  #1,d2               * decrement index (byte value)
00B007E8  6606                    1783      BNE.s       LAB_1773            * branch if not zero
00B007EA                          1784  
00B007EA  301F                    1785      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token
00B007EC  6000 FDBC               1786      BRA     LAB_1602            * go execute it
00B007F0                          1787  
00B007F0                          1788  LAB_1773
00B007F0  6100 05B6               1789      BSR     LAB_IGBY            * increment & scan memory
00B007F4  610A                    1790      BSR.s       LAB_GFPN            * get fixed-point number into temp integer & d1
00B007F6                          1791                              * (skip this n)
00B007F6  B03C 002C               1792      CMP.b       #$2C,d0         * compare next character with ","
00B007FA  67EA                    1793      BEQ.s       LAB_176C            * loop if ","
00B007FC                          1794  
00B007FC  301F                    1795      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token (run out of options)
00B007FE  4E75                    1796      RTS                     * and exit
00B00800                          1797  
00B00800                          1798  
00B00800                          1799  *************************************************************************************
00B00800                          1800  *
00B00800                          1801  * get fixed-point number into temp integer & d1
00B00800                          1802  * interpret number from (a5), leave (a5) pointing to byte after #
00B00800                          1803  
00B00800                          1804  LAB_GFPN
00B00800  7200                    1805      MOVEQ       #$00,d1         * clear integer register
00B00802  2001                    1806      MOVE.l  d1,d0               * clear d0
00B00804  6100 05A4               1807      BSR     LAB_GBYT            * scan memory, Cb=1 if "0"-"9", & get byte
00B00808  642E                    1808      BCC.s       LAB_1786            * return if carry clear, chr was not "0"-"9"
00B0080A                          1809  
00B0080A  2F02                    1810      MOVE.l  d2,-(sp)            * save d2
00B0080C                          1811  LAB_1785
00B0080C  2401                    1812      MOVE.l  d1,d2               * copy integer register
00B0080E  D281                    1813      ADD.l       d1,d1               * *2
00B00810  6500 F958               1814      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00B00814                          1815  
00B00814  D281                    1816      ADD.l       d1,d1               * *4
00B00816  6500 F952               1817      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00B0081A                          1818  
00B0081A  D282                    1819      ADD.l       d2,d1               * *1 + *4
00B0081C  6500 F94C               1820      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00B00820                          1821  
00B00820  D281                    1822      ADD.l       d1,d1               * *10
00B00822  6500 F946               1823      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00B00826                          1824  
00B00826  0400 0030               1825      SUB.b       #$30,d0         * subtract $30 from byte
00B0082A  D280                    1826      ADD.l       d0,d1               * add to integer register, the top 24 bits are
00B0082C                          1827                              * always clear
00B0082C  6900 F93C               1828      BVS     LAB_SNER            * if overflow do syntax error, then warm start
00B00830                          1829                              * this makes the maximum line number 2147483647
00B00830  6100 0576               1830      BSR     LAB_IGBY            * increment & scan memory
00B00834  65D6                    1831      BCS.s       LAB_1785            * loop for next character if "0"-"9"
00B00836                          1832  
00B00836  241F                    1833      MOVE.l  (sp)+,d2            * restore d2
00B00838                          1834  LAB_1786
00B00838  2741 048E               1835      MOVE.l  d1,Itemp(a3)        * save Itemp
00B0083C  4E75                    1836      RTS
00B0083E                          1837  
00B0083E                          1838  
00B0083E                          1839  *************************************************************************************
00B0083E                          1840  *
00B0083E                          1841  * perform DEC
00B0083E                          1842  
00B0083E                          1843  LAB_DEC
00B0083E  3F3C 8180               1844      MOVE.w  #$8180,-(sp)        * set -1 sign/exponent
00B00842  600A                    1845      BRA.s       LAB_17B7            * go do DEC
00B00844                          1846  
00B00844                          1847  
00B00844                          1848  *************************************************************************************
00B00844                          1849  *
00B00844                          1850  * perform INC
00B00844                          1851  
00B00844                          1852  LAB_INC
00B00844  3F3C 8100               1853      MOVE.w  #$8100,-(sp)        * set 1 sign/exponent
00B00848  6004                    1854      BRA.s       LAB_17B7            * go do INC
00B0084A                          1855  
00B0084A                          1856                              * was "," so another INCR variable to do
00B0084A                          1857  LAB_17B8
00B0084A  6100 055C               1858      BSR     LAB_IGBY            * increment and scan memory
00B0084E                          1859  LAB_17B7
00B0084E  6100 0768               1860      BSR     LAB_GVAR            * get variable address in a0
00B00852                          1861  
00B00852                          1862  * if you want a non existant variable to return a null value then set the novar
00B00852                          1863  * value at the top of this file to some non zero value
00B00852                          1864  
00B00852                 FALSE    1865   ifne   novar
00B00852                          1866   endc
00B00852                          1867  
00B00852  4A2B 0619               1868      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00856                          1869                              * $00=float
00B00856  6B00 F8E6               1870      BMI     LAB_TMER            * if string do "Type mismatch" error/warm start
00B0085A                          1871  
00B0085A  6636                    1872      BNE.s       LAB_INCI            * go do integer INC/DEC
00B0085C                          1873  
00B0085C  2748 04D6               1874      MOVE.l  a0,Lvarpl(a3)       * save var address
00B00860  6100 130A               1875      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00B00864  277C 80000000 05FC      1876      MOVE.l  #$80000000,FAC2_m(a3)   * set FAC2 mantissa for 1
00B0086C  3017                    1877      MOVE.w  (sp),d0         * move exponent & sign to d0
00B0086E  3740 0600               1878      MOVE.w  d0,FAC2_e(a3)       * move exponent & sign to FAC2
00B00872  176B 05F9 0602          1879      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00B00878  B12B 0602               1880      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00B0087C  6100 100A               1881      BSR     LAB_ADD         * add FAC2 to FAC1
00B00880  6100 1306               1882      BSR     LAB_PFAC            * pack FAC1 into variable (Lvarpl)
00B00884                          1883  LAB_INCT
00B00884  6100 0524               1884      BSR     LAB_GBYT            * scan memory
00B00888  0C00 002C               1885      CMPI.b  #$2C,d0         * compare with ","
00B0088C  67BC                    1886      BEQ.s       LAB_17B8            * continue if "," (another variable to do)
00B0088E                          1887  
00B0088E  544F                    1888      ADDQ.w  #2,sp               * else dump sign & exponent
00B00890  4E75                    1889      RTS
00B00892                          1890  
00B00892                          1891  LAB_INCI
00B00892  4A2F 0001               1892      TST.b       1(sp)               * test sign
00B00896  6604                    1893      BNE.s       LAB_DECI            * branch if DEC
00B00898                          1894  
00B00898  5290                    1895      ADDQ.l  #1,(a0)         * increment variable
00B0089A  60E8                    1896      BRA.s       LAB_INCT            * go scan for more
00B0089C                          1897  
00B0089C                          1898  LAB_DECI
00B0089C  5390                    1899      SUBQ.l  #1,(a0)         * decrement variable
00B0089E  60E4                    1900      BRA.s       LAB_INCT            * go scan for more
00B008A0                          1901  
00B008A0                          1902  
00B008A0                          1903  *************************************************************************************
00B008A0                          1904  *
00B008A0                          1905  * perform LET
00B008A0                          1906  
00B008A0                          1907  LAB_LET
00B008A0  6100 0712               1908      BSR     LAB_SVAR            * search for or create a variable
00B008A4                          1909                              * return the variable address in a0
00B008A4  2748 04D6               1910      MOVE.l  a0,Lvarpl(a3)       * save variable address
00B008A8  1F2B 0619               1911      MOVE.b  Dtypef(a3),-(sp)        * push var data type, $80=string, $40=integer,
00B008AC                          1912                              * $00=float
00B008AC  70BD                    1913      MOVEQ       #TK_EQUAL-$100,d0       * get = token
00B008AE  6100 04F0               1914      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00B008B2                          1915                              * start
00B008B2  6100 0394               1916      BSR     LAB_EVEX            * evaluate expression
00B008B6  102B 0619               1917      MOVE.b  Dtypef(a3),d0       * copy expression data type
00B008BA  175F 0619               1918      MOVE.b  (sp)+,Dtypef(a3)        * pop variable data type
00B008BE  E318                    1919      ROL.b       #1,d0               * set carry if expression type = string
00B008C0  6100 0372               1920      BSR     LAB_CKTM            * type match check, set C for string
00B008C4  6700 12C2               1921      BEQ     LAB_PFAC            * if number pack FAC1 into variable Lvarpl & RET
00B008C8                          1922  
00B008C8                          1923  * string LET
00B008C8                          1924  
00B008C8                          1925  LAB_17D5
00B008C8  246B 04D6               1926      MOVEA.l Lvarpl(a3),a2       * get pointer to variable
00B008CC                          1927  LAB_17D6
00B008CC  206B 05F4               1928      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00B008D0  2250                    1929      MOVEA.l (a0),a1         * get string pointer
00B008D2  B3EB 04AA               1930      CMP.l       Sstorl(a3),a1       * compare string memory start with string
00B008D6                          1931                              * pointer
00B008D6  6516                    1932      BCS.s       LAB_1811            * if it was in program memory assign the value
00B008D8                          1933                              * and exit
00B008D8                          1934  
00B008D8  B1EB 0496               1935      CMPA.l  Sfncl(a3),a0        * compare functions start with descriptor
00B008DC                          1936                              * pointer
00B008DC  6510                    1937      BCS.s       LAB_1811            * branch if >= (string is on stack)
00B008DE                          1938  
00B008DE                          1939                              * string is variable$ make space and copy string
00B008DE                          1940  LAB_1810
00B008DE  7200                    1941      MOVEQ       #0,d1               * clear length
00B008E0  3228 0004               1942      MOVE.w  4(a0),d1            * get string length
00B008E4  2050                    1943      MOVEA.l (a0),a0         * get string pointer
00B008E6  6100 0B04               1944      BSR     LAB_20C9            * copy string
00B008EA  206B 05F4               1945      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer back
00B008EE                          1946                              * clean stack & assign value to string variable
00B008EE                          1947  LAB_1811
00B008EE  B9C8                    1948      CMPA.l  a0,a4               * is string on the descriptor stack
00B008F0  6602                    1949      BNE.s       LAB_1813            * skip pop if not
00B008F2                          1950  
00B008F2  5C4C                    1951      ADDQ.w  #$06,a4         * else update stack pointer
00B008F4                          1952  LAB_1813
00B008F4  24D8                    1953      MOVE.l  (a0)+,(a2)+         * save pointer to variable
00B008F6  3490                    1954      MOVE.w  (a0),(a2)           * save length to variable
00B008F8                          1955  RTS_008
00B008F8  4E75                    1956      RTS
00B008FA                          1957  
00B008FA                          1958  
00B008FA                          1959  *************************************************************************************
00B008FA                          1960  *
00B008FA                          1961  * perform GET
00B008FA                          1962  
00B008FA                          1963  LAB_GET
00B008FA  6100 06B8               1964      BSR     LAB_SVAR            * search for or create a variable
00B008FE                          1965                              * return the variable address in a0
00B008FE  2748 04D6               1966      MOVE.l  a0,Lvarpl(a3)       * save variable address as GET variable
00B00902  4A2B 0619               1967      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00906                          1968                              * $00=float
00B00906  6B0C                    1969      BMI.s       LAB_GETS            * go get string character
00B00908                          1970  
00B00908                          1971                              * was numeric get
00B00908  6100 1DE4               1972      BSR     INGET               * get input byte
00B0090C  6100 09BA               1973      BSR     LAB_1FD0            * convert d0 to unsigned byte in FAC1
00B00910  6000 1276               1974      BRA     LAB_PFAC            * pack FAC1 into variable (Lvarpl) & return
00B00914                          1975  
00B00914                          1976  LAB_GETS
00B00914  7200                    1977      MOVEQ       #$00,d1         * assume no byte
00B00916  2041                    1978      MOVE.l  d1,a0               * assume null string
00B00918  6100 1DD4               1979      BSR     INGET               * get input byte
00B0091C  6408                    1980      BCC.s       LAB_NoSt            * branch if no byte received
00B0091E                          1981  
00B0091E  7201                    1982      MOVEQ       #$01,d1         * string is single byte
00B00920  6100 0AFC               1983      BSR     LAB_2115            * make string space d1 bytes long
00B00924                          1984                              * return a0 = pointer, other registers unchanged
00B00924                          1985  
00B00924  1080                    1986      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00B00926                          1987  LAB_NoSt
00B00926  6100 0ADC               1988      BSR     LAB_RTST            * push string on descriptor stack
00B0092A                          1989                              * a0 = pointer, d1 = length
00B0092A                          1990  
00B0092A  609C                    1991      BRA.s       LAB_17D5            * do string LET & return
00B0092C                          1992  
00B0092C                          1993  
00B0092C                          1994  *************************************************************************************
00B0092C                          1995  *
00B0092C                          1996  * PRINT
00B0092C                          1997  
00B0092C                          1998  LAB_1829
00B0092C  6100 00B4               1999      BSR     LAB_18C6            * print string from stack
00B00930                          2000  LAB_182C
00B00930  6100 0478               2001      BSR     LAB_GBYT            * scan memory
00B00934                          2002  
00B00934                          2003  * perform PRINT
00B00934                          2004  
00B00934                          2005  LAB_PRINT
00B00934  674A                    2006      BEQ.s       LAB_CRLF            * if nothing following just print CR/LF
00B00936                          2007  
00B00936                          2008  LAB_1831
00B00936  B03C 00A8               2009      CMP.b       #TK_TAB,d0          * compare with TAB( token
00B0093A  6764                    2010      BEQ.s       LAB_18A2            * go do TAB/SPC
00B0093C                          2011  
00B0093C  B03C 00AC               2012      CMP.b       #TK_SPC,d0          * compare with SPC( token
00B00940  675E                    2013      BEQ.s       LAB_18A2            * go do TAB/SPC
00B00942                          2014  
00B00942  B03C 002C               2015      CMP.b       #',',d0         * compare with ","
00B00946  6740                    2016      BEQ.s       LAB_188B            * go do move to next TAB mark
00B00948                          2017  
00B00948  B03C 003B               2018      CMP.b       #';',d0         * compare with ";"
00B0094C  6700 0086               2019      BEQ     LAB_18BD            * if ";" continue with PRINT processing
00B00950                          2020  
00B00950  6100 02F6               2021      BSR     LAB_EVEX            * evaluate expression
00B00954  4A2B 0619               2022      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00958                          2023                              * $00=float
00B00958  6BD2                    2024      BMI.s       LAB_1829            * branch if string
00B0095A                          2025  
00B0095A                          2026  ** replace the two lines above with this code
00B0095A                          2027  
00B0095A                          2028  **  MOVE.b  Dtypef(a3),d0       * get data type flag, $80=string, $00=numeric
00B0095A                          2029  **  BMI.s       LAB_1829            * branch if string
00B0095A                          2030  
00B0095A  6100 13AA               2031      BSR     LAB_2970            * convert FAC1 to string
00B0095E  6100 0A5E               2032      BSR     LAB_20AE            * print " terminated string to FAC1 stack
00B00962                          2033  
00B00962                          2034  * don't check fit if terminal width byte is zero
00B00962                          2035  
00B00962  7000                    2036      MOVEQ       #0,d0               * clear d0
00B00964  102B 064A               2037      MOVE.b  TWidth(a3),d0       * get terminal width byte
00B00968  670C                    2038      BEQ.s       LAB_185E            * skip check if zero
00B0096A                          2039  
00B0096A  902C 0007               2040      SUB.b       7(a4),d0            * subtract string length
00B0096E  902B 0649               2041      SUB.b       TPos(a3),d0         * subtract terminal position
00B00972  6402                    2042      BCC.s       LAB_185E            * branch if less than terminal width
00B00974                          2043  
00B00974  610A                    2044      BSR.s       LAB_CRLF            * else print CR/LF
00B00976                          2045  LAB_185E
00B00976  616A                    2046      BSR.s       LAB_18C6            * print string from stack
00B00978  60B6                    2047      BRA.s       LAB_182C            * always go continue processing line
00B0097A                          2048  
00B0097A                          2049  
00B0097A                          2050  *************************************************************************************
00B0097A                          2051  *
00B0097A                          2052  * CR/LF return to BASIC from BASIC input handler
00B0097A                          2053  * leaves a0 pointing to the buffer start
00B0097A                          2054  
00B0097A                          2055  LAB_1866
00B0097A  11BC 0000 1000          2056      MOVE.b  #$00,(a0,d1.w)      * null terminate input
00B00980                          2057  
00B00980                          2058  * print CR/LF
00B00980                          2059  
00B00980                          2060  LAB_CRLF
00B00980  700D                    2061      MOVEQ       #$0D,d0         * load [CR]
00B00982  6174                    2062      BSR.s       LAB_PRNA            * go print the character
00B00984  700A                    2063      MOVEQ       #$0A,d0         * load [LF]
00B00986  6070                    2064      BRA.s       LAB_PRNA            * go print the character & return
00B00988                          2065  
00B00988                          2066  LAB_188B
00B00988  142B 0649               2067      MOVE.b  TPos(a3),d2         * get terminal position
00B0098C  B42B 064B               2068      CMP.b       Iclim(a3),d2        * compare with input column limit
00B00990  6504                    2069      BCS.s       LAB_1898            * branch if less than Iclim
00B00992                          2070  
00B00992  61EC                    2071      BSR.s       LAB_CRLF            * else print CR/LF (next line)
00B00994  603E                    2072      BRA.s       LAB_18BD            * continue with PRINT processing
00B00996                          2073  
00B00996                          2074  LAB_1898
00B00996  942B 0646               2075      SUB.b       TabSiz(a3),d2       * subtract TAB size
00B0099A  64FA                    2076      BCC.s       LAB_1898            * loop if result was >= 0
00B0099C                          2077  
00B0099C  4402                    2078      NEG.b       d2              * twos complement it
00B0099E  6022                    2079      BRA.s       LAB_18B7            * print d2 spaces
00B009A0                          2080  
00B009A0                          2081                              * do TAB/SPC
00B009A0                          2082  LAB_18A2
00B009A0  3F00                    2083      MOVE.w  d0,-(sp)            * save token
00B009A2  6100 0D6A               2084      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00B009A6  3400                    2085      MOVE.w  d0,d2               * copy byte
00B009A8  6100 0400               2086      BSR     LAB_GBYT            * get basic byte back
00B009AC  B03C 0029               2087      CMP.b       #$29,d0         * is next character ")"
00B009B0  6600 F7B8               2088      BNE     LAB_SNER            * if not do syntax error, then warm start
00B009B4                          2089  
00B009B4  301F                    2090      MOVE.w  (sp)+,d0            * get token back
00B009B6  B03C 00A8               2091      CMP.b       #TK_TAB,d0          * was it TAB ?
00B009BA  6606                    2092      BNE.s       LAB_18B7            * branch if not (was SPC)
00B009BC                          2093  
00B009BC                          2094                              * calculate TAB offset
00B009BC  942B 0649               2095      SUB.b       TPos(a3),d2         * subtract terminal position
00B009C0  6312                    2096      BLS.s       LAB_18BD            * branch if result was <= 0
00B009C2                          2097                              * can't TAB backwards or already there
00B009C2                          2098  
00B009C2                          2099                              * print d2.b spaces
00B009C2                          2100  LAB_18B7
00B009C2  7000                    2101      MOVEQ       #0,d0               * clear longword
00B009C4  5300                    2102      SUBQ.b  #1,d0               * make d0 = $FF
00B009C6  C480                    2103      AND.l       d0,d2               * mask for byte only
00B009C8  670A                    2104      BEQ.s       LAB_18BD            * branch if zero
00B009CA                          2105  
00B009CA  7020                    2106      MOVEQ       #$20,d0         * load " "
00B009CC  5302                    2107      SUBQ.b  #1,d2               * adjust for DBF loop
00B009CE                          2108  LAB_18B8
00B009CE  6128                    2109      BSR.s       LAB_PRNA            * go print
00B009D0  51CA FFFC               2110      DBF     d2,LAB_18B8         * decrement count and loop if not all done
00B009D4                          2111  
00B009D4                          2112                              * continue with PRINT processing
00B009D4                          2113  LAB_18BD
00B009D4  6100 03D2               2114      BSR     LAB_IGBY            * increment & scan memory
00B009D8  6600 FF5C               2115      BNE     LAB_1831            * if byte continue executing PRINT
00B009DC                          2116  
00B009DC  4E75                    2117      RTS                     * exit if nothing more to print
00B009DE                          2118  
00B009DE                          2119  
00B009DE                          2120  *************************************************************************************
00B009DE                          2121  *
00B009DE                          2122  * print null terminated string from a0
00B009DE                          2123  
00B009DE                          2124  LAB_18C3
00B009DE  6100 09DE               2125      BSR     LAB_20AE            * print terminated string to FAC1/stack
00B009E2                          2126  
00B009E2                          2127  * print string from stack
00B009E2                          2128  
00B009E2                          2129  LAB_18C6
00B009E2  6100 0BCE               2130      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00B009E6                          2131                              * returns with d0 = length, a0 = pointer
00B009E6  670C                    2132      BEQ.s       RTS_009         * exit (RTS) if null string
00B009E8                          2133  
00B009E8  3200                    2134      MOVE.w  d0,d1               * copy length & set Z flag
00B009EA  5341                    2135      SUBQ.w  #1,d1               * -1 for BF loop
00B009EC                          2136  LAB_18CD
00B009EC  1018                    2137      MOVE.b  (a0)+,d0            * get byte from string
00B009EE  6108                    2138      BSR.s       LAB_PRNA            * go print the character
00B009F0  51C9 FFFA               2139      DBF     d1,LAB_18CD         * decrement count and loop if not done yet
00B009F4                          2140  
00B009F4                          2141  RTS_009
00B009F4  4E75                    2142      RTS
00B009F6                          2143  
00B009F6                          2144  
00B009F6                          2145  *************************************************************************************
00B009F6                          2146  *
00B009F6                          2147  * print "?" character
00B009F6                          2148  
00B009F6                          2149  LAB_18E3
00B009F6  703F                    2150      MOVEQ       #$3F,d0         * load "?" character
00B009F8                          2151  
00B009F8                          2152  
00B009F8                          2153  *************************************************************************************
00B009F8                          2154  *
00B009F8                          2155  * print character in d0, includes the null handler and infinite line length code
00B009F8                          2156  * changes no registers
00B009F8                          2157  
00B009F8                          2158  LAB_PRNA
00B009F8  2F01                    2159      MOVE.l  d1,-(sp)            * save d1
00B009FA  B03C 0020               2160      CMP.b       #$20,d0         * compare with " "
00B009FE  6528                    2161      BCS.s       LAB_18F9            * branch if less, non printing character
00B00A00                          2162  
00B00A00                          2163                              * don't check fit if terminal width byte is zero
00B00A00  122B 064A               2164      MOVE.b  TWidth(a3),d1       * get terminal width
00B00A04  6610                    2165      BNE.s       LAB_18F0            * branch if not zero (not infinite length)
00B00A06                          2166  
00B00A06                          2167                              * is "infinite line" so check TAB position
00B00A06  122B 0649               2168      MOVE.b  TPos(a3),d1         * get position
00B00A0A  922B 0646               2169      SUB.b       TabSiz(a3),d1       * subtract TAB size
00B00A0E  6614                    2170      BNE.s       LAB_18F7            * skip reset if different
00B00A10                          2171  
00B00A10  1741 0649               2172      MOVE.b  d1,TPos(a3)         * else reset position
00B00A14  600E                    2173      BRA.s       LAB_18F7            * go print character
00B00A16                          2174  
00B00A16                          2175  LAB_18F0
00B00A16  B22B 0649               2176      CMP.b       TPos(a3),d1         * compare with terminal character position
00B00A1A  6608                    2177      BNE.s       LAB_18F7            * branch if not at end of line
00B00A1C                          2178  
00B00A1C  2F00                    2179      MOVE.l  d0,-(sp)            * save d0
00B00A1E  6100 FF60               2180      BSR     LAB_CRLF            * else print CR/LF
00B00A22  201F                    2181      MOVE.l  (sp)+,d0            * restore d0
00B00A24                          2182  LAB_18F7
00B00A24  522B 0649               2183      ADDQ.b  #$01,TPos(a3)       * increment terminal position
00B00A28                          2184  LAB_18F9
00B00A28  4EAB 0476               2185      JSR     V_OUTP(a3)          * output byte via output vector
00B00A2C  B03C 000D               2186      CMP.b       #$0D,d0         * compare with [CR]
00B00A30  6618                    2187      BNE.s       LAB_188A            * branch if not [CR]
00B00A32                          2188  
00B00A32                          2189                              * else print nullct nulls after the [CR]
00B00A32  7200                    2190      MOVEQ       #$00,d1         * clear d1
00B00A34  122B 0648               2191      MOVE.b  Nullct(a3),d1       * get null count
00B00A38  670C                    2192      BEQ.s       LAB_1886            * branch if no nulls
00B00A3A                          2193  
00B00A3A  7000                    2194      MOVEQ       #$00,d0         * load [NULL]
00B00A3C                          2195  LAB_1880
00B00A3C  4EAB 0476               2196      JSR     V_OUTP(a3)          * go print the character
00B00A40  51C9 FFFA               2197      DBF     d1,LAB_1880         * decrement count and loop if not all done
00B00A44                          2198  
00B00A44  700D                    2199      MOVEQ       #$0D,d0         * restore the character
00B00A46                          2200  LAB_1886
00B00A46  1741 0649               2201      MOVE.b  d1,TPos(a3)         * clear terminal position
00B00A4A                          2202  LAB_188A
00B00A4A  221F                    2203      MOVE.l  (sp)+,d1            * restore d1
00B00A4C  4E75                    2204      RTS
00B00A4E                          2205  
00B00A4E                          2206  
00B00A4E                          2207  *************************************************************************************
00B00A4E                          2208  *
00B00A4E                          2209  * handle bad input data
00B00A4E                          2210  
00B00A4E                          2211  LAB_1904
00B00A4E  2A5F                    2212      MOVEA.l (sp)+,a5            * restore execute pointer
00B00A50  4A2B 0644               2213      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00B00A54  6A0A                    2214      BPL.s       LAB_1913            * branch if INPUT (go do redo)
00B00A56                          2215  
00B00A56  276B 04C2 04B6          2216      MOVE.l  Dlinel(a3),Clinel(a3)   * save DATA line as current line
00B00A5C  6000 F6E0               2217      BRA     LAB_TMER            * do type mismatch error, then warm start
00B00A60                          2218  
00B00A60                          2219                              * mode was INPUT
00B00A60                          2220  LAB_1913
00B00A60  41FA 2A68               2221      LEA     LAB_REDO(pc),a0     * point to redo message
00B00A64  6100 FF78               2222      BSR     LAB_18C3            * print null terminated string from memory
00B00A68  2A6B 04BE               2223      MOVEA.l Cpntrl(a3),a5       * save continue pointer as BASIC execute pointer
00B00A6C  4E75                    2224      RTS
00B00A6E                          2225  
00B00A6E                          2226  
00B00A6E                          2227  *************************************************************************************
00B00A6E                          2228  *
00B00A6E                          2229  * perform INPUT
00B00A6E                          2230  
00B00A6E                          2231  LAB_INPUT
00B00A6E  6100 0860               2232      BSR     LAB_CKRN            * check not direct (back here if ok)
00B00A72  B03C 0022               2233      CMP.b       #'"',d0         * compare the next byte with open quote
00B00A76  660E                    2234      BNE.s       LAB_1934            * if no prompt string just go get the input
00B00A78                          2235  
00B00A78  6100 0306               2236      BSR     LAB_1BC1            * print "..." string
00B00A7C  703B                    2237      MOVEQ       #';',d0         * set the search character to ";"
00B00A7E  6100 0320               2238      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00B00A82                          2239                              * start
00B00A82  6100 FF5E               2240      BSR     LAB_18C6            * print string from Sutill/Sutilh
00B00A86                          2241                              * finished the prompt, now read the data
00B00A86                          2242  LAB_1934
00B00A86  6100 F80C               2243      BSR     LAB_INLN            * print "? " and get BASIC input
00B00A8A                          2244                              * return a0 pointing to the buffer start
00B00A8A  7000                    2245      MOVEQ       #0,d0               * flag INPUT
00B00A8C                          2246  
00B00A8C                          2247  * if you don't want a null response to INPUT to break the program then set the nobrk
00B00A8C                          2248  * value at the top of this file to some non zero value
00B00A8C                          2249  
00B00A8C                 FALSE    2250   ifne   nobrk
00B00A8C                          2251   endc
00B00A8C                          2252  
00B00A8C                          2253  * if you do want a null response to INPUT to break the program then leave the nobrk
00B00A8C                          2254  * value at the top of this file set to zero
00B00A8C                          2255  
00B00A8C                 TRUE     2256   ifeq   nobrk
00B00A8C                          2257  
00B00A8C  4A10                    2258      TST.b       (a0)                * test first byte from buffer
00B00A8E  660A                    2259      BNE.s       LAB_1953            * branch if not null input
00B00A90                          2260  
00B00A90  6000 FB5E               2261      BRA     LAB_1647            * go do BREAK exit
00B00A94                          2262  
00B00A94                          2263   endc
00B00A94                          2264  
00B00A94                          2265  
00B00A94                          2266  *************************************************************************************
00B00A94                          2267  *
00B00A94                          2268  * perform READ
00B00A94                          2269  
00B00A94                          2270  LAB_READ
00B00A94  206B 04C6               2271      MOVEA.l Dptrl(a3),a0        * get the DATA pointer
00B00A98  7098                    2272      MOVEQ       #$98-$100,d0        * flag READ
00B00A9A                          2273  LAB_1953
00B00A9A  1740 0644               2274      MOVE.b  d0,Imode(a3)        * set input mode flag, $00=INPUT, $98=READ
00B00A9E  2748 04CA               2275      MOVE.l  a0,Rdptrl(a3)       * save READ pointer
00B00AA2                          2276  
00B00AA2                          2277                              * READ or INPUT the next variable from list
00B00AA2                          2278  LAB_195B
00B00AA2  6100 0510               2279      BSR     LAB_SVAR            * search for or create a variable
00B00AA6                          2280                              * return the variable address in a0
00B00AA6  2748 04D6               2281      MOVE.l  a0,Lvarpl(a3)       * save variable address as LET variable
00B00AAA  2F0D                    2282      MOVE.l  a5,-(sp)            * save BASIC execute pointer
00B00AAC                          2283  LAB_1961
00B00AAC  2A6B 04CA               2284      MOVEA.l Rdptrl(a3),a5       * set READ pointer as BASIC execute pointer
00B00AB0  6100 02F8               2285      BSR     LAB_GBYT            * scan memory
00B00AB4  661E                    2286      BNE.s       LAB_1986            * if not null go get the value
00B00AB6                          2287  
00B00AB6                          2288                              * the pointer was to a null entry
00B00AB6  4A2B 0644               2289      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00B00ABA  6B72                    2290      BMI.s       LAB_19DD            * branch if READ (go find the next statement)
00B00ABC                          2291  
00B00ABC                          2292                              * else the mode was INPUT so get more
00B00ABC  6100 FF38               2293      BSR     LAB_18E3            * print a "?" character
00B00AC0  6100 F7D2               2294      BSR     LAB_INLN            * print "? " and get BASIC input
00B00AC4                          2295                              * return a0 pointing to the buffer start
00B00AC4                          2296  
00B00AC4                          2297  * if you don't want a null response to INPUT to break the program then set the nobrk
00B00AC4                          2298  * value at the top of this file to some non zero value
00B00AC4                          2299  
00B00AC4                 FALSE    2300   ifne   nobrk
00B00AC4                          2301   endc
00B00AC4                          2302  
00B00AC4                          2303  * if you do want a null response to INPUT to break the program then leave the nobrk
00B00AC4                          2304  * value at the top of this file set to zero
00B00AC4                          2305  
00B00AC4                 TRUE     2306   ifeq   nobrk
00B00AC4                          2307  
00B00AC4  4A10                    2308      TST.b       (a0)                * test the first byte from the buffer
00B00AC6  6604                    2309      BNE.s       LAB_1984            * if not null input go handle it
00B00AC8                          2310  
00B00AC8  6000 FB26               2311      BRA     LAB_1647            * else go do the BREAK exit
00B00ACC                          2312  
00B00ACC                          2313  LAB_1984
00B00ACC  2A48                    2314      MOVEA.l a0,a5               * set the execute pointer to the buffer
00B00ACE  534D                    2315      SUBQ.w  #1,a5               * decrement the execute pointer
00B00AD0                          2316  
00B00AD0                          2317   endc
00B00AD0                          2318  
00B00AD0                          2319  LAB_1985
00B00AD0  6100 02D6               2320      BSR     LAB_IGBY            * increment & scan memory
00B00AD4                          2321  LAB_1986
00B00AD4  4A2B 0619               2322      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00AD8                          2323                              * $00=float
00B00AD8  6A20                    2324      BPL.s       LAB_19B0            * branch if numeric
00B00ADA                          2325  
00B00ADA                          2326                              * else get string
00B00ADA  1400                    2327      MOVE.b  d0,d2               * save search character
00B00ADC  B03C 0022               2328      CMP.b       #$22,d0         * was it " ?
00B00AE0  6706                    2329      BEQ.s       LAB_1999            * branch if so
00B00AE2                          2330  
00B00AE2  743A                    2331      MOVEQ       #':',d2         * set new search character
00B00AE4  702C                    2332      MOVEQ       #',',d0         * other search character is ","
00B00AE6  534D                    2333      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00B00AE8                          2334  LAB_1999
00B00AE8  524D                    2335      ADDQ.w  #1,a5               * increment BASIC execute pointer
00B00AEA  1600                    2336      MOVE.b  d0,d3               * set second search character
00B00AEC  204D                    2337      MOVEA.l a5,a0               * BASIC execute pointer is source
00B00AEE                          2338  
00B00AEE  6100 08D2               2339      BSR     LAB_20B4            * print d2/d3 terminated string to FAC1 stack
00B00AF2                          2340                              * d2 = Srchc, d3 = Asrch, a0 is source
00B00AF2  2A4A                    2341      MOVEA.l a2,a5               * copy end of string to BASIC execute pointer
00B00AF4  6100 FDD2               2342      BSR     LAB_17D5            * go do string LET
00B00AF8  6010                    2343      BRA.s       LAB_19B6            * go check string terminator
00B00AFA                          2344  
00B00AFA                          2345                              * get numeric INPUT
00B00AFA                          2346  LAB_19B0
00B00AFA  1F2B 0619               2347      MOVE.b  Dtypef(a3),-(sp)        * save variable data type
00B00AFE  6100 1D98               2348      BSR     LAB_2887            * get FAC1 from string
00B00B02  175F 0619               2349      MOVE.b  (sp)+,Dtypef(a3)        * restore variable data type
00B00B06  6100 1080               2350      BSR     LAB_PFAC            * pack FAC1 into (Lvarpl)
00B00B0A                          2351  LAB_19B6
00B00B0A  6100 029E               2352      BSR     LAB_GBYT            * scan memory
00B00B0E  670A                    2353      BEQ.s       LAB_19C2            * branch if null (last entry)
00B00B10                          2354  
00B00B10  B03C 002C               2355      CMP.b       #',',d0         * else compare with ","
00B00B14  6600 FF38               2356      BNE     LAB_1904            * if not "," go handle bad input data
00B00B18                          2357  
00B00B18  524D                    2358      ADDQ.w  #1,a5               * else was "," so point to next chr
00B00B1A                          2359                              * got good input data
00B00B1A                          2360  LAB_19C2
00B00B1A  274D 04CA               2361      MOVE.l  a5,Rdptrl(a3)       * save the read pointer for now
00B00B1E  2A5F                    2362      MOVEA.l (sp)+,a5            * restore the execute pointer
00B00B20  6100 0288               2363      BSR     LAB_GBYT            * scan the memory
00B00B24  6736                    2364      BEQ.s       LAB_1A03            * if null go do extra ignored message
00B00B26                          2365  
00B00B26  487A FF7A               2366      PEA     LAB_195B(pc)        * set return address
00B00B2A  6000 0272               2367      BRA     LAB_1C01            * scan for "," else do syntax error/warm start
00B00B2E                          2368                              * then go INPUT next variable from list
00B00B2E                          2369  
00B00B2E                          2370                              * find next DATA statement or do "Out of Data"
00B00B2E                          2371                              * error
00B00B2E                          2372  LAB_19DD
00B00B2E  6100 FC04               2373      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00B00B32                          2374                              * returns a0 as pointer to [:] or [EOL]
00B00B32  2A48                    2375      MOVEA.l a0,a5               * add index, now = pointer to [EOL]/[EOS]
00B00B34  524D                    2376      ADDQ.w  #1,a5               * pointer to next character
00B00B36  B03C 003A               2377      CMP.b       #':',d0         * was it statement end?
00B00B3A  6712                    2378      BEQ.s       LAB_19F6            * branch if [:]
00B00B3C                          2379  
00B00B3C                          2380                              * was [EOL] so find next line
00B00B3C                          2381  
00B00B3C  320D                    2382      MOVE.w  a5,d1               * past pad byte(s)
00B00B3E  C27C 0001               2383      AND.w       #1,d1               * mask odd bit
00B00B42  DAC1                    2384      ADD.w       d1,a5               * add pointer
00B00B44  241D                    2385      MOVE.l  (a5)+,d2            * get next line pointer
00B00B46  6700 F61A               2386      BEQ     LAB_ODER            * branch if end of program
00B00B4A                          2387  
00B00B4A  275D 04C2               2388      MOVE.l  (a5)+,Dlinel(a3)        * save current DATA line
00B00B4E                          2389  LAB_19F6
00B00B4E  6100 025A               2390      BSR     LAB_GBYT            * scan memory
00B00B52  B03C 0083               2391      CMP.b       #TK_DATA,d0         * compare with "DATA" token
00B00B56  6700 FF78               2392      BEQ     LAB_1985            * was "DATA" so go do next READ
00B00B5A                          2393  
00B00B5A  60D2                    2394      BRA.s       LAB_19DD            * go find next statement if not "DATA"
00B00B5C                          2395  
00B00B5C                          2396  * end of INPUT/READ routine
00B00B5C                          2397  
00B00B5C                          2398  LAB_1A03
00B00B5C  206B 04CA               2399      MOVEA.l Rdptrl(a3),a0       * get temp READ pointer
00B00B60  4A2B 0644               2400      TST.b       Imode(a3)           * get input mode flag, $00=INPUT, $98=READ
00B00B64  6A06                    2401      BPL.s       LAB_1A0E            * branch if INPUT
00B00B66                          2402  
00B00B66  2748 04C6               2403      MOVE.l  a0,Dptrl(a3)        * else save temp READ pointer as DATA pointer
00B00B6A  4E75                    2404      RTS
00B00B6C                          2405  
00B00B6C                          2406                              * we were getting INPUT
00B00B6C                          2407  LAB_1A0E
00B00B6C  4A10                    2408      TST.b       (a0)                * test next byte
00B00B6E  6602                    2409      BNE.s       LAB_1A1B            * error if not end of INPUT
00B00B70                          2410  
00B00B70  4E75                    2411      RTS
00B00B72                          2412                              * user typed too much
00B00B72                          2413  LAB_1A1B
00B00B72  41FA 2946               2414      LEA     LAB_IMSG(pc),a0     * point to extra ignored message
00B00B76  6000 FE66               2415      BRA     LAB_18C3            * print null terminated string from memory & RTS
00B00B7A                          2416  
00B00B7A                          2417  
00B00B7A                          2418  *************************************************************************************
00B00B7A                          2419  *
00B00B7A                          2420  * perform NEXT
00B00B7A                          2421  
00B00B7A                          2422  LAB_NEXT
00B00B7A  6610                    2423      BNE.s       LAB_1A46            * branch if NEXT var
00B00B7C                          2424  
00B00B7C  584F                    2425      ADDQ.w  #4,sp               * back past return address
00B00B7E  0C57 0081               2426      CMP.w       #TK_FOR,(sp)        * is FOR token on stack?
00B00B82  6600 F5EA               2427      BNE     LAB_NFER            * if not do NEXT without FOR err/warm start
00B00B86                          2428  
00B00B86  206F 0002               2429      MOVEA.l 2(sp),a0            * get stacked FOR variable pointer
00B00B8A  601C                    2430      BRA.s       LAB_11BD            * branch always (no variable to search for)
00B00B8C                          2431  
00B00B8C                          2432  * NEXT var
00B00B8C                          2433  
00B00B8C                          2434  LAB_1A46
00B00B8C  6100 042A               2435      BSR     LAB_GVAR            * get variable address in a0
00B00B90  584F                    2436      ADDQ.w  #4,sp               * back past return address
00B00B92  303C 0081               2437      MOVE.w  #TK_FOR,d0          * set for FOR token
00B00B96  721C                    2438      MOVEQ       #$1C,d1         * set for FOR use size
00B00B98  6002                    2439      BRA.s       LAB_11A6            * enter loop for next variable search
00B00B9A                          2440  
00B00B9A                          2441  LAB_11A5
00B00B9A  DFC1                    2442      ADDA.l  d1,sp               * add FOR stack use size
00B00B9C                          2443  LAB_11A6
00B00B9C  B057                    2444      CMP.w       (sp),d0         * is FOR token on stack?
00B00B9E  6600 F5CE               2445      BNE     LAB_NFER            * if not found do NEXT without FOR error and
00B00BA2                          2446                              * warm start
00B00BA2                          2447  
00B00BA2                          2448                              * was FOR token
00B00BA2  B1EF 0002               2449      CMPA.l  2(sp),a0            * compare var pointer with stacked var pointer
00B00BA6  66F2                    2450      BNE.s       LAB_11A5            * loop if no match found
00B00BA8                          2451  
00B00BA8                          2452  LAB_11BD
00B00BA8  376F 0006 0600          2453      MOVE.w  6(sp),FAC2_e(a3)        * get STEP value exponent and sign
00B00BAE  276F 0008 05FC          2454      MOVE.l  8(sp),FAC2_m(a3)        * get STEP value mantissa
00B00BB4                          2455  
00B00BB4  176F 0012 0619          2456      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type
00B00BBA  6100 021C               2457      BSR     LAB_1C19            * check type and unpack (a0)
00B00BBE                          2458  
00B00BBE  176B 0601 0602          2459      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00B00BC4  102B 05F9               2460      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00B00BC8  B12B 0602               2461      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00B00BCC                          2462  
00B00BCC  2748 04D6               2463      MOVE.l  a0,Lvarpl(a3)       * save variable pointer
00B00BD0  6100 0CB6               2464      BSR     LAB_ADD         * add STEP value to FOR variable
00B00BD4  176F 0012 0619          2465      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type (again)
00B00BDA  6100 0FAC               2466      BSR     LAB_PFAC            * pack FAC1 into FOR variable (Lvarpl)
00B00BDE                          2467  
00B00BDE  376F 000C 0600          2468      MOVE.w  12(sp),FAC2_e(a3)       * get TO value exponent and sign
00B00BE4  276F 000E 05FC          2469      MOVE.l  14(sp),FAC2_m(a3)       * get TO value mantissa
00B00BEA                          2470  
00B00BEA  176B 0601 0602          2471      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00B00BF0  102B 05F9               2472      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00B00BF4  B12B 0602               2473      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00B00BF8                          2474  
00B00BF8  6100 1038               2475      BSR     LAB_27FA            * compare FAC1 with FAC2 (TO value)
00B00BFC                          2476                              * returns d0=+1 if FAC1 > FAC2
00B00BFC                          2477                              * returns d0= 0 if FAC1 = FAC2
00B00BFC                          2478                              * returns d0=-1 if FAC1 < FAC2
00B00BFC                          2479  
00B00BFC  322F 0006               2480      MOVE.w  6(sp),d1            * get STEP value exponent and sign
00B00C00  B141                    2481      EOR.w       d0,d1               * EOR compare result with STEP exponent and sign
00B00C02                          2482  
00B00C02  4A00                    2483      TST.b       d0              * test for =
00B00C04  6704                    2484      BEQ.s       LAB_1A90            * branch if = (loop INcomplete)
00B00C06                          2485  
00B00C06  4A01                    2486      TST.b       d1              * test result
00B00C08  6A0E                    2487      BPL.s       LAB_1A9B            * branch if > (loop complete)
00B00C0A                          2488  
00B00C0A                          2489                              * loop back and do it all again
00B00C0A                          2490  LAB_1A90
00B00C0A  276F 0014 04B6          2491      MOVE.l  20(sp),Clinel(a3)       * reset current line
00B00C10  2A6F 0018               2492      MOVE.l  24(sp),a5           * reset BASIC execute pointer
00B00C14  6000 F976               2493      BRA     LAB_15C2            * go do interpreter inner loop
00B00C18                          2494  
00B00C18                          2495                              * loop complete so carry on
00B00C18                          2496  LAB_1A9B
00B00C18  DEFC 001C               2497      ADDA.w  #28,sp          * add 28 to dump FOR structure
00B00C1C  6100 018C               2498      BSR     LAB_GBYT            * scan memory
00B00C20  B03C 002C               2499      CMP.b       #$2C,d0         * compare with ","
00B00C24  6600 F966               2500      BNE     LAB_15C2            * if not "," go do interpreter inner loop
00B00C28                          2501  
00B00C28                          2502                              * was "," so another NEXT variable to do
00B00C28  6100 017E               2503      BSR     LAB_IGBY            * else increment & scan memory
00B00C2C  6100 FF5E               2504      BSR     LAB_1A46            * do NEXT (var)
00B00C30                          2505  
00B00C30                          2506  
00B00C30                          2507  *************************************************************************************
00B00C30                          2508  *
00B00C30                          2509  * evaluate expression & check is numeric, else do type mismatch
00B00C30                          2510  
00B00C30                          2511  LAB_EVNM
00B00C30  6116                    2512      BSR.s       LAB_EVEX            * evaluate expression
00B00C32                          2513  
00B00C32                          2514  
00B00C32                          2515  *************************************************************************************
00B00C32                          2516  *
00B00C32                          2517  * check if source is numeric, else do type mismatch
00B00C32                          2518  
00B00C32                          2519  LAB_CTNM
00B00C32  B040                    2520      CMP.w       d0,d0               * required type is numeric so clear carry
00B00C34                          2521  
00B00C34                          2522  
00B00C34                          2523  *************************************************************************************
00B00C34                          2524  *
00B00C34                          2525  * type match check, set C for string, clear C for numeric
00B00C34                          2526  
00B00C34                          2527  LAB_CKTM
00B00C34  082B 0007 0619          2528      BTST.b  #7,Dtypef(a3)       * test data type flag, don't change carry
00B00C3A  6606                    2529      BNE.s       LAB_1ABA            * branch if data type is string
00B00C3C                          2530  
00B00C3C                          2531                              * else data type was numeric
00B00C3C  6500 F500               2532      BCS     LAB_TMER            * if required type is string do type mismatch
00B00C40                          2533                              * error
00B00C40                          2534  
00B00C40  4E75                    2535      RTS
00B00C42                          2536                              * data type was string, now check required type
00B00C42                          2537  LAB_1ABA
00B00C42  6400 F4FA               2538      BCC     LAB_TMER            * if required type is numeric do type mismatch
00B00C46                          2539                              * error
00B00C46  4E75                    2540      RTS
00B00C48                          2541  
00B00C48                          2542  
00B00C48                          2543  *************************************************************************************
00B00C48                          2544  *
00B00C48                          2545  * this routine evaluates any type of expression. first it pushes an end marker so
00B00C48                          2546  * it knows when the expression has been evaluated, this is a precedence value of zero.
00B00C48                          2547  * next the first value is evaluated, this can be an in line value, either numeric or
00B00C48                          2548  * string, a variable or array element of any type, a function or even an expression
00B00C48                          2549  * in parenthesis. this value is kept in FAC_1
00B00C48                          2550  * after the value is evaluated a test is made on the next BASIC program byte, if it
00B00C48                          2551  * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
00B00C48                          2552  * in the comparison evaluation flag. this test loops until no more comparrison operators
00B00C48                          2553  * are found or more than one of any type is found. in the last case an error is generated
00B00C48                          2554  
00B00C48                          2555  * evaluate expression
00B00C48                          2556  
00B00C48                          2557  LAB_EVEX
00B00C48  534D                    2558      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00B00C4A                          2559  LAB_EVEZ
00B00C4A  7200                    2560      MOVEQ       #0,d1               * clear precedence word
00B00C4C  1741 0619               2561      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
00B00C50                          2562                              * $00=float
00B00C50  601C                    2563      BRA.s       LAB_1ACD            * enter loop
00B00C52                          2564  
00B00C52                          2565  * get vector, set up operator then continue evaluation
00B00C52                          2566  
00B00C52                          2567  LAB_1B43                        *
00B00C52  41FA 22BC               2568      LEA     LAB_OPPT(pc),a0     * point to operator vector table
00B00C56  3030 1002               2569      MOVE.w  2(a0,d1.w),d0       * get vector offset
00B00C5A  4870 0000               2570      PEA     (a0,d0.w)           * push vector
00B00C5E                          2571  
00B00C5E  2F2B 05F4               2572      MOVE.l  FAC1_m(a3),-(sp)        * push FAC1 mantissa
00B00C62  3F2B 05F8               2573      MOVE.w  FAC1_e(a3),-(sp)        * push sign and exponent
00B00C66  1F2B 0647               2574      MOVE.b  comp_f(a3),-(sp)        * push comparison evaluation flag
00B00C6A                          2575  
00B00C6A  3230 1000               2576      MOVE.w  (a0,d1.w),d1        * get precedence value
00B00C6E                          2577  LAB_1ACD
00B00C6E  3F01                    2578      MOVE.w  d1,-(sp)            * push precedence value
00B00C70  6100 00E4               2579      BSR     LAB_GVAL            * get value from line
00B00C74  177C 0000 0647          2580      MOVE.b  #$00,comp_f(a3)     * clear compare function flag
00B00C7A                          2581  LAB_1ADB
00B00C7A  6100 012E               2582      BSR     LAB_GBYT            * scan memory
00B00C7E                          2583  LAB_1ADE
00B00C7E  0400 00BC               2584      SUB.b       #TK_GT,d0           * subtract token for > (lowest compare function)
00B00C82  652A                    2585      BCS.s       LAB_1AFA            * branch if < TK_GT
00B00C84                          2586  
00B00C84  B03C 0003               2587      CMP.b       #$03,d0         * compare with ">" to "<" tokens
00B00C88  650A                    2588      BCS.s       LAB_1AE0            * branch if <= TK_SGN (is compare function)
00B00C8A                          2589  
00B00C8A  4A2B 0647               2590      TST.b       comp_f(a3)          * test compare function flag
00B00C8E  6660                    2591      BNE.s       LAB_1B2A            * branch if compare function
00B00C90                          2592  
00B00C90  6000 0086               2593      BRA     LAB_1B78            * go do functions
00B00C94                          2594  
00B00C94                          2595                              * was token for > = or < (d0 = 0, 1 or 2)
00B00C94                          2596  LAB_1AE0
00B00C94  7201                    2597      MOVEQ       #1,d1               * set to 0000 0001
00B00C96  E121                    2598      ASL.b       d0,d1               * 1 if >, 2 if =, 4 if <
00B00C98  102B 0647               2599      MOVE.b  comp_f(a3),d0       * copy old compare function flag
00B00C9C  B32B 0647               2600      EOR.b       d1,comp_f(a3)       * EOR in this compare function bit
00B00CA0  B02B 0647               2601      CMP.b       comp_f(a3),d0       * compare old with new compare function flag
00B00CA4  6400 F4C4               2602      BCC     LAB_SNER            * if new <= old comp_f do syntax error and warm
00B00CA8                          2603                              * start, there was more than one <, = or >
00B00CA8  6100 00FE               2604      BSR     LAB_IGBY            * increment & scan memory
00B00CAC  60D0                    2605      BRA.s       LAB_1ADE            * go do next character
00B00CAE                          2606  
00B00CAE                          2607                              * token is < ">" or > "<" tokens
00B00CAE                          2608  LAB_1AFA
00B00CAE  4A2B 0647               2609      TST.b       comp_f(a3)          * test compare function flag
00B00CB2  663C                    2610      BNE.s       LAB_1B2A            * branch if compare function
00B00CB4                          2611  
00B00CB4                          2612                              * was < TK_GT so is operator or lower
00B00CB4  0600 000A               2613      ADD.b   #(TK_GT-TK_PLUS),d0     * add # of operators (+ - * / ^ AND OR EOR)
00B00CB8  645E                    2614      BCC.s       LAB_1B78            * branch if < + operator
00B00CBA                          2615  
00B00CBA  6608                    2616      BNE.s       LAB_1B0B            * branch if not + token
00B00CBC                          2617  
00B00CBC  4A2B 0619               2618      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00CC0                          2619                              * $00=float
00B00CC0  6B00 087C               2620      BMI     LAB_224D            * type is string & token was +
00B00CC4                          2621  
00B00CC4                          2622  LAB_1B0B
00B00CC4  7200                    2623      MOVEQ       #0,d1               * clear longword
00B00CC6  D000                    2624      ADD.b       d0,d0               * *2
00B00CC8  D000                    2625      ADD.b       d0,d0               * *4
00B00CCA  1200                    2626      MOVE.b  d0,d1               * copy to index
00B00CCC                          2627  LAB_1B13
00B00CCC  301F                    2628      MOVE.w  (sp)+,d0            * pull previous precedence
00B00CCE  41FA 2240               2629      LEA     LAB_OPPT(pc),a0     * set pointer to operator table
00B00CD2  B070 1000               2630      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00B00CD6  6446                    2631      BCC.s       LAB_1B7D            * branch if previous precedence (d0) >=
00B00CD8                          2632  
00B00CD8  6100 FF58               2633      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00B00CDC                          2634  LAB_1B1C
00B00CDC  3F00                    2635      MOVE.w  d0,-(sp)            * save precedence
00B00CDE                          2636  LAB_1B1D
00B00CDE  6100 FF72               2637      BSR     LAB_1B43            * get vector, set-up operator and continue
00B00CE2                          2638                              * evaluation
00B00CE2  301F                    2639      MOVE.w  (sp)+,d0            * restore precedence
00B00CE4  222B 063C               2640      MOVE.l  prstk(a3),d1        * get stacked function pointer
00B00CE8  6A22                    2641      BPL.s       LAB_1B3C            * branch if stacked values
00B00CEA                          2642  
00B00CEA  3000                    2643      MOVE.w  d0,d0               * copy precedence (set flags)
00B00CEC  672E                    2644      BEQ.s       LAB_1B7B            * exit if done
00B00CEE                          2645  
00B00CEE  603C                    2646      BRA.s       LAB_1B86            * else pop FAC2 & return (do function)
00B00CF0                          2647  
00B00CF0                          2648                              * was compare function (< = >)
00B00CF0                          2649  LAB_1B2A
00B00CF0  102B 0619               2650      MOVE.b  Dtypef(a3),d0       * get data type flag
00B00CF4  122B 0647               2651      MOVE.b  comp_f(a3),d1       * get compare function flag
00B00CF8  D000                    2652      ADD.b       d0,d0               * string bit flag into X bit
00B00CFA  D301                    2653      ADDX.b  d1,d1               * shift compare function flag
00B00CFC                          2654  
00B00CFC  177C 0000 0619          2655      MOVE.b  #0,Dtypef(a3)       * clear data type flag, $00=float
00B00D02  1741 0647               2656      MOVE.b  d1,comp_f(a3)       * save new compare function flag
00B00D06  534D                    2657      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00B00D08  7230                    2658      MOVEQ       #(TK_LT-TK_PLUS)*4,d1   * set offset to last operator entry
00B00D0A  60C0                    2659      BRA.s       LAB_1B13            * branch always
00B00D0C                          2660  
00B00D0C                          2661  LAB_1B3C
00B00D0C  41FA 2202               2662      LEA     LAB_OPPT(pc),a0     * point to function vector table
00B00D10  B070 1000               2663      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00B00D14  6416                    2664      BCC.s       LAB_1B86            * branch if d0 >=, pop FAC2 & return
00B00D16                          2665  
00B00D16  60C4                    2666      BRA.s       LAB_1B1C            * branch always
00B00D18                          2667  
00B00D18                          2668  * do functions
00B00D18                          2669  
00B00D18                          2670  LAB_1B78
00B00D18  72FF                    2671      MOVEQ       #-1,d1          * flag all done
00B00D1A  301F                    2672      MOVE.w  (sp)+,d0            * pull precedence word
00B00D1C                          2673  LAB_1B7B
00B00D1C  6732                    2674      BEQ.s       LAB_1B9D            * exit if done
00B00D1E                          2675  
00B00D1E                          2676  LAB_1B7D
00B00D1E  B07C 0064               2677      CMP.w       #$64,d0         * compare previous precedence with $64
00B00D22  6704                    2678      BEQ.s       LAB_1B84            * branch if was $64 (< function can be string)
00B00D24                          2679  
00B00D24  6100 FF0C               2680      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00B00D28                          2681  LAB_1B84
00B00D28  2741 063C               2682      MOVE.l  d1,prstk(a3)        * save current operator index
00B00D2C                          2683  
00B00D2C                          2684                              * pop FAC2 & return
00B00D2C                          2685  LAB_1B86
00B00D2C  101F                    2686      MOVE.b  (sp)+,d0            * pop comparison evaluation flag
00B00D2E  1200                    2687      MOVE.b  d0,d1               * copy comparison evaluation flag
00B00D30  E208                    2688      LSR.b       #1,d0               * shift out comparison evaluation lowest bit
00B00D32  1740 0645               2689      MOVE.b  d0,Cflag(a3)        * save comparison evaluation flag
00B00D36  375F 0600               2690      MOVE.w  (sp)+,FAC2_e(a3)        * pop exponent and sign
00B00D3A  275F 05FC               2691      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00B00D3E  176B 0601 0602          2692      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign
00B00D44  102B 05F9               2693      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00B00D48  B12B 0602               2694      EOR.b       d0,FAC_sc(a3)       * EOR FAC1 sign and set sign compare
00B00D4C                          2695  
00B00D4C  E209                    2696      LSR.b       #1,d1               * type bit into X and C
00B00D4E  4E75                    2697      RTS
00B00D50                          2698  
00B00D50                          2699  LAB_1B9D
00B00D50  102B 05F8               2700      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B00D54  4E75                    2701      RTS
00B00D56                          2702  
00B00D56                          2703  
00B00D56                          2704  *************************************************************************************
00B00D56                          2705  *
00B00D56                          2706  * get a value from the BASIC line
00B00D56                          2707  
00B00D56                          2708  LAB_GVAL
00B00D56  6150                    2709      BSR.s       LAB_IGBY            * increment & scan memory
00B00D58  6500 1B3E               2710      BCS     LAB_2887            * if numeric get FAC1 from string & return
00B00D5C                          2711  
00B00D5C  4A00                    2712      TST.b       d0              * test byte
00B00D5E  6B00 008E               2713      BMI     LAB_1BD0            * if -ve go test token values
00B00D62                          2714  
00B00D62                          2715                              * else it is either a string, number, variable
00B00D62                          2716                              * or (<expr>)
00B00D62  B03C 0024               2717      CMP.b       #'$',d0         * compare with "$"
00B00D66  6700 1B30               2718      BEQ     LAB_2887            * if "$" get hex number from string & return
00B00D6A                          2719  
00B00D6A  B03C 0025               2720      CMP.b       #'%',d0         * else compare with "%"
00B00D6E  6700 1B28               2721      BEQ     LAB_2887            * if "%" get binary number from string & return
00B00D72                          2722  
00B00D72  B03C 002E               2723      CMP.b       #$2E,d0         * compare with "."
00B00D76  6700 1B20               2724      BEQ     LAB_2887            * if so get FAC1 from string and return
00B00D7A                          2725                              * (e.g. .123)
00B00D7A                          2726  
00B00D7A                          2727                              * wasn't a number so ...
00B00D7A  B03C 0022               2728      CMP.b       #$22,d0         * compare with "
00B00D7E  660C                    2729      BNE.s       LAB_1BF3            * if not open quote it must be a variable or
00B00D80                          2730                              * open bracket
00B00D80                          2731  
00B00D80                          2732                              * was open quote so get the enclosed string
00B00D80                          2733  
00B00D80                          2734  * print "..." string to string stack
00B00D80                          2735  
00B00D80                          2736  LAB_1BC1
00B00D80  101D                    2737      MOVE.b  (a5)+,d0            * increment BASIC execute pointer (past ")
00B00D82                          2738                              * fastest/shortest method
00B00D82  204D                    2739      MOVEA.l a5,a0               * copy basic execute pointer (string start)
00B00D84  6100 0638               2740      BSR     LAB_20AE            * print " terminated string to stack
00B00D88  2A4A                    2741      MOVEA.l a2,a5               * restore BASIC execute pointer from temp
00B00D8A  4E75                    2742      RTS
00B00D8C                          2743  
00B00D8C                          2744  * get value from line .. continued
00B00D8C                          2745                              * wasn't any sort of number so ...
00B00D8C                          2746  LAB_1BF3
00B00D8C  B03C 0028               2747      CMP.b       #'(',d0         * compare with "("
00B00D90  6642                    2748      BNE.s       LAB_1C18            * if not "(" get (var) and return value in FAC1
00B00D92                          2749                              * and $ flag
00B00D92                          2750  
00B00D92                          2751  
00B00D92                          2752  *************************************************************************************
00B00D92                          2753  *
00B00D92                          2754  * evaluate expression within parentheses
00B00D92                          2755  
00B00D92                          2756  LAB_1BF7
00B00D92  6100 FEB6               2757      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00B00D96                          2758  
00B00D96                          2759  
00B00D96                          2760  *************************************************************************************
00B00D96                          2761  *
00B00D96                          2762  * all the 'scan for' routines return the character after the sought character
00B00D96                          2763  
00B00D96                          2764  * scan for ")", else do syntax error, then warm start
00B00D96                          2765  
00B00D96                          2766  LAB_1BFB
00B00D96  7029                    2767      MOVEQ       #$29,d0         * load d0 with ")"
00B00D98  6006                    2768      BRA.s       LAB_SCCA
00B00D9A                          2769  
00B00D9A                          2770  
00B00D9A                          2771  *************************************************************************************
00B00D9A                          2772  *
00B00D9A                          2773  * scan for "," and get byte, else do Syntax error then warm start
00B00D9A                          2774  
00B00D9A                          2775  LAB_SCGB
00B00D9A  487A 0976               2776      PEA     LAB_GTBY(pc)        * return address is to get byte parameter
00B00D9E                          2777  
00B00D9E                          2778  
00B00D9E                          2779  *************************************************************************************
00B00D9E                          2780  *
00B00D9E                          2781  * scan for ",", else do syntax error, then warm start
00B00D9E                          2782  
00B00D9E                          2783  LAB_1C01
00B00D9E  702C                    2784      MOVEQ       #$2C,d0         * load d0 with ","
00B00DA0                          2785  
00B00DA0                          2786  
00B00DA0                          2787  *************************************************************************************
00B00DA0                          2788  *
00B00DA0                          2789  * scan for CHR$(d0) , else do syntax error, then warm start
00B00DA0                          2790  
00B00DA0                          2791  LAB_SCCA
00B00DA0  B01D                    2792      CMP.b       (a5)+,d0            * check next byte is = d0
00B00DA2  6706                    2793      BEQ.s       LAB_GBYT            * if so go get next
00B00DA4                          2794  
00B00DA4  6000 F3C4               2795      BRA     LAB_SNER            * else do syntax error/warm start
00B00DA8                          2796  
00B00DA8                          2797  
00B00DA8                          2798  *************************************************************************************
00B00DA8                          2799  *
00B00DA8                          2800  * BASIC increment and scan memory routine
00B00DA8                          2801  
00B00DA8                          2802  LAB_IGBY
00B00DA8  101D                    2803      MOVE.b  (a5)+,d0            * get byte & increment pointer
00B00DAA                          2804  
00B00DAA                          2805  * scan memory routine, exit with Cb = 1 if numeric character
00B00DAA                          2806  * also skips any spaces encountered
00B00DAA                          2807  
00B00DAA                          2808  LAB_GBYT
00B00DAA  1015                    2809      MOVE.b  (a5),d0         * get byte
00B00DAC                          2810  
00B00DAC  B03C 0020               2811      CMP.b       #$20,d0         * compare with " "
00B00DB0  67F6                    2812      BEQ.s       LAB_IGBY            * if " " go do next
00B00DB2                          2813  
00B00DB2                          2814  * test current BASIC byte, exit with Cb = 1 if numeric character
00B00DB2                          2815  
00B00DB2  B03C 00A9               2816      CMP.b       #TK_ELSE,d0         * compare with the token for ELSE
00B00DB6  640C                    2817      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00B00DB8                          2818  
00B00DB8  B03C 003A               2819      CMP.b       #$3A,d0         * compare with ":"
00B00DBC  6406                    2820      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00B00DBE                          2821  
00B00DBE  7CD0                    2822      MOVEQ       #$D0,d6         * set -"0"
00B00DC0  D006                    2823      ADD.b       d6,d0               * add -"0"
00B00DC2  9006                    2824      SUB.b       d6,d0               * subtract -"0"
00B00DC4                          2825  RTS_001                     * carry set if byte = "0"-"9"
00B00DC4  4E75                    2826      RTS
00B00DC6                          2827  
00B00DC6                          2828  
00B00DC6                          2829  *************************************************************************************
00B00DC6                          2830  *
00B00DC6                          2831  * set-up for - operator
00B00DC6                          2832  
00B00DC6                          2833  LAB_1C11
00B00DC6  6100 FE6A               2834      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00B00DCA  7228                    2835      MOVEQ   #(TK_GT-TK_PLUS)*4,d1       * set offset from base to - operator
00B00DCC                          2836  LAB_1C13
00B00DCC  4FEF 0004               2837      LEA     4(sp),sp            * dump GVAL return address
00B00DD0  6000 FF0C               2838      BRA     LAB_1B1D            * continue evaluating expression
00B00DD4                          2839  
00B00DD4                          2840  
00B00DD4                          2841  *************************************************************************************
00B00DD4                          2842  *
00B00DD4                          2843  * variable name set-up
00B00DD4                          2844  * get (var), return value in FAC_1 & data type flag
00B00DD4                          2845  
00B00DD4                          2846  LAB_1C18
00B00DD4  6100 01E2               2847      BSR     LAB_GVAR            * get variable address in a0
00B00DD8                          2848  
00B00DD8                          2849  * if you want a non existant variable to return a null value then set the novar
00B00DD8                          2850  * value at the top of this file to some non zero value
00B00DD8                          2851  
00B00DD8                 FALSE    2852   ifne   novar
00B00DD8                          2853   endc
00B00DD8                          2854  
00B00DD8                          2855  * return existing variable value
00B00DD8                          2856  
00B00DD8                          2857  LAB_1C19
00B00DD8  4A2B 0619               2858      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B00DDC                          2859                              * $00=float
00B00DDC  6700 0D8E               2860      BEQ     LAB_UFAC            * if float unpack memory (a0) into FAC1 and
00B00DE0                          2861                              * return
00B00DE0                          2862  
00B00DE0  6A06                    2863      BPL.s       LAB_1C1A            * if integer unpack memory (a0) into FAC1
00B00DE2                          2864                              * and return
00B00DE2                          2865  
00B00DE2  2748 05F4               2866      MOVE.l  a0,FAC1_m(a3)       * else save descriptor pointer in FAC1
00B00DE6  4E75                    2867      RTS
00B00DE8                          2868  
00B00DE8                          2869  LAB_1C1A
00B00DE8  2010                    2870      MOVE.l  (a0),d0         * get integer value
00B00DEA  6000 04BC               2871      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B00DEE                          2872  
00B00DEE                          2873  
00B00DEE                          2874  *************************************************************************************
00B00DEE                          2875  *
00B00DEE                          2876  * get value from line .. continued
00B00DEE                          2877  * do tokens
00B00DEE                          2878  
00B00DEE                          2879  LAB_1BD0
00B00DEE  B03C 00B3               2880      CMP.b       #TK_MINUS,d0        * compare with token for -
00B00DF2  67D2                    2881      BEQ.s       LAB_1C11            * branch if - token (do set-up for - operator)
00B00DF4                          2882  
00B00DF4                          2883                              * wasn't -123 so ...
00B00DF4  B03C 00B2               2884      CMP.b       #TK_PLUS,d0         * compare with token for +
00B00DF8  6700 FF5C               2885      BEQ     LAB_GVAL            * branch if + token (+n = n so ignore leading +)
00B00DFC                          2886  
00B00DFC  B03C 00AE               2887      CMP.b       #TK_NOT,d0          * compare with token for NOT
00B00E00  6606                    2888      BNE.s       LAB_1BE7            * branch if not token for NOT
00B00E02                          2889  
00B00E02                          2890                              * was NOT token
00B00E02  323C 002C               2891      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1    * offset to NOT function
00B00E06  60C4                    2892      BRA.s       LAB_1C13            * do set-up for function then execute
00B00E08                          2893  
00B00E08                          2894                              * wasn't +, - or NOT so ...
00B00E08                          2895  LAB_1BE7
00B00E08  B03C 00AB               2896      CMP.b       #TK_FN,d0           * compare with token for FN
00B00E0C  6700 0514               2897      BEQ     LAB_201E            * if FN go evaluate FNx
00B00E10                          2898  
00B00E10                          2899                              * wasn't +, -, NOT or FN so ...
00B00E10  0400 00BF               2900      SUB.b       #TK_SGN,d0          * compare with token for SGN & normalise
00B00E14  6500 F354               2901      BCS     LAB_SNER            * if < SGN token then do syntax error
00B00E18                          2902  
00B00E18                          2903  * get value from line .. continued
00B00E18                          2904  * only functions left so set up function references
00B00E18                          2905  
00B00E18                          2906  * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00B00E18                          2907  * to process function calls. now the function vector is computed and pushed on the stack
00B00E18                          2908  * and the preprocess offset is read. if the preprocess offset is non zero then the vector
00B00E18                          2909  * is calculated and the routine called, if not this routine just does RTS. whichever
00B00E18                          2910  * happens the RTS at the end of this routine, or the preprocess routine calls, the
00B00E18                          2911  * function code
00B00E18                          2912  
00B00E18                          2913  * this also removes some less than elegant code that was used to bypass type checking
00B00E18                          2914  * for functions that returned strings
00B00E18                          2915  
00B00E18  C07C 007F               2916      AND.w       #$7F,d0         * mask byte
00B00E1C  D040                    2917      ADD.w       d0,d0               * *2 (2 bytes per function offset)
00B00E1E                          2918  
00B00E1E  41FA 20A4               2919      LEA     LAB_FTBL(pc),a0     * pointer to functions vector table
00B00E22  3230 0000               2920      MOVE.w  (a0,d0.w),d1        * get function vector offset
00B00E26  4870 1000               2921      PEA     (a0,d1.w)           * push function vector
00B00E2A                          2922  
00B00E2A  41FA 204C               2923      LEA     LAB_FTPP(pc),a0     * pointer to functions preprocess vector table
00B00E2E  3030 0000               2924      MOVE.w  (a0,d0.w),d0        * get function preprocess vector offset
00B00E32  6712                    2925      BEQ.s       LAB_1C2A            * no preprocess vector so go do function
00B00E34                          2926  
00B00E34  41F0 0000               2927      LEA     (a0,d0.w),a0        * get function preprocess vector
00B00E38  4ED0                    2928      JMP     (a0)                * go do preprocess routine then function
00B00E3A                          2929  
00B00E3A                          2930  
00B00E3A                          2931  *************************************************************************************
00B00E3A                          2932  *
00B00E3A                          2933  * process string expression in parenthesis
00B00E3A                          2934  
00B00E3A                          2935  LAB_PPFS
00B00E3A  6100 FF56               2936      BSR     LAB_1BF7            * process expression in parenthesis
00B00E3E  4A2B 0619               2937      TST.b       Dtypef(a3)          * test data type
00B00E42  6A00 F2FA               2938      BPL     LAB_TMER            * if numeric do Type missmatch Error/warm start
00B00E46                          2939  
00B00E46                          2940  LAB_1C2A
00B00E46  4E75                    2941      RTS                     * else do function
00B00E48                          2942  
00B00E48                          2943  
00B00E48                          2944  *************************************************************************************
00B00E48                          2945  *
00B00E48                          2946  * process numeric expression in parenthesis
00B00E48                          2947  
00B00E48                          2948  LAB_PPFN
00B00E48  6100 FF48               2949      BSR     LAB_1BF7            * process expression in parenthesis
00B00E4C  4A2B 0619               2950      TST.b       Dtypef(a3)          * test data type
00B00E50  6B00 F2EC               2951      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00B00E54                          2952  
00B00E54  4E75                    2953      RTS                     * else do function
00B00E56                          2954  
00B00E56                          2955  
00B00E56                          2956  *************************************************************************************
00B00E56                          2957  *
00B00E56                          2958  * set numeric data type and increment BASIC execute pointer
00B00E56                          2959  
00B00E56                          2960  LAB_PPBI
00B00E56  177C 0000 0619          2961      MOVE.b  #$00,Dtypef(a3)     * clear data type flag, $00=float
00B00E5C  101D                    2962      MOVE.b  (a5)+,d0            * get next BASIC byte
00B00E5E  4E75                    2963      RTS                     * do function
00B00E60                          2964  
00B00E60                          2965  
00B00E60                          2966  *************************************************************************************
00B00E60                          2967  *
00B00E60                          2968  * process string for LEFT$, RIGHT$ or MID$
00B00E60                          2969  
00B00E60                          2970  LAB_LRMS
00B00E60  6100 FDE8               2971      BSR     LAB_EVEZ            * evaluate (should be string) expression
00B00E64  4A2B 0619               2972      TST.b       Dtypef(a3)          * test data type flag
00B00E68  6A00 F2D4               2973      BPL     LAB_TMER            * if type is not string do type mismatch error
00B00E6C                          2974  
00B00E6C  141D                    2975      MOVE.b  (a5)+,d2            * get BASIC byte
00B00E6E  B43C 002C               2976      CMP.b       #',',d2         * compare with comma
00B00E72  6600 F2F6               2977      BNE     LAB_SNER            * if not "," go do syntax error/warm start
00B00E76                          2978  
00B00E76  2F2B 05F4               2979      MOVE.l  FAC1_m(a3),-(sp)        * save descriptor pointer
00B00E7A  6100 08AA               2980      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00B00E7E  205F                    2981      MOVEA.l (sp)+,a0            * restore descriptor pointer
00B00E80  4E75                    2982      RTS                     * do function
00B00E82                          2983  
00B00E82                          2984  
00B00E82                          2985  *************************************************************************************
00B00E82                          2986  *
00B00E82                          2987  * process numeric expression(s) for BIN$ or HEX$
00B00E82                          2988  
00B00E82                          2989  LAB_BHSS
00B00E82  6100 FDC6               2990      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00B00E86  4A2B 0619               2991      TST.b       Dtypef(a3)          * test data type
00B00E8A  6B00 F2B2               2992      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00B00E8E                          2993  
00B00E8E  6100 0DCE               2994      BSR     LAB_2831            * convert FAC1 floating to fixed
00B00E92                          2995                              * result in d0 and Itemp
00B00E92  7200                    2996      MOVEQ       #0,d1               * set default to no leading "0"s
00B00E94  141D                    2997      MOVE.b  (a5)+,d2            * get BASIC byte
00B00E96  B43C 002C               2998      CMP.b       #',',d2         * compare with comma
00B00E9A  660C                    2999      BNE.s       LAB_BHCB            * if not "," go check close bracket
00B00E9C                          3000  
00B00E9C  2F00                    3001      MOVE.l  d0,-(sp)            * copy number to stack
00B00E9E  6100 0872               3002      BSR     LAB_GTBY            * get byte value
00B00EA2  2200                    3003      MOVE.l  d0,d1               * copy leading 0s #
00B00EA4  201F                    3004      MOVE.l  (sp)+,d0            * restore number from stack
00B00EA6  141D                    3005      MOVE.b  (a5)+,d2            * get BASIC byte
00B00EA8                          3006  LAB_BHCB
00B00EA8  B43C 0029               3007      CMP.b       #')',d2         * compare with close bracket
00B00EAC  6600 F2BC               3008      BNE     LAB_SNER            * if not ")" do Syntax Error/warm start
00B00EB0                          3009  
00B00EB0  4E75                    3010      RTS                     * go do function
00B00EB2                          3011  
00B00EB2                          3012  
00B00EB2                          3013  *************************************************************************************
00B00EB2                          3014  *
00B00EB2                          3015  * perform EOR
00B00EB2                          3016  
00B00EB2                          3017  LAB_EOR
00B00EB2  6116                    3018      BSR.s       GetFirst            * get two values for OR, AND or EOR
00B00EB4                          3019                              * first in d0, and Itemp, second in d2
00B00EB4  B580                    3020      EOR.l       d2,d0               * EOR values
00B00EB6  6000 03F0               3021      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B00EBA                          3022  
00B00EBA                          3023  
00B00EBA                          3024  *************************************************************************************
00B00EBA                          3025  *
00B00EBA                          3026  * perform OR
00B00EBA                          3027  
00B00EBA                          3028  LAB_OR
00B00EBA  610E                    3029      BSR.s       GetFirst            * get two values for OR, AND or EOR
00B00EBC                          3030                              * first in d0, and Itemp, second in d2
00B00EBC  8082                    3031      OR.l        d2,d0               * do OR
00B00EBE  6000 03E8               3032      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B00EC2                          3033  
00B00EC2                          3034  
00B00EC2                          3035  *************************************************************************************
00B00EC2                          3036  *
00B00EC2                          3037  * perform AND
00B00EC2                          3038  
00B00EC2                          3039  LAB_AND
00B00EC2  6106                    3040      BSR.s       GetFirst            * get two values for OR, AND or EOR
00B00EC4                          3041                              * first in d0, and Itemp, second in d2
00B00EC4  C082                    3042      AND.l       d2,d0               * do AND
00B00EC6  6000 03E0               3043      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B00ECA                          3044  
00B00ECA                          3045  
00B00ECA                          3046  *************************************************************************************
00B00ECA                          3047  *
00B00ECA                          3048  * get two values for OR, AND, EOR
00B00ECA                          3049  * first in d0, second in d2
00B00ECA                          3050  
00B00ECA                          3051  GetFirst
00B00ECA  6100 0228               3052      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00B00ECE                          3053                              * result in d0 and Itemp
00B00ECE  2400                    3054      MOVE.l  d0,d2               * copy second value
00B00ED0  6100 0CF4               3055      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00B00ED4                          3056                              * expression
00B00ED4  6000 021E               3057      BRA     LAB_EVIR            * evaluate integer expression (no sign check)
00B00ED8                          3058                              * result in d0 and Itemp & return
00B00ED8                          3059  
00B00ED8                          3060  
00B00ED8                          3061  *************************************************************************************
00B00ED8                          3062  *
00B00ED8                          3063  * perform NOT
00B00ED8                          3064  
00B00ED8                          3065  LAB_EQUAL
00B00ED8  6100 021A               3066      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00B00EDC                          3067                              * result in d0 and Itemp
00B00EDC  4680                    3068      NOT.l       d0              * bitwise invert
00B00EDE  6000 03C8               3069      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B00EE2                          3070  
00B00EE2                          3071  
00B00EE2                          3072  *************************************************************************************
00B00EE2                          3073  *
00B00EE2                          3074  * perform comparisons
00B00EE2                          3075  * do < compare
00B00EE2                          3076  
00B00EE2                          3077  LAB_LTHAN
00B00EE2  6100 FD50               3078      BSR     LAB_CKTM            * type match check, set C for string
00B00EE6  6506                    3079      BCS.s       LAB_1CAE            * branch if string
00B00EE8                          3080  
00B00EE8                          3081                              * do numeric < compare
00B00EE8  6100 0D48               3082      BSR     LAB_27FA            * compare FAC1 with FAC2
00B00EEC                          3083                              * returns d0=+1 if FAC1 > FAC2
00B00EEC                          3084                              * returns d0= 0 if FAC1 = FAC2
00B00EEC                          3085                              * returns d0=-1 if FAC1 < FAC2
00B00EEC  6042                    3086      BRA.s       LAB_1CF2            * process result
00B00EEE                          3087  
00B00EEE                          3088                              * do string < compare
00B00EEE                          3089  LAB_1CAE
00B00EEE  177C 0000 0619          3090      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00B00EF4                          3091                              * $00=float
00B00EF4  6100 06BC               3092      BSR     LAB_22B6            * pop string off descriptor stack, or from top
00B00EF8                          3093                              * of string space returns d0 = length,
00B00EF8                          3094                              * a0 = pointer
00B00EF8  2248                    3095      MOVEA.l a0,a1               * copy string 2 pointer
00B00EFA  2200                    3096      MOVE.l  d0,d1               * copy string 2 length
00B00EFC  206B 05FC               3097      MOVEA.l FAC2_m(a3),a0       * get string 1 descriptor pointer
00B00F00  6100 06B4               3098      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00B00F04                          3099                              * d0 = length, a0 = pointer
00B00F04  2400                    3100      MOVE.l  d0,d2               * copy length
00B00F06  6604                    3101      BNE.s       LAB_1CB5            * branch if not null string
00B00F08                          3102  
00B00F08  4A81                    3103      TST.l       d1              * test if string 2 is null also
00B00F0A  6724                    3104      BEQ.s       LAB_1CF2            * if so do string 1 = string 2
00B00F0C                          3105  
00B00F0C                          3106  LAB_1CB5
00B00F0C  9481                    3107      SUB.l       d1,d2               * subtract string 2 length
00B00F0E  670C                    3108      BEQ.s       LAB_1CD5            * branch if strings = length
00B00F10                          3109  
00B00F10  6504                    3110      BCS.s       LAB_1CD4            * branch if string 1 < string 2
00B00F12                          3111  
00B00F12  70FF                    3112      MOVEQ       #-1,d0          * set for string 1 > string 2
00B00F14  6008                    3113      BRA.s       LAB_1CD6            * go do character comapare
00B00F16                          3114  
00B00F16                          3115  LAB_1CD4
00B00F16  2200                    3116      MOVE.l  d0,d1               * string 1 length is compare length
00B00F18  7001                    3117      MOVEQ       #1,d0               * and set for string 1 < string 2
00B00F1A  6002                    3118      BRA.s       LAB_1CD6            * go do character comapare
00B00F1C                          3119  
00B00F1C                          3120  LAB_1CD5
00B00F1C  2002                    3121      MOVE.l  d2,d0               * set for string 1 = string 2
00B00F1E                          3122  LAB_1CD6
00B00F1E  5381                    3123      SUBQ.l  #1,d1               * adjust length for DBcc loop
00B00F20                          3124  
00B00F20                          3125                              * d1 is length to compare, d0 is <=> for length
00B00F20                          3126                              * a0 is string 1 pointer, a1 is string 2 pointer
00B00F20                          3127  LAB_1CE6
00B00F20  B308                    3128      CMPM.b  (a0)+,(a1)+         * compare string bytes (1 with 2)
00B00F22  56C9 FFFC               3129      DBNE        d1,LAB_1CE6         * loop if same and not end yet
00B00F26                          3130  
00B00F26  6708                    3131      BEQ.s       LAB_1CF2            * if = to here, then go use length compare
00B00F28                          3132  
00B00F28  6404                    3133      BCC.s       LAB_1CDB            * else branch if string 1 > string 2
00B00F2A                          3134  
00B00F2A  70FF                    3135      MOVEQ       #-1,d0          * else set for string 1 < string 2
00B00F2C  6002                    3136      BRA.s       LAB_1CF2            * go set result
00B00F2E                          3137  
00B00F2E                          3138  LAB_1CDB
00B00F2E  7001                    3139      MOVEQ       #1,d0               * and set for string 1 > string 2
00B00F30                          3140  
00B00F30                          3141  LAB_1CF2
00B00F30  5200                    3142      ADDQ.b  #1,d0               * make result 0, 1 or 2
00B00F32  1200                    3143      MOVE.b  d0,d1               * copy to d1
00B00F34  7001                    3144      MOVEQ       #1,d0               * set d0 longword
00B00F36  E338                    3145      ROL.b       d1,d0               * make 1, 2 or 4 (result = flag bit)
00B00F38  C02B 0645               3146      AND.b       Cflag(a3),d0        * AND with comparison evaluation flag
00B00F3C  6700 0CDC               3147      BEQ     LAB_27DB            * exit if not a wanted result (i.e. false)
00B00F40                          3148  
00B00F40  70FF                    3149      MOVEQ       #-1,d0          * else set -1 (true)
00B00F42  6000 0CD6               3150      BRA     LAB_27DB            * save d0 as integer & return
00B00F46                          3151  
00B00F46                          3152  
00B00F46                          3153  LAB_1CFE
00B00F46  6100 FE56               3154      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00B00F4A                          3155  
00B00F4A                          3156  
00B00F4A                          3157  *************************************************************************************
00B00F4A                          3158  *
00B00F4A                          3159  * perform DIM
00B00F4A                          3160  
00B00F4A                          3161  LAB_DIM
00B00F4A  72FF                    3162      MOVEQ       #-1,d1          * set "DIM" flag
00B00F4C  6170                    3163      BSR.s       LAB_1D10            * search for or dimension a variable
00B00F4E  6100 FE5A               3164      BSR     LAB_GBYT            * scan memory
00B00F52  66F2                    3165      BNE.s       LAB_1CFE            * loop and scan for "," if not null
00B00F54                          3166  
00B00F54  4E75                    3167      RTS
00B00F56                          3168  
00B00F56                          3169  
00B00F56                          3170  *************************************************************************************
00B00F56                          3171  *
00B00F56                          3172  * perform << (left shift)
00B00F56                          3173  
00B00F56                          3174  LAB_LSHIFT
00B00F56  612E                    3175      BSR.s       GetPair         * get an integer and byte pair
00B00F58                          3176                              * byte is in d2, integer is in d0 and Itemp
00B00F58  6708                    3177      BEQ.s       NoShift         * branch if byte zero
00B00F5A                          3178  
00B00F5A  B43C 0020               3179      CMP.b       #$20,d2         * compare bit count with 32d
00B00F5E  6420                    3180      BCC.s       TooBig          * branch if >=
00B00F60                          3181  
00B00F60  E5A0                    3182      ASL.l       d2,d0               * shift longword
00B00F62                          3183  NoShift
00B00F62  6000 0344               3184      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B00F66                          3185  
00B00F66                          3186  
00B00F66                          3187  *************************************************************************************
00B00F66                          3188  *
00B00F66                          3189  * perform >> (right shift)
00B00F66                          3190  
00B00F66                          3191  LAB_RSHIFT
00B00F66  611E                    3192      BSR.s       GetPair         * get an integer and byte pair
00B00F68                          3193                              * byte is in d2, integer is in d0 and Itemp
00B00F68  67F8                    3194      BEQ.s       NoShift         * branch if byte zero
00B00F6A                          3195  
00B00F6A  B43C 0020               3196      CMP.b       #$20,d2         * compare bit count with 32d
00B00F6E  650A                    3197      BCS.s       Not2Big         * branch if >= (return shift)
00B00F70                          3198  
00B00F70  4A80                    3199      TST.l       d0              * test sign bit
00B00F72  6A0C                    3200      BPL.s       TooBig          * branch if +ve
00B00F74                          3201  
00B00F74  70FF                    3202      MOVEQ       #-1,d0          * set longword
00B00F76  6000 0330               3203      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00B00F7A                          3204  
00B00F7A                          3205  Not2Big
00B00F7A  E4A0                    3206      ASR.l       d2,d0               * shift longword
00B00F7C  6000 032A               3207      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00B00F80                          3208  
00B00F80                          3209  TooBig
00B00F80  7000                    3210      MOVEQ       #0,d0               * clear longword
00B00F82  6000 0324               3211      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00B00F86                          3212  
00B00F86                          3213  
00B00F86                          3214  *************************************************************************************
00B00F86                          3215  *
00B00F86                          3216  * get an integer and byte pair
00B00F86                          3217  * byte is in d2, integer is in d0 and Itemp
00B00F86                          3218  
00B00F86                          3219  GetPair
00B00F86  6100 078E               3220      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00B00F8A                          3221                              * Itemp
00B00F8A  1400                    3222      MOVE.b  d0,d2               * save it
00B00F8C  6100 0C38               3223      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00B00F90                          3224                              * expression
00B00F90  6100 0162               3225      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00B00F94                          3226                              * result in d0 and Itemp
00B00F94  4A02                    3227      TST.b       d2              * test byte value
00B00F96  4E75                    3228      RTS
00B00F98                          3229  
00B00F98                          3230  
00B00F98                          3231  *************************************************************************************
00B00F98                          3232  *
00B00F98                          3233  * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
00B00F98                          3234  
00B00F98                          3235  LAB_CASC
00B00F98  B03C 0061               3236      CMP.b       #$61,d0         * compare with "a"
00B00F9C  6410                    3237      BCC.s       LAB_1D83            * if >="a" go check =<"z"
00B00F9E                          3238  
00B00F9E                          3239  
00B00F9E                          3240  *************************************************************************************
00B00F9E                          3241  *
00B00F9E                          3242  * check alpha upper case, return C=0 if<"A" or >"Z"
00B00F9E                          3243  
00B00F9E                          3244  LAB_CAUC
00B00F9E  B03C 0041               3245      CMP.b       #$41,d0         * compare with "A"
00B00FA2  6404                    3246      BCC.s       LAB_1D8A            * if >="A" go check =<"Z"
00B00FA4                          3247  
00B00FA4  8040                    3248      OR      d0,d0               * make C=0
00B00FA6  4E75                    3249      RTS
00B00FA8                          3250  
00B00FA8                          3251  LAB_1D8A
00B00FA8  B03C 005B               3252      CMP.b       #$5B,d0         * compare with "Z"+1
00B00FAC                          3253                              * carry set if byte<="Z"
00B00FAC  4E75                    3254      RTS
00B00FAE                          3255  
00B00FAE                          3256  LAB_1D83
00B00FAE  B03C 007B               3257      CMP.b       #$7B,d0         * compare with "z"+1
00B00FB2                          3258                              * carry set if byte<="z"
00B00FB2  4E75                    3259      RTS
00B00FB4                          3260  
00B00FB4                          3261  
00B00FB4                          3262  *************************************************************************************
00B00FB4                          3263  *
00B00FB4                          3264  * search for or create variable. this is used to automatically create a variable if
00B00FB4                          3265  * it is not found. any routines that need to create the variable call LAB_GVAR via
00B00FB4                          3266  * this point and error generation is supressed and the variable will be created
00B00FB4                          3267  *
00B00FB4                          3268  * return pointer to variable in Cvaral and a0
00B00FB4                          3269  * set data type to variable type
00B00FB4                          3270  
00B00FB4                          3271  LAB_SVAR
00B00FB4  6102                    3272      BSR.s       LAB_GVAR            * search for variable
00B00FB6                          3273  LAB_FVAR
00B00FB6  4E75                    3274      RTS
00B00FB8                          3275  
00B00FB8                          3276  
00B00FB8                          3277  *************************************************************************************
00B00FB8                          3278  *
00B00FB8                          3279  * search for variable. if this routine is called from anywhere but the above call and
00B00FB8                          3280  * the variable searched for does not exist then an error will be returned
00B00FB8                          3281  *
00B00FB8                          3282  * DIM flag is in d1.b
00B00FB8                          3283  * return pointer to variable in Cvaral and a0
00B00FB8                          3284  * set data type to variable type
00B00FB8                          3285  
00B00FB8                          3286  LAB_GVAR
00B00FB8  7200                    3287      MOVEQ       #$00,d1         * set DIM flag = $00
00B00FBA  6100 FDEE               3288      BSR     LAB_GBYT            * scan memory (1st character)
00B00FBE                          3289  LAB_1D10
00B00FBE  1741 0618               3290      MOVE.b  d1,Defdim(a3)       * save DIM flag
00B00FC2                          3291  
00B00FC2                          3292  * search for FN name entry point
00B00FC2                          3293  
00B00FC2                          3294  LAB_1D12
00B00FC2  61D4                    3295      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00B00FC4  6400 F1A4               3296      BCC     LAB_SNER            * if not, syntax error then warm start
00B00FC8                          3297  
00B00FC8                          3298                              * it is a variable name so ...
00B00FC8  7200                    3299      MOVEQ       #$0,d1          * set index for name byte
00B00FCA  41EB 04CE               3300      LEA     Varname(a3),a0      * pointer to variable name
00B00FCE  2081                    3301      MOVE.l  d1,(a0)         * clear the variable name
00B00FD0  1741 0619               3302      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
00B00FD4                          3303                              * $00=float
00B00FD4                          3304  
00B00FD4                          3305  LAB_1D2D
00B00FD4  B27C 0004               3306      CMP.w       #$04,d1         * done all significant characters?
00B00FD8  6406                    3307      BCC.s       LAB_1D2E            * if so go ignore any more
00B00FDA                          3308  
00B00FDA  1180 1000               3309      MOVE.b  d0,(a0,d1.w)        * save the character
00B00FDE  5241                    3310      ADDQ.w  #1,d1               * increment index
00B00FE0                          3311  LAB_1D2E
00B00FE0  6100 FDC6               3312      BSR     LAB_IGBY            * increment & scan memory (next character)
00B00FE4  65EE                    3313      BCS.s       LAB_1D2D            * branch if character = "0"-"9" (ok)
00B00FE6                          3314  
00B00FE6                          3315                              * character wasn't "0" to "9" so ...
00B00FE6  61B0                    3316      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00B00FE8  65EA                    3317      BCS.s       LAB_1D2D            * branch if = "A"-"Z" (ok)
00B00FEA                          3318  
00B00FEA                          3319                              * check if string variable
00B00FEA  B03C 0024               3320      CMP.b       #'$',d0         * compare with "$"
00B00FEE  660C                    3321      BNE.s       LAB_1D44            * branch if not string
00B00FF0                          3322  
00B00FF0                          3323                              * type is string
00B00FF0  002B 0080 04CF          3324      OR.b        #$80,Varname+1(a3)  * set top bit of 2nd character, indicate string
00B00FF6  6100 FDB0               3325      BSR     LAB_IGBY            * increment & scan memory
00B00FFA  6010                    3326      BRA.s       LAB_1D45            * skip integer check
00B00FFC                          3327  
00B00FFC                          3328                              * check if integer variable
00B00FFC                          3329  LAB_1D44
00B00FFC  B03C 0026               3330      CMP.b       #'&',d0         * compare with "&"
00B01000  660A                    3331      BNE.s       LAB_1D45            * branch if not integer
00B01002                          3332  
00B01002                          3333                              * type is integer
00B01002  002B 0080 04D0          3334      OR.b        #$80,Varname+2(a3)  * set top bit of 3rd character, indicate integer
00B01008  6100 FD9E               3335      BSR     LAB_IGBY            * increment & scan memory
00B0100C                          3336  
00B0100C                          3337  * after we have determined the variable type we need to determine
00B0100C                          3338  * if it's an array of type
00B0100C                          3339  
00B0100C                          3340                              * gets here with character after var name in d0
00B0100C                          3341  LAB_1D45
00B0100C  4A2B 0643               3342      TST.b       Sufnxf(a3)          * test function name flag
00B01010  670E                    3343      BEQ.s       LAB_1D48            * if not FN or FN variable continue
00B01012                          3344  
00B01012  6A14                    3345      BPL.s       LAB_1D49            * if FN variable go find or create it
00B01014                          3346  
00B01014                          3347                              * else was FN name
00B01014  202B 04CE               3348      MOVE.l  Varname(a3),d0      * get whole function name
00B01018  7208                    3349      MOVEQ       #8,d1               * set step to next function size -4
00B0101A  41EB 0496               3350      LEA     Sfncl(a3),a0        * get pointer to start of functions
00B0101E  601C                    3351      BRA.s       LAB_1D4B            * go find function
00B01020                          3352  
00B01020                          3353  LAB_1D48
00B01020  0400 0028               3354      SUB.b       #'(',d0         * subtract "("
00B01024  6700 00F4               3355      BEQ     LAB_1E17            * if "(" go find, or make, array
00B01028                          3356  
00B01028                          3357  * either find or create var
00B01028                          3358  * var name (1st four characters only!) is in Varname
00B01028                          3359  
00B01028                          3360                              * variable name wasn't var( .. so look for
00B01028                          3361                              * plain variable
00B01028                          3362  LAB_1D49
00B01028  202B 04CE               3363      MOVE.l  Varname(a3),d0      * get whole variable name
00B0102C                          3364  LAB_1D4A
00B0102C  7204                    3365      MOVEQ       #4,d1               * set step to next variable size -4
00B0102E  41EB 049A               3366      LEA     Svarl(a3),a0        * get pointer to start of variables
00B01032                          3367  
00B01032  0800 0017               3368      BTST.l  #23,d0          * test if string name
00B01036  6704                    3369      BEQ.s       LAB_1D4B            * branch if not
00B01038                          3370  
00B01038  5441                    3371      ADDQ.w  #2,d1               * 6 bytes per string entry
00B0103A  5848                    3372      ADDQ.w  #(Sstrl-Svarl),a0       * move to string area
00B0103C                          3373  
00B0103C                          3374  LAB_1D4B
00B0103C  2268 0004               3375      MOVEA.l 4(a0),a1            * get end address
00B01040  2050                    3376      MOVEA.l (a0),a0         * get start address
00B01042  6006                    3377      BRA.s       LAB_1D5E            * enter loop at exit check
00B01044                          3378  
00B01044                          3379  LAB_1D5D
00B01044  B098                    3380      CMP.l       (a0)+,d0            * compare this variable with name
00B01046  6776                    3381      BEQ.s       LAB_1DD7            * branch if match (found var)
00B01048                          3382  
00B01048  D1C1                    3383      ADDA.l  d1,a0               * add offset to next variable
00B0104A                          3384  LAB_1D5E
00B0104A  B1C9                    3385      CMPA.l  a1,a0               * compare address with variable space end
00B0104C  66F6                    3386      BNE.s       LAB_1D5D            * if not end go check next
00B0104E                          3387  
00B0104E  4A2B 0643               3388      TST.b       Sufnxf(a3)          * is it a function or function variable
00B01052  660A                    3389      BNE.s       LAB_1D94            * if was go do DEF or function variable
00B01054                          3390  
00B01054                          3391                              * reached end of variable mem without match
00B01054                          3392                              * ... so create new variable, possibly
00B01054                          3393  
00B01054  45FA FF60               3394      LEA     LAB_FVAR(pc),a2     * get the address of the create if doesn't
00B01058                          3395                              * exist call to LAB_GVAR
00B01058  B5D7                    3396      CMPA.l  (sp),a2         * compare the return address with expected
00B0105A  6600 F0CA               3397      BNE     LAB_UVER            * if not create go do error or return null
00B0105E                          3398  
00B0105E                          3399  * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
00B0105E                          3400  
00B0105E                          3401  LAB_1D94
00B0105E  082B 0000 0643          3402      BTST.b  #0,Sufnxf(a3)       * test function search flag
00B01064  6600 F0C8               3403      BNE     LAB_UFER            * if not doing DEF then go do undefined
00B01068                          3404                              * function error
00B01068                          3405  
00B01068                          3406                              * else create new variable/function
00B01068                          3407  LAB_1D98
00B01068  246B 04A6               3408      MOVEA.l Earryl(a3),a2       * get end of block to move
00B0106C  240A                    3409      MOVE.l  a2,d2               * copy end of block to move
00B0106E  9489                    3410      SUB.l       a1,d2               * calculate block to move size
00B01070                          3411  
00B01070  204A                    3412      MOVEA.l a2,a0               * copy end of block to move
00B01072  5881                    3413      ADDQ.l  #4,d1               * space for one variable/function + name
00B01074  D5C1                    3414      ADDA.l  d1,a2               * add space for one variable/function
00B01076  274A 04A6               3415      MOVE.l  a2,Earryl(a3)       * set new array mem end
00B0107A  E28A                    3416      LSR.l       #1,d2               * /2 for word copy
00B0107C  6712                    3417      BEQ.s       LAB_1DAF            * skip move if zero length block
00B0107E                          3418  
00B0107E  5382                    3419      SUBQ.l  #1,d2               * -1 for DFB loop
00B01080  4842                    3420      SWAP        d2              * swap high word to low word
00B01082                          3421  LAB_1DAC
00B01082  4842                    3422      SWAP        d2              * swap high word to low word
00B01084                          3423  LAB_1DAE
00B01084  3520                    3424      MOVE.w  -(a0),-(a2)         * copy word
00B01086  51CA FFFC               3425      DBF     d2,LAB_1DAE         * loop until done
00B0108A                          3426  
00B0108A  4842                    3427      SWAP        d2              * swap high word to low word
00B0108C  51CA FFF4               3428      DBF     d2,LAB_1DAC         * decrement high count and loop until done
00B01090                          3429  
00B01090                          3430  * get here after creating either a function, variable or string
00B01090                          3431  * if function set variables start, string start, array start
00B01090                          3432  * if variable set string start, array start
00B01090                          3433  * if string set array start
00B01090                          3434  
00B01090                          3435  LAB_1DAF
00B01090  4A2B 0643               3436      TST.b       Sufnxf(a3)          * was it function
00B01094  6B08                    3437      BMI.s       LAB_1DB0            * branch if was FN
00B01096                          3438  
00B01096  0800 0017               3439      BTST.l  #23,d0          * was it string
00B0109A  660A                    3440      BNE.s       LAB_1DB2            * branch if string
00B0109C                          3441  
00B0109C  6004                    3442      BRA.s       LAB_1DB1            * branch if was plain variable
00B0109E                          3443  
00B0109E                          3444  LAB_1DB0
00B0109E  D3AB 049A               3445      ADD.l       d1,Svarl(a3)        * set new variable memory start
00B010A2                          3446  LAB_1DB1
00B010A2  D3AB 049E               3447      ADD.l       d1,Sstrl(a3)        * set new start of strings
00B010A6                          3448  LAB_1DB2
00B010A6  D3AB 04A2               3449      ADD.l       d1,Sarryl(a3)       * set new array memory start
00B010AA  20C0                    3450      MOVE.l  d0,(a0)+            * save variable/function name
00B010AC  20BC 00000000           3451      MOVE.l  #$00,(a0)           * initialise variable
00B010B2  0800 0017               3452      BTST.l  #23,d0          * was it string
00B010B6  6706                    3453      BEQ.s       LAB_1DD7            * branch if not string
00B010B8                          3454  
00B010B8  317C 0000 0004          3455      MOVE.w  #$00,4(a0)          * else initialise string length
00B010BE                          3456  
00B010BE                          3457                              * found a match for var ((Vrschl) = ptr)
00B010BE                          3458  LAB_1DD7
00B010BE  2200                    3459      MOVE.l  d0,d1               * ........ $....... &....... ........
00B010C0  D281                    3460      ADD.l       d1,d1               * .......$ .......& ........ .......0
00B010C2  4841                    3461      SWAP        d1              * ........ .......0 .......$ .......&
00B010C4  E219                    3462      ROR.b       #1,d1               * ........ .......0 .......$ &.......
00B010C6  E249                    3463      LSR.w       #1,d1               * ........ .......0 0....... $&.....?.
00B010C8  C23C 00C0               3464      AND.b       #$C0,d1         * mask the type bits
00B010CC  1741 0619               3465      MOVE.b  d1,Dtypef(a3)       * save the data type
00B010D0                          3466  
00B010D0  177C 0000 0643          3467      MOVE.b  #$00,Sufnxf(a3)     * clear FN flag byte
00B010D6                          3468  
00B010D6                          3469  * if you want a non existant variable to return a null value then set the novar
00B010D6                          3470  * value at the top of this file to some non zero value
00B010D6                          3471  
00B010D6                 FALSE    3472   ifne   novar
00B010D6                          3473   endc
00B010D6                          3474  
00B010D6  4E75                    3475      RTS
00B010D8                          3476  
00B010D8                          3477  
00B010D8                          3478  *************************************************************************************
00B010D8                          3479  *
00B010D8                          3480  * set-up array pointer, d0, to first element in array
00B010D8                          3481  * set d0 to (a0)+2*(Dimcnt)+$0A
00B010D8                          3482  
00B010D8                          3483  LAB_1DE6
00B010D8  7005                    3484      MOVEQ       #5,d0               * set d0 to 5 (*2 = 10, later)
00B010DA  D02B 063F               3485      ADD.b       Dimcnt(a3),d0       * add # of dimensions (1, 2 or 3)
00B010DE  D080                    3486      ADD.l       d0,d0               * *2 (bytes per dimension size)
00B010E0  D088                    3487      ADD.l       a0,d0               * add array start pointer
00B010E2  4E75                    3488      RTS
00B010E4                          3489  
00B010E4                          3490  
00B010E4                          3491  *************************************************************************************
00B010E4                          3492  *
00B010E4                          3493  * evaluate unsigned integer expression
00B010E4                          3494  
00B010E4                          3495  LAB_EVIN
00B010E4  6100 FCC2               3496      BSR     LAB_IGBY            * increment & scan memory
00B010E8  6100 FB46               3497      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B010EC                          3498                              * else do type mismatch
00B010EC                          3499  
00B010EC                          3500  
00B010EC                          3501  *************************************************************************************
00B010EC                          3502  *
00B010EC                          3503  * evaluate positive integer expression, result in d0 and Itemp
00B010EC                          3504  
00B010EC                          3505  LAB_EVPI
00B010EC  4A2B 05F9               3506      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00B010F0  6B00 F06C               3507      BMI     LAB_FCER            * do function call error if -ve
00B010F4                          3508  
00B010F4                          3509  
00B010F4                          3510  *************************************************************************************
00B010F4                          3511  *
00B010F4                          3512  * evaluate integer expression, no sign check
00B010F4                          3513  * result in d0 and Itemp, exit with flags set correctly
00B010F4                          3514  
00B010F4                          3515  LAB_EVIR
00B010F4  0C2B 00A0 05F8          3516      CMPI.b  #$A0,FAC1_e(a3)     * compare exponent with exponent = 2^32 (n>2^31)
00B010FA  6500 0B62               3517      BCS     LAB_2831            * convert FAC1 floating to fixed
00B010FE                          3518                              * result in d0 and Itemp
00B010FE  6600 F05E               3519      BNE     LAB_FCER            * if > do function call error, then warm start
00B01102                          3520  
00B01102  4A2B 05F9               3521      TST.b       FAC1_s(a3)          * test sign of FAC1
00B01106  6A00 0B56               3522      BPL     LAB_2831            * if +ve then ok
00B0110A                          3523  
00B0110A  202B 05F4               3524      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B0110E  4480                    3525      NEG.l       d0              * do -d0
00B01110  6800 F04C               3526      BVC     LAB_FCER            * if not $80000000 do FC error, then warm start
00B01114                          3527  
00B01114  2740 048E               3528      MOVE.l  d0,Itemp(a3)        * else just set it
00B01118  4E75                    3529      RTS
00B0111A                          3530  
00B0111A                          3531  
00B0111A                          3532  *************************************************************************************
00B0111A                          3533  *
00B0111A                          3534  * find or make array
00B0111A                          3535  
00B0111A                          3536  LAB_1E17
00B0111A  3F2B 0618               3537      MOVE.w  Defdim(a3),-(sp)        * get DIM flag and data type flag (word in mem)
00B0111E  7200                    3538      MOVEQ       #0,d1               * clear dimensions count
00B01120                          3539  
00B01120                          3540  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
00B01120                          3541  
00B01120                          3542  LAB_1E1F
00B01120  3F01                    3543      MOVE.w  d1,-(sp)            * save dimensions count
00B01122  2F2B 04CE               3544      MOVE.l  Varname(a3),-(sp)       * save variable name
00B01126  61BC                    3545      BSR.s       LAB_EVIN            * evaluate integer expression
00B01128                          3546  
00B01128  4840                    3547      SWAP        d0              * swap high word to low word
00B0112A  4A40                    3548      TST.w       d0              * test swapped high word
00B0112C  6600 F020               3549      BNE     LAB_ABER            * if too big do array bounds error
00B01130                          3550  
00B01130  275F 04CE               3551      MOVE.l  (sp)+,Varname(a3)       * restore variable name
00B01134  321F                    3552      MOVE.w  (sp)+,d1            * restore dimensions count
00B01136  301F                    3553      MOVE.w  (sp)+,d0            * restore DIM and data type flags
00B01138  3F2B 0490               3554      MOVE.w  Itemp+2(a3),-(sp)       * stack this dimension size
00B0113C  3F00                    3555      MOVE.w  d0,-(sp)            * save DIM and data type flags
00B0113E  5241                    3556      ADDQ.w  #1,d1               * increment dimensions count
00B01140  6100 FC68               3557      BSR     LAB_GBYT            * scan memory
00B01144  B03C 002C               3558      CMP.b       #$2C,d0         * compare with ","
00B01148  67D6                    3559      BEQ.s       LAB_1E1F            * if found go do next dimension
00B0114A                          3560  
00B0114A  1741 063F               3561      MOVE.b  d1,Dimcnt(a3)       * store dimensions count
00B0114E  6100 FC46               3562      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B01152  375F 0618               3563      MOVE.w  (sp)+,Defdim(a3)        * restore DIM and data type flags (word in mem)
00B01156  206B 04A2               3564      MOVEA.l Sarryl(a3),a0       * get array mem start
00B0115A                          3565  
00B0115A                          3566  * now check to see if we are at the end of array memory (we would be if there were
00B0115A                          3567  * no arrays).
00B0115A                          3568  
00B0115A                          3569  LAB_1E5C
00B0115A  2748 0610               3570      MOVE.l  a0,Astrtl(a3)       * save as array start pointer
00B0115E  B1EB 04A6               3571      CMPA.l  Earryl(a3),a0       * compare with array mem end
00B01162  672E                    3572      BEQ.s       LAB_1EA1            * go build array if not found
00B01164                          3573  
00B01164                          3574                              * search for array
00B01164  2010                    3575      MOVE.l  (a0),d0         * get this array name
00B01166  B0AB 04CE               3576      CMP.l       Varname(a3),d0      * compare with array name
00B0116A  670A                    3577      BEQ.s       LAB_1E8D            * array found so branch
00B0116C                          3578  
00B0116C                          3579                              * no match
00B0116C  2068 0004               3580      MOVEA.l 4(a0),a0            * get this array size
00B01170  D1EB 0610               3581      ADDA.l  Astrtl(a3),a0       * add to array start pointer
00B01174  60E4                    3582      BRA.s       LAB_1E5C            * go check next array
00B01176                          3583  
00B01176                          3584                              * found array, are we trying to dimension it?
00B01176                          3585  LAB_1E8D
00B01176  4A2B 0618               3586      TST.b       Defdim(a3)          * are we trying to dimension it?
00B0117A  6600 EFCE               3587      BNE     LAB_DDER            * if so do double dimension error/warm start
00B0117E                          3588  
00B0117E                          3589  * found the array and we're not dimensioning it so we must find an element in it
00B0117E                          3590  
00B0117E  6100 FF58               3591      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00B01182                          3592                              * in the array
00B01182  5048                    3593      ADDQ.w  #8,a0               * index to dimension count
00B01184  3018                    3594      MOVE.w  (a0)+,d0            * get no of dimensions
00B01186  B02B 063F               3595      CMP.b       Dimcnt(a3),d0       * compare with dimensions count
00B0118A  6700 0094               3596      BEQ     LAB_1F28            * found array so go get element
00B0118E                          3597  
00B0118E  6000 EF8E               3598      BRA     LAB_WDER            * else wrong so do "Wrong dimensions" error
00B01192                          3599  
00B01192                          3600                              * array not found, so possibly build it
00B01192                          3601  LAB_1EA1
00B01192  4A2B 0618               3602      TST.b       Defdim(a3)          * test the default DIM flag
00B01196  6700 EF8A               3603      BEQ     LAB_UDER            * if default flag is clear then we are not
00B0119A                          3604                              * explicitly dimensioning an array so go
00B0119A                          3605                              * do an "Undimensioned array" error
00B0119A                          3606  
00B0119A  6100 FF3C               3607      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00B0119E                          3608                              * in the array
00B0119E  202B 04CE               3609      MOVE.l  Varname(a3),d0      * get array name
00B011A2  20C0                    3610      MOVE.l  d0,(a0)+            * save array name
00B011A4  7204                    3611      MOVEQ       #4,d1               * set 4 bytes per element
00B011A6  0800 0017               3612      BTST.l  #23,d0          * test if string array
00B011AA  6702                    3613      BEQ.s       LAB_1EDF            * branch if not string
00B011AC                          3614  
00B011AC  7206                    3615      MOVEQ       #6,d1               * else 6 bytes per element
00B011AE                          3616  LAB_1EDF
00B011AE  2741 060C               3617      MOVE.l  d1,Asptl(a3)        * set array data size (bytes per element)
00B011B2  122B 063F               3618      MOVE.b  Dimcnt(a3),d1       * get dimensions count
00B011B6  5848                    3619      ADDQ.w  #4,a0               * skip the array size now (don't know it yet!)
00B011B8  30C1                    3620      MOVE.w  d1,(a0)+            * set array's dimensions count
00B011BA                          3621  
00B011BA                          3622  * now calculate the array data space size
00B011BA                          3623  
00B011BA                          3624  LAB_1EC0
00B011BA                          3625  
00B011BA                          3626  * If you want arrays to dimension themselves by default then comment out the test
00B011BA                          3627  * above and uncomment the next three code lines and the label LAB_1ED0
00B011BA                          3628  
00B011BA                          3629  *   MOVE.w  #$0A,d1         * set default dimension value, allow 0 to 9
00B011BA                          3630  *   TST.b       Defdim(a3)          * test default DIM flag
00B011BA                          3631  *   BNE.s       LAB_1ED0            * branch if b6 of Defdim is clear
00B011BA                          3632  
00B011BA  321F                    3633      MOVE.w  (sp)+,d1            * get dimension size
00B011BC                          3634  *LAB_1ED0
00B011BC  30C1                    3635      MOVE.w  d1,(a0)+            * save to array header
00B011BE  6100 00AE               3636      BSR     LAB_1F7C            * do this dimension size+1 * array size
00B011C2                          3637                              * (d1+1)*(Asptl), result in d0
00B011C2  2740 060C               3638      MOVE.l  d0,Asptl(a3)        * save array data size
00B011C6  532B 063F               3639      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00B011CA  66EE                    3640      BNE.s       LAB_1EC0            * loop while not = 0
00B011CC                          3641  
00B011CC  D1EB 060C               3642      ADDA.l  Asptl(a3),a0        * add size to first element address
00B011D0  6500 EF84               3643      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00B011D4                          3644  
00B011D4  B1EB 04AA               3645      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00B011D8  650C                    3646      BCS.s       LAB_1ED6            * branch if less (is ok)
00B011DA                          3647  
00B011DA  6100 028E               3648      BSR     LAB_GARB            * do garbage collection routine
00B011DE  B1EB 04AA               3649      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00B011E2  6400 EF72               3650      BCC     LAB_OMER            * if Sstorl <= a0 do "Out of memory"
00B011E6                          3651                              * error then warm start
00B011E6                          3652  
00B011E6                          3653  LAB_1ED6                        * ok exit, carry set
00B011E6  2748 04A6               3654      MOVE.l  a0,Earryl(a3)       * save array mem end
00B011EA  7000                    3655      MOVEQ       #0,d0               * zero d0
00B011EC  222B 060C               3656      MOVE.l  Asptl(a3),d1        * get size in bytes
00B011F0  E289                    3657      LSR.l       #1,d1               * /2 for word fill (may be odd # words)
00B011F2  5341                    3658      SUBQ.w  #1,d1               * adjust for DBF loop
00B011F4                          3659  LAB_1ED8
00B011F4  3100                    3660      MOVE.w  d0,-(a0)            * decrement pointer and clear word
00B011F6  51C9 FFFC               3661      DBF     d1,LAB_1ED8         * decrement & loop until low word done
00B011FA                          3662  
00B011FA  4841                    3663      SWAP        d1              * swap words
00B011FC  4A41                    3664      TST.w       d1              * test high word
00B011FE  6706                    3665      BEQ.s       LAB_1F07            * exit if done
00B01200                          3666  
00B01200  5341                    3667      SUBQ.w  #1,d1               * decrement low (high) word
00B01202  4841                    3668      SWAP        d1              * swap back
00B01204  60EE                    3669      BRA.s       LAB_1ED8            * go do a whole block
00B01206                          3670  
00B01206                          3671  * now we need to calculate the array size by doing Earryl - Astrtl
00B01206                          3672  
00B01206                          3673  LAB_1F07
00B01206  206B 0610               3674      MOVEA.l Astrtl(a3),a0       * get for calculation and as pointer
00B0120A  202B 04A6               3675      MOVE.l  Earryl(a3),d0       * get array memory end
00B0120E  9088                    3676      SUB.l       a0,d0               * calculate array size
00B01210  2140 0004               3677      MOVE.l  d0,4(a0)            * save size to array
00B01214  4A2B 0618               3678      TST.b       Defdim(a3)          * test default DIM flag
00B01218  6652                    3679      BNE.s       RTS_011         * exit (RET) if this was a DIM command
00B0121A                          3680  
00B0121A                          3681                              * else, find element
00B0121A  5048                    3682      ADDQ.w  #8,a0               * index to dimension count
00B0121C  3758 063F               3683      MOVE.w  (a0)+,Dimcnt(a3)        * get array's dimension count
00B01220                          3684  
00B01220                          3685  * we have found, or built, the array. now we need to find the element
00B01220                          3686  
00B01220                          3687  LAB_1F28
00B01220  7000                    3688      MOVEQ       #0,d0               * clear first result
00B01222  2740 060C               3689      MOVE.l  d0,Asptl(a3)        * clear array data pointer
00B01226                          3690  
00B01226                          3691  * compare nth dimension bound (a0) with nth index (sp)+
00B01226                          3692  * if greater do array bounds error
00B01226                          3693  
00B01226                          3694  LAB_1F2C
00B01226  3218                    3695      MOVE.w  (a0)+,d1            * get nth dimension bound
00B01228  B257                    3696      CMP.w       (sp),d1         * compare nth index with nth dimension bound
00B0122A  6500 EF22               3697      BCS     LAB_ABER            * if d1 less or = do array bounds error
00B0122E                          3698  
00B0122E                          3699  * now do pointer = pointer * nth dimension + nth index
00B0122E                          3700  
00B0122E  4A80                    3701      TST.l       d0              * test pointer
00B01230  6702                    3702      BEQ.s       LAB_1F5A            * skip multiply if last result = null
00B01232                          3703  
00B01232  613A                    3704      BSR.s       LAB_1F7C            * do this dimension size+1 * array size
00B01234                          3705  LAB_1F5A
00B01234  7200                    3706      MOVEQ       #0,d1               * clear longword
00B01236  321F                    3707      MOVE.w  (sp)+,d1            * get nth dimension index
00B01238  D081                    3708      ADD.l       d1,d0               * add index to size
00B0123A  2740 060C               3709      MOVE.l  d0,Asptl(a3)        * save array data pointer
00B0123E                          3710  
00B0123E  532B 063F               3711      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00B01242  66E2                    3712      BNE.s       LAB_1F2C            * loop if dimensions still to do
00B01244                          3713  
00B01244  177C 0000 0619          3714      MOVE.b  #0,Dtypef(a3)       * set data type to float
00B0124A  7203                    3715      MOVEQ       #3,d1               * set for numeric array
00B0124C  4A2B 04CF               3716      TST.b       Varname+1(a3)       * test if string array
00B01250  6A0A                    3717      BPL.s       LAB_1F6A            * branch if not string
00B01252                          3718  
00B01252  7205                    3719      MOVEQ       #5,d1               * else set for string array
00B01254  177C 0080 0619          3720      MOVE.b  #$80,Dtypef(a3)     * and set data type to string
00B0125A  600C                    3721      BRA.s       LAB_1F6B            * skip integer test
00B0125C                          3722  
00B0125C                          3723  LAB_1F6A
00B0125C  4A2B 04D0               3724      TST.b       Varname+2(a3)       * test if integer array
00B01260  6A06                    3725      BPL.s       LAB_1F6B            * branch if not integer
00B01262                          3726  
00B01262  177C 0040 0619          3727      MOVE.b  #$40,Dtypef(a3)     * else set data type to integer
00B01268                          3728  LAB_1F6B
00B01268  6104                    3729      BSR.s       LAB_1F7C            * do element size (d1) * array size (Asptl)
00B0126A  D1C0                    3730      ADDA.l  d0,a0               * add array data start pointer
00B0126C                          3731  RTS_011
00B0126C  4E75                    3732      RTS
00B0126E                          3733  
00B0126E                          3734  
00B0126E                          3735  *************************************************************************************
00B0126E                          3736  *
00B0126E                          3737  * do this dimension size (d1) * array data size (Asptl)
00B0126E                          3738  
00B0126E                          3739  * do a 16 x 32 bit multiply
00B0126E                          3740  * d1 holds the 16 bit multiplier
00B0126E                          3741  * Asptl holds the 32 bit multiplicand
00B0126E                          3742  
00B0126E                          3743  * d0    bbbb  bbbb
00B0126E                          3744  * d1    0000  aaaa
00B0126E                          3745  *   ----------
00B0126E                          3746  * d0    rrrr  rrrr
00B0126E                          3747  
00B0126E                          3748  LAB_1F7C
00B0126E  202B 060C               3749      MOVE.l  Asptl(a3),d0        * get result
00B01272  2400                    3750      MOVE.l  d0,d2               * copy it
00B01274  4842                    3751      SWAP        d2              * shift high word to low word
00B01276  C0C1                    3752      MULU.w  d1,d0               * d1 * low word = low result
00B01278  C4C1                    3753      MULU.w  d1,d2               * d1 * high word = high result
00B0127A  4842                    3754      SWAP        d2              * align words for test
00B0127C  4A42                    3755      TST.w       d2              * must be zero
00B0127E  6600 EED6               3756      BNE     LAB_OMER            * if overflow go do "Out of memory" error
00B01282                          3757  
00B01282  D082                    3758      ADD.l       d2,d0               * calculate result
00B01284  6500 EED0               3759      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00B01288                          3760  
00B01288  D0AB 060C               3761      ADD.l       Asptl(a3),d0        * add original
00B0128C  6500 EEC8               3762      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00B01290                          3763  
00B01290  4E75                    3764      RTS
00B01292                          3765  
00B01292                          3766  
00B01292                          3767  *************************************************************************************
00B01292                          3768  *
00B01292                          3769  * perform FRE()
00B01292                          3770  
00B01292                          3771  LAB_FRE
00B01292  4A2B 0619               3772      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00B01296                          3773                              * $00=float
00B01296  6A04                    3774      BPL.s       LAB_1FB4            * branch if numeric
00B01298                          3775  
00B01298  6100 0318               3776      BSR     LAB_22B6            * pop string off descriptor stack, or from
00B0129C                          3777                              * top of string space, returns d0 = length,
00B0129C                          3778                              * a0 = pointer
00B0129C                          3779  
00B0129C                          3780                              * FRE(n) was numeric so do this
00B0129C                          3781  LAB_1FB4
00B0129C  6100 01CC               3782      BSR     LAB_GARB            * go do garbage collection
00B012A0  202B 04AA               3783      MOVE.l  Sstorl(a3),d0       * get bottom of string space
00B012A4  90AB 04A6               3784      SUB.l       Earryl(a3),d0       * subtract array mem end
00B012A8                          3785  
00B012A8                          3786  
00B012A8                          3787  *************************************************************************************
00B012A8                          3788  *
00B012A8                          3789  * convert d0 to signed longword in FAC1
00B012A8                          3790  
00B012A8                          3791  LAB_AYFC
00B012A8  177C 0000 0619          3792      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00B012AE                          3793                              * $00=float
00B012AE  377C A000 05F8          3794      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent and clear sign (b7)
00B012B4  2740 05F4               3795      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00B012B8  6A00 063E               3796      BPL     LAB_24D0            * convert if +ve
00B012BC                          3797  
00B012BC  003C 0001               3798      ORI.b       #1,CCR          * else set carry
00B012C0  6000 0636               3799      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00B012C4                          3800  
00B012C4                          3801  
00B012C4                          3802  *************************************************************************************
00B012C4                          3803  *
00B012C4                          3804  * remember if the line length is zero (infinite line) then POS(n) will return
00B012C4                          3805  * position MOD tabsize
00B012C4                          3806  
00B012C4                          3807  * perform POS()
00B012C4                          3808  
00B012C4                          3809  LAB_POS
00B012C4  102B 0649               3810      MOVE.b  TPos(a3),d0         * get terminal position
00B012C8                          3811  
00B012C8                          3812  * convert d0 to unsigned byte in FAC1
00B012C8                          3813  
00B012C8                          3814  LAB_1FD0
00B012C8  C0BC 000000FF           3815      AND.l       #$FF,d0         * clear high bits
00B012CE  60D8                    3816      BRA.s       LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00B012D0                          3817  
00B012D0                          3818  * check not direct (used by DEF and INPUT)
00B012D0                          3819  
00B012D0                          3820  LAB_CKRN
00B012D0  4A2B 04B6               3821      TST.b       Clinel(a3)          * test current line #
00B012D4  6B00 EE6C               3822      BMI     LAB_IDER            * if -ve go do illegal direct error then warm
00B012D8                          3823                              * start
00B012D8                          3824  
00B012D8  4E75                    3825      RTS                     * can continue so return
00B012DA                          3826  
00B012DA                          3827  
00B012DA                          3828  *************************************************************************************
00B012DA                          3829  *
00B012DA                          3830  * perform DEF
00B012DA                          3831  
00B012DA                          3832  LAB_DEF
00B012DA  70AB                    3833      MOVEQ       #TK_FN-$100,d0      * get FN token
00B012DC  6100 FAC2               3834      BSR     LAB_SCCA            * scan for CHR$(d0), else syntax error and
00B012E0                          3835                              * warm start
00B012E0                          3836                              * return character after d0
00B012E0  177C 0080 0643          3837      MOVE.b  #$80,Sufnxf(a3)     * set FN flag bit
00B012E6  6100 FCDA               3838      BSR     LAB_1D12            * get FN name
00B012EA  2748 0614               3839      MOVE.l  a0,func_l(a3)       * save function pointer
00B012EE                          3840  
00B012EE  61E0                    3841      BSR.s       LAB_CKRN            * check not direct (back here if ok)
00B012F0  0C1D 0028               3842      CMP.b       #$28,(a5)+          * check next byte is "(" and increment
00B012F4  6600 EE74               3843      BNE     LAB_SNER            * else do syntax error/warm start
00B012F8                          3844  
00B012F8  177C 007E 0643          3845      MOVE.b  #$7E,Sufnxf(a3)     * set FN variable flag bits
00B012FE  6100 FCB4               3846      BSR     LAB_SVAR            * search for or create a variable
00B01302                          3847                              * return the variable address in a0
00B01302  6100 FA92               3848      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B01306  70BD                    3849      MOVEQ       #TK_EQUAL-$100,d0       * = token
00B01308  6100 FA96               3850      BSR     LAB_SCCA            * scan for CHR$(A), else syntax error/warm start
00B0130C                          3851                              * return character after d0
00B0130C  2F2B 04CE               3852      MOVE.l  Varname(a3),-(sp)       * push current variable name
00B01310  2F0D                    3853      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00B01312  6100 F41A               3854      BSR     LAB_DATA            * go perform DATA, find end of DEF FN statement
00B01316  206B 0614               3855      MOVEA.l func_l(a3),a0       * get the function pointer
00B0131A  209F                    3856      MOVE.l  (sp)+,(a0)          * save BASIC execute pointer to function
00B0131C  215F 0004               3857      MOVE.l  (sp)+,4(a0)         * save current variable name to function
00B01320  4E75                    3858      RTS
00B01322                          3859  
00B01322                          3860  
00B01322                          3861  *************************************************************************************
00B01322                          3862  *
00B01322                          3863  * evaluate FNx
00B01322                          3864  
00B01322                          3865  LAB_201E
00B01322  177C 0081 0643          3866      MOVE.b  #$81,Sufnxf(a3)     * set FN flag (find not create)
00B01328  6100 FA7E               3867      BSR     LAB_IGBY            * increment & scan memory
00B0132C  6100 FC94               3868      BSR     LAB_1D12            * get FN name
00B01330  1F2B 0619               3869      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function type)
00B01334  2F08                    3870      MOVE.l  a0,-(sp)            * push function pointer
00B01336  0C15 0028               3871      CMP.b       #$28,(a5)           * check next byte is "(", no increment
00B0133A  6600 EE2E               3872      BNE     LAB_SNER            * else do syntax error/warm start
00B0133E                          3873  
00B0133E  6100 FA52               3874      BSR     LAB_1BF7            * evaluate expression within parentheses
00B01342  205F                    3875      MOVEA.l (sp)+,a0            * pop function pointer
00B01344  2748 0614               3876      MOVE.l  a0,func_l(a3)       * set function pointer
00B01348  1F2B 0619               3877      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function expression type)
00B0134C                          3878  
00B0134C  2028 0004               3879      MOVE.l  4(a0),d0            * get function variable name
00B01350  6100 FCDA               3880      BSR     LAB_1D4A            * go find function variable (already created)
00B01354                          3881  
00B01354                          3882                              * now check type match for variable
00B01354  101F                    3883      MOVE.b  (sp)+,d0            * pop data type flag (function expression type)
00B01356  E318                    3884      ROL.b       #1,d0               * set carry if type = string
00B01358  6100 F8DA               3885      BSR     LAB_CKTM            * type match check, set C for string
00B0135C                          3886  
00B0135C                          3887                              * now stack the function variable value before
00B0135C                          3888                              * use
00B0135C  6712                    3889      BEQ.s       LAB_2043            * branch if not string
00B0135E                          3890  
00B0135E  43EB 04DA               3891      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00B01362  B9C9                    3892      CMPA.l  a1,a4               * compare string stack pointer with max+1
00B01364  6700 EDD0               3893      BEQ     LAB_SCER            * if no space on the stack go do string too
00B01368                          3894                              * complex error
00B01368                          3895  
00B01368  3928 0004               3896      MOVE.w  4(a0),-(a4)         * string length on descriptor stack
00B0136C  2910                    3897      MOVE.l  (a0),-(a4)          * string address on stack
00B0136E  6002                    3898      BRA.s       LAB_204S            * skip var push
00B01370                          3899  
00B01370                          3900  LAB_2043
00B01370  2F10                    3901      MOVE.l  (a0),-(sp)          * push variable
00B01372                          3902  LAB_204S
00B01372  2F08                    3903      MOVE.l  a0,-(sp)            * push variable address
00B01374  1F2B 0619               3904      MOVE.b  Dtypef(a3),-(sp)        * push variable data type
00B01378                          3905  
00B01378  6132                    3906      BSR.s       LAB_2045            * pack function expression value into (a0)
00B0137A                          3907                              * (function variable)
00B0137A  2F0D                    3908      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00B0137C  206B 0614               3909      MOVEA.l func_l(a3),a0       * get function pointer
00B01380  2A50                    3910      MOVEA.l (a0),a5         * save function execute ptr as BASIC execute ptr
00B01382  6100 F8C4               3911      BSR     LAB_EVEX            * evaluate expression
00B01386  6100 FA22               3912      BSR     LAB_GBYT            * scan memory
00B0138A  6600 EDDE               3913      BNE     LAB_SNER            * if not [EOL] or [EOS] do syntax error and
00B0138E                          3914                              * warm start
00B0138E                          3915  
00B0138E  2A5F                    3916      MOVE.l  (sp)+,a5            * restore BASIC execute pointer
00B01390                          3917  
00B01390                          3918  * restore variable from stack and test data type
00B01390                          3919  
00B01390  101F                    3920      MOVE.b  (sp)+,d0            * pull variable data type
00B01392  205F                    3921      MOVEA.l (sp)+,a0            * pull variable address
00B01394  4A00                    3922      TST.b       d0              * test variable data type
00B01396  6A08                    3923      BPL.s       LAB_204T            * branch if not string
00B01398                          3924  
00B01398  209C                    3925      MOVE.l  (a4)+,(a0)          * string address from descriptor stack
00B0139A  315C 0004               3926      MOVE.w  (a4)+,4(a0)         * string length from descriptor stack
00B0139E  6002                    3927      BRA.s       LAB_2044            * skip variable pull
00B013A0                          3928  
00B013A0                          3929  LAB_204T
00B013A0  209F                    3930      MOVE.l  (sp)+,(a0)          * restore variable from stack
00B013A2                          3931  LAB_2044
00B013A2  101F                    3932      MOVE.b  (sp)+,d0            * pop data type flag (function type)
00B013A4  E318                    3933      ROL.b       #1,d0               * set carry if type = string
00B013A6  6100 F88C               3934      BSR     LAB_CKTM            * type match check, set C for string
00B013AA  4E75                    3935      RTS
00B013AC                          3936  
00B013AC                          3937  LAB_2045
00B013AC  4A2B 0619               3938      TST.b       Dtypef(a3)          * test data type
00B013B0  6A00 07EE               3939      BPL     LAB_2778            * if numeric pack FAC1 into variable (a0)
00B013B4                          3940                              * and return
00B013B4                          3941  
00B013B4  2448                    3942      MOVEA.l a0,a2               * copy variable pointer
00B013B6  6000 F514               3943      BRA     LAB_17D6            * go do string LET & return
00B013BA                          3944  
00B013BA                          3945  
00B013BA                          3946  
00B013BA                          3947  *************************************************************************************
00B013BA                          3948  *
00B013BA                          3949  * perform STR$()
00B013BA                          3950  
00B013BA                          3951  LAB_STRS
00B013BA  6100 094A               3952      BSR     LAB_2970            * convert FAC1 to string
00B013BE                          3953  
00B013BE                          3954  * scan, set up string
00B013BE                          3955  * print " terminated string to FAC1 stack
00B013BE                          3956  
00B013BE                          3957  LAB_20AE
00B013BE  7422                    3958      MOVEQ       #$22,d2         * set Srchc character (terminator 1)
00B013C0  3602                    3959      MOVE.w  d2,d3               * set Asrch character (terminator 2)
00B013C2                          3960  
00B013C2                          3961  * print d2/d3 terminated string to FAC1 stack
00B013C2                          3962  * d2 = Srchc, d3 = Asrch, a0 is source
00B013C2                          3963  * a6 is temp
00B013C2                          3964  
00B013C2                          3965  LAB_20B4
00B013C2  7200                    3966      MOVEQ       #0,d1               * clear longword
00B013C4  5341                    3967      SUBQ.w  #1,d1               * set length to -1
00B013C6  2448                    3968      MOVEA.l a0,a2               * copy start to calculate end
00B013C8                          3969  LAB_20BE
00B013C8  5241                    3970      ADDQ.w  #1,d1               * increment length
00B013CA  1030 1000               3971      MOVE.b  (a0,d1.w),d0        * get byte from string
00B013CE  6710                    3972      BEQ.s       LAB_20D0            * exit loop if null byte [EOS]
00B013D0                          3973  
00B013D0  B002                    3974      CMP.b       d2,d0               * compare with search character (terminator 1)
00B013D2  6704                    3975      BEQ.s       LAB_20CB            * branch if terminator
00B013D4                          3976  
00B013D4  B003                    3977      CMP.b       d3,d0               * compare with terminator 2
00B013D6  66F0                    3978      BNE.s       LAB_20BE            * loop if not terminator 2 (or null string)
00B013D8                          3979  
00B013D8                          3980  LAB_20CB
00B013D8  B03C 0022               3981      CMP.b       #$22,d0         * compare with "
00B013DC  6602                    3982      BNE.s       LAB_20D0            * branch if not "
00B013DE                          3983  
00B013DE  524A                    3984      ADDQ.w  #1,a2               * else increment string start (skip " at end)
00B013E0                          3985  LAB_20D0
00B013E0  D5C1                    3986      ADDA.l  d1,a2               * add longowrd length to make string end+1
00B013E2                          3987  
00B013E2  B1CB                    3988      CMPA.l  a3,a0               * is string in ram
00B013E4  651E                    3989      BCS.s       LAB_RTST            * if not go push descriptor on stack & exit
00B013E6                          3990                              * (could be message string from ROM)
00B013E6                          3991  
00B013E6  B1EB 0492               3992      CMPA.l  Smeml(a3),a0        * is string in utility ram
00B013EA  6418                    3993      BCC.s       LAB_RTST            * if not go push descriptor on stack & exit
00B013EC                          3994                              * (is in string or program space)
00B013EC                          3995  
00B013EC                          3996                              * (else) copy string to string memory
00B013EC                          3997  LAB_20C9
00B013EC  2248                    3998      MOVEA.l a0,a1               * copy descriptor pointer
00B013EE  2001                    3999      MOVE.l  d1,d0               * copy longword length
00B013F0  6604                    4000      BNE.s       LAB_20D8            * branch if not null string
00B013F2                          4001  
00B013F2  2041                    4002      MOVEA.l d1,a0               * make null pointer
00B013F4  600E                    4003      BRA.s       LAB_RTST            * go push descriptor on stack & exit
00B013F6                          4004  
00B013F6                          4005  LAB_20D8
00B013F6  6126                    4006      BSR.s       LAB_2115            * make string space d1 bytes long
00B013F8  D1C1                    4007      ADDA.l  d1,a0               * new string end
00B013FA  D3C1                    4008      ADDA.l  d1,a1               * old string end
00B013FC  5340                    4009      SUBQ.w  #1,d0               * -1 for DBF loop
00B013FE                          4010  LAB_20E0
00B013FE  1121                    4011      MOVE.b  -(a1),-(a0)         * copy byte (source can be odd aligned)
00B01400  51C8 FFFC               4012      DBF     d0,LAB_20E0         * loop until done
00B01404                          4013  
00B01404                          4014  
00B01404                          4015  
00B01404                          4016  *************************************************************************************
00B01404                          4017  *
00B01404                          4018  * check for space on descriptor stack then ...
00B01404                          4019  * put string address and length on descriptor stack & update stack pointers
00B01404                          4020  * start is in a0, length is in d1
00B01404                          4021  
00B01404                          4022  LAB_RTST
00B01404  43EB 04DA               4023      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00B01408  B9C9                    4024      CMPA.l  a1,a4               * compare string stack pointer with max+1
00B0140A  6700 ED2A               4025      BEQ     LAB_SCER            * if no space on string stack ..
00B0140E                          4026                              * .. go do 'string too complex' error
00B0140E                          4027  
00B0140E                          4028                              * push string & update pointers
00B0140E  3901                    4029      MOVE.w  d1,-(a4)            * string length on descriptor stack
00B01410  2908                    4030      MOVE.l  a0,-(a4)            * string address on stack
00B01412  274C 05F4               4031      MOVE.l  a4,FAC1_m(a3)       * string descriptor pointer in FAC1
00B01416  177C 0080 0619          4032      MOVE.b  #$80,Dtypef(a3)     * save data type flag, $80=string
00B0141C  4E75                    4033      RTS
00B0141E                          4034  
00B0141E                          4035  
00B0141E                          4036  *************************************************************************************
00B0141E                          4037  *
00B0141E                          4038  * build descriptor a0/d1
00B0141E                          4039  * make space in string memory for string d1.w long
00B0141E                          4040  * return pointer in a0/Sutill
00B0141E                          4041  
00B0141E                          4042  LAB_2115
00B0141E  4A41                    4043      TST.w       d1              * test length
00B01420  672E                    4044      BEQ.s       LAB_2128            * branch if user wants null string
00B01422                          4045  
00B01422                          4046                              * make space for string d1 long
00B01422  2F00                    4047      MOVE.l  d0,-(sp)            * save d0
00B01424  7000                    4048      MOVEQ       #0,d0               * clear longword
00B01426  1740 0642               4049      MOVE.b  d0,Gclctd(a3)       * clear garbage collected flag (b7)
00B0142A  7001                    4050      MOVEQ       #1,d0               * +1 to possibly round up
00B0142C  C041                    4051      AND.w       d1,d0               * mask odd bit
00B0142E  D041                    4052      ADD.w       d1,d0               * ensure d0 is even length
00B01430  6404                    4053      BCC.s       LAB_2117            * branch if no overflow
00B01432                          4054  
00B01432  7001                    4055      MOVEQ       #1,d0               * set to allocate 65536 bytes
00B01434  4840                    4056      SWAP        d0              * makes $00010000
00B01436                          4057  LAB_2117
00B01436  206B 04AA               4058      MOVEA.l Sstorl(a3),a0       * get bottom of string space
00B0143A  91C0                    4059      SUBA.l  d0,a0               * subtract string length
00B0143C  B1EB 04A6               4060      CMPA.l  Earryl(a3),a0       * compare with top of array space
00B01440  6512                    4061      BCS.s       LAB_2137            * if less do out of memory error
00B01442                          4062  
00B01442  2748 04AA               4063      MOVE.l  a0,Sstorl(a3)       * save bottom of string space
00B01446  2748 04B2               4064      MOVE.l  a0,Sutill(a3)       * save string utility pointer
00B0144A  201F                    4065      MOVE.l  (sp)+,d0            * restore d0
00B0144C  4A41                    4066      TST.w       d1              * set flags on length
00B0144E  4E75                    4067      RTS
00B01450                          4068  
00B01450                          4069  LAB_2128
00B01450  3041                    4070      MOVEA.w d1,a0               * make null pointer
00B01452  4E75                    4071      RTS
00B01454                          4072  
00B01454                          4073  LAB_2137
00B01454  4A2B 0642               4074      TST.b       Gclctd(a3)          * get garbage collected flag
00B01458  6B00 ECFC               4075      BMI     LAB_OMER            * do "Out of memory" error, then warm start
00B0145C                          4076  
00B0145C  2F09                    4077      MOVE.l  a1,-(sp)            * save a1
00B0145E  610A                    4078      BSR.s       LAB_GARB            * else go do garbage collection
00B01460  225F                    4079      MOVEA.l (sp)+,a1            * restore a1
00B01462  177C 0080 0642          4080      MOVE.b  #$80,Gclctd(a3)     * set garbage collected flag
00B01468  60CC                    4081      BRA.s       LAB_2117            * go try again
00B0146A                          4082  
00B0146A                          4083  
00B0146A                          4084  *************************************************************************************
00B0146A                          4085  *
00B0146A                          4086  * garbage collection routine
00B0146A                          4087  
00B0146A                          4088  LAB_GARB
00B0146A  48E7 E0E0               4089      MOVEM.l d0-d2/a0-a2,-(sp)       * save registers
00B0146E  276B 04AE 04AA          4090      MOVE.l  Ememl(a3),Sstorl(a3)    * start with no strings
00B01474                          4091  
00B01474                          4092                              * re-run routine from last ending
00B01474                          4093  LAB_214B
00B01474  222B 04A6               4094      MOVE.l  Earryl(a3),d1       * set highest uncollected string so far
00B01478  7000                    4095      MOVEQ       #0,d0               * clear longword
00B0147A  2240                    4096      MOVEA.l d0,a1               * clear string to move pointer
00B0147C  206B 049E               4097      MOVEA.l Sstrl(a3),a0        * set pointer to start of strings
00B01480  41E8 0004               4098      LEA     4(a0),a0            * index to string pointer
00B01484  246B 04A2               4099      MOVEA.l Sarryl(a3),a2       * set end pointer to start of arrays (end of
00B01488                          4100                              * strings)
00B01488  6008                    4101      BRA.s       LAB_2176            * branch into loop at end loop test
00B0148A                          4102  
00B0148A                          4103  LAB_2161
00B0148A  6100 0084               4104      BSR     LAB_2206            * test and set if this is the highest string
00B0148E  41E8 000A               4105      LEA     10(a0),a0           * increment to next string
00B01492                          4106  LAB_2176
00B01492  B1CA                    4107      CMPA.l  a2,a0               * compare end of area with pointer
00B01494  65F4                    4108      BCS.s       LAB_2161            * go do next if not at end
00B01496                          4109  
00B01496                          4110  * done strings, now do arrays.
00B01496                          4111  
00B01496  41E8 FFFC               4112      LEA     -4(a0),a0           * decrement pointer to start of arrays
00B0149A  246B 04A6               4113      MOVEA.l Earryl(a3),a2       * set end pointer to end of arrays
00B0149E  6024                    4114      BRA.s       LAB_218F            * branch into loop at end loop test
00B014A0                          4115  
00B014A0                          4116  LAB_217E
00B014A0  2428 0004               4117      MOVE.l  4(a0),d2            * get array size
00B014A4  D488                    4118      ADD.l       a0,d2               * makes start of next array
00B014A6                          4119  
00B014A6  2010                    4120      MOVE.l  (a0),d0         * get array name
00B014A8  0800 0017               4121      BTST        #23,d0          * test string flag
00B014AC  6714                    4122      BEQ.s       LAB_218B            * branch if not string
00B014AE                          4123  
00B014AE  3028 0008               4124      MOVE.w  8(a0),d0            * get # of dimensions
00B014B2  D040                    4125      ADD.w       d0,d0               * *2
00B014B4  D0C0                    4126      ADDA.w  d0,a0               * add to skip dimension size(s)
00B014B6  41E8 000A               4127      LEA     10(a0),a0           * increment to first element
00B014BA                          4128  LAB_2183
00B014BA  6154                    4129      BSR.s       LAB_2206            * test and set if this is the highest string
00B014BC  5C48                    4130      ADDQ.w  #6,a0               * increment to next element
00B014BE  B1C2                    4131      CMPA.l  d2,a0               * compare with start of next array
00B014C0  66F8                    4132      BNE.s       LAB_2183            * go do next if not at end of array
00B014C2                          4133  
00B014C2                          4134  LAB_218B
00B014C2  2042                    4135      MOVEA.l d2,a0               * pointer to next array
00B014C4                          4136  LAB_218F
00B014C4  B5C8                    4137      CMPA.l  a0,a2               * compare pointer with array end
00B014C6  66D8                    4138      BNE.s       LAB_217E            * go do next if not at end
00B014C8                          4139  
00B014C8                          4140  * done arrays and variables, now just the descriptor stack to do
00B014C8                          4141  
00B014C8  204C                    4142      MOVEA.l a4,a0               * get descriptor stack pointer
00B014CA  45EB 04F2               4143      LEA     des_sk(a3),a2       * set end pointer to end of stack
00B014CE  6006                    4144      BRA.s       LAB_21C4            * branch into loop at end loop test
00B014D0                          4145  
00B014D0                          4146  LAB_21C2
00B014D0  613E                    4147      BSR.s       LAB_2206            * test and set if this is the highest string
00B014D2  41E8 0006               4148      LEA     6(a0),a0            * increment to next string
00B014D6                          4149  LAB_21C4
00B014D6  B5C8                    4150      CMPA.l  a0,a2               * compare pointer with stack end
00B014D8  66F6                    4151      BNE.s       LAB_21C2            * go do next if not at end
00B014DA                          4152  
00B014DA                          4153  * descriptor search complete, now either exit or set-up and move string
00B014DA                          4154  
00B014DA  2009                    4155      MOVE.l  a1,d0               * set the flags (a1 is move string)
00B014DC  672C                    4156      BEQ.s       LAB_21D1            * go tidy up and exit if no move
00B014DE                          4157  
00B014DE  2051                    4158      MOVEA.l (a1),a0         * a0 is now string start
00B014E0  7200                    4159      MOVEQ       #0,d1               * clear d1
00B014E2  3229 0004               4160      MOVE.w  4(a1),d1            * d1 is string length
00B014E6  5281                    4161      ADDQ.l  #1,d1               * +1
00B014E8  C23C 00FE               4162      AND.b       #$FE,d1         * make even length
00B014EC  D1C1                    4163      ADDA.l  d1,a0               * pointer is now to string end+1
00B014EE  246B 04AA               4164      MOVEA.l Sstorl(a3),a2       * is destination end+1
00B014F2  B1CA                    4165      CMPA.l  a2,a0               * does the string need moving
00B014F4  670C                    4166      BEQ.s       LAB_2240            * branch if not
00B014F6                          4167  
00B014F6  E289                    4168      LSR.l       #1,d1               * word move so do /2
00B014F8  5341                    4169      SUBQ.w  #1,d1               * -1 for DBF loop
00B014FA                          4170  LAB_2216
00B014FA  3520                    4171      MOVE.w  -(a0),-(a2)         * copy word
00B014FC  51C9 FFFC               4172      DBF     d1,LAB_2216         * loop until done
00B01500                          4173  
00B01500  228A                    4174      MOVE.l  a2,(a1)         * save new string start
00B01502                          4175  LAB_2240
00B01502  2751 04AA               4176      MOVE.l  (a1),Sstorl(a3)     * string start is new string mem start
00B01506  6000 FF6C               4177      BRA     LAB_214B            * re-run routine from last ending
00B0150A                          4178                              * (but don't collect this string)
00B0150A                          4179  
00B0150A                          4180  LAB_21D1
00B0150A  4CDF 0707               4181      MOVEM.l (sp)+,d0-d2/a0-a2       * restore registers
00B0150E  4E75                    4182      RTS
00B01510                          4183  
00B01510                          4184  * test and set if this is the highest string
00B01510                          4185  
00B01510                          4186  LAB_2206
00B01510  2010                    4187      MOVE.l  (a0),d0         * get this string pointer
00B01512  6728                    4188      BEQ.s       RTS_012         * exit if null string
00B01514                          4189  
00B01514  B280                    4190      CMP.l       d0,d1               * compare with highest uncollected string so far
00B01516  6424                    4191      BCC.s       RTS_012         * exit if <= with highest so far
00B01518                          4192  
00B01518  B0AB 04AA               4193      CMP.l       Sstorl(a3),d0       * compare with bottom of string space
00B0151C  641E                    4194      BCC.s       RTS_012         * exit if >= bottom of string space
00B0151E                          4195  
00B0151E  70FF                    4196      MOVEQ       #-1,d0          * d0 = $FFFFFFFF
00B01520  3028 0004               4197      MOVE.w  4(a0),d0            * d0 is string length
00B01524  4440                    4198      NEG.w       d0              * make -ve
00B01526  C03C 00FE               4199      AND.b       #$FE,d0         * make -ve even length
00B0152A  D0AB 04AA               4200      ADD.l       Sstorl(a3),d0       * add string store to -ve length
00B0152E  B090                    4201      CMP.l       (a0),d0         * compare with string address
00B01530  6706                    4202      BEQ.s       LAB_2212            * if = go move string store pointer down
00B01532                          4203  
00B01532  2210                    4204      MOVE.l  (a0),d1         * highest = current
00B01534  2248                    4205      MOVEA.l a0,a1               * string to move = current
00B01536  4E75                    4206      RTS
00B01538                          4207  
00B01538                          4208  LAB_2212
00B01538  2740 04AA               4209      MOVE.l  d0,Sstorl(a3)       * set new string store start
00B0153C                          4210  RTS_012
00B0153C  4E75                    4211      RTS
00B0153E                          4212  
00B0153E                          4213  
00B0153E                          4214  *************************************************************************************
00B0153E                          4215  *
00B0153E                          4216  * concatenate - add strings
00B0153E                          4217  * string descriptor 1 is in FAC1_m, string 2 is in line
00B0153E                          4218  
00B0153E                          4219  LAB_224D
00B0153E  487A F73A               4220      PEA     LAB_1ADB(pc)        * continue evaluation after concatenate
00B01542  2F2B 05F4               4221      MOVE.l  FAC1_m(a3),-(sp)        * stack descriptor pointer for string 1
00B01546                          4222  
00B01546  6100 F80E               4223      BSR     LAB_GVAL            * get value from line
00B0154A  4A2B 0619               4224      TST.b       Dtypef(a3)          * test data type flag
00B0154E  6A00 EBEE               4225      BPL     LAB_TMER            * if type is not string do type mismatch error
00B01552                          4226  
00B01552  205F                    4227      MOVEA.l (sp)+,a0            * restore descriptor pointer for string 1
00B01554                          4228  
00B01554                          4229  *************************************************************************************
00B01554                          4230  *
00B01554                          4231  * concatenate
00B01554                          4232  * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
00B01554                          4233  
00B01554                          4234  LAB_224E
00B01554  226B 05F4               4235      MOVEA.l FAC1_m(a3),a1       * copy descriptor pointer 2
00B01558  3228 0004               4236      MOVE.w  4(a0),d1            * get length 1
00B0155C  D269 0004               4237      ADD.w       4(a1),d1            * add length 2
00B01560  6500 EBD8               4238      BCS     LAB_SLER            * if overflow go do 'string too long' error
00B01564                          4239  
00B01564  2F08                    4240      MOVE.l  a0,-(sp)            * save descriptor pointer 1
00B01566  6100 FEB6               4241      BSR     LAB_2115            * make space d1 bytes long
00B0156A  2748 05FC               4242      MOVE.l  a0,FAC2_m(a3)       * save new string start pointer
00B0156E  2057                    4243      MOVEA.l (sp),a0         * copy descriptor pointer 1 from stack
00B01570  3028 0004               4244      MOVE.w  4(a0),d0            * get length
00B01574  2050                    4245      MOVEA.l (a0),a0         * get string pointer
00B01576  6120                    4246      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00B01578                          4247                              * return with a0 = pointer, d1 = length
00B01578                          4248  
00B01578  206B 05F4               4249      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer for string 2
00B0157C  6138                    4250      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00B0157E                          4251                              * a0 = pointer, d0 = length
00B0157E  6118                    4252      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00B01580                          4253                              * return with a0 = pointer, d1 = length
00B01580                          4254  
00B01580  205F                    4255      MOVEA.l (sp)+,a0            * get descriptor pointer for string 1
00B01582  6132                    4256      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00B01584                          4257                              * d0 = length, a0 = pointer
00B01584                          4258  
00B01584  206B 05FC               4259      MOVEA.l FAC2_m(a3),a0       * retreive the result string pointer
00B01588  2208                    4260      MOVE.l  a0,d1               * copy the result string pointer
00B0158A  6700 FE78               4261      BEQ     LAB_RTST            * if it is a null string just return it
00B0158E                          4262                              * a0 = pointer, d1 = length
00B0158E                          4263  
00B0158E  4481                    4264      NEG.l       d1              * else make the start pointer negative
00B01590  D2AB 04B2               4265      ADD.l       Sutill(a3),d1       * add the end pointert to give the length
00B01594  6000 FE6E               4266      BRA     LAB_RTST            * push string on descriptor stack
00B01598                          4267                              * a0 = pointer, d1 = length
00B01598                          4268  
00B01598                          4269  
00B01598                          4270  *************************************************************************************
00B01598                          4271  *
00B01598                          4272  * copy string d0 bytes long from a0 to Sutill
00B01598                          4273  * return with a0 = pointer, d1 = length
00B01598                          4274  
00B01598                          4275  LAB_229E
00B01598  3200                    4276      MOVE.w  d0,d1               * copy and check length
00B0159A  6714                    4277      BEQ.s       RTS_013         * skip copy if null
00B0159C                          4278  
00B0159C  226B 04B2               4279      MOVEA.l Sutill(a3),a1       * get destination pointer
00B015A0  2F09                    4280      MOVE.l  a1,-(sp)            * save destination string pointer
00B015A2  5340                    4281      SUBQ.w  #1,d0               * subtract for DBF loop
00B015A4                          4282  LAB_22A0
00B015A4  12D8                    4283      MOVE.b  (a0)+,(a1)+         * copy byte
00B015A6  51C8 FFFC               4284      DBF     d0,LAB_22A0         * loop if not done
00B015AA                          4285  
00B015AA  2749 04B2               4286      MOVE.l  a1,Sutill(a3)       * update Sutill to end of copied string
00B015AE  205F                    4287      MOVEA.l (sp)+,a0            * restore destination string pointer
00B015B0                          4288  RTS_013
00B015B0  4E75                    4289      RTS
00B015B2                          4290  
00B015B2                          4291  
00B015B2                          4292  *************************************************************************************
00B015B2                          4293  *
00B015B2                          4294  * pop string off descriptor stack, or from top of string space
00B015B2                          4295  * returns with d0.l = length, a0 = pointer
00B015B2                          4296  
00B015B2                          4297  LAB_22B6
00B015B2  206B 05F4               4298      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00B015B6                          4299  
00B015B6                          4300  
00B015B6                          4301  *************************************************************************************
00B015B6                          4302  *
00B015B6                          4303  * pop (a0) descriptor off stack or from string space
00B015B6                          4304  * returns with d0.l = length, a0 = pointer
00B015B6                          4305  
00B015B6                          4306  LAB_22BA
00B015B6  48E7 4040               4307      MOVEM.l a1/d1,-(sp)         * save other regs
00B015BA  B9C8                    4308      CMPA.l  a0,a4               * is string on the descriptor stack
00B015BC  6602                    4309      BNE.s       LAB_22BD            * skip pop if not
00B015BE                          4310  
00B015BE  5C4C                    4311      ADDQ.w  #$06,a4         * else update stack pointer
00B015C0                          4312  LAB_22BD
00B015C0  7000                    4313      MOVEQ       #0,d0               * clear string length longword
00B015C2  2258                    4314      MOVEA.l (a0)+,a1            * get string address
00B015C4  3018                    4315      MOVE.w  (a0)+,d0            * get string length
00B015C6                          4316  
00B015C6  B9C8                    4317      CMPA.l  a0,a4               * was it on the descriptor stack
00B015C8  6610                    4318      BNE.s       LAB_22E6            * branch if it wasn't
00B015CA                          4319  
00B015CA  B3EB 04AA               4320      CMPA.l  Sstorl(a3),a1       * compare string address with bottom of string
00B015CE                          4321                              * space
00B015CE  660A                    4322      BNE.s       LAB_22E6            * branch if <>
00B015D0                          4323  
00B015D0  7201                    4324      MOVEQ       #1,d1               * mask for odd bit
00B015D2  C240                    4325      AND.w       d0,d1               * AND length
00B015D4  D280                    4326      ADD.l       d0,d1               * make it fit word aligned length
00B015D6                          4327  
00B015D6  D3AB 04AA               4328      ADD.l       d1,Sstorl(a3)       * add to bottom of string space
00B015DA                          4329  LAB_22E6
00B015DA  2049                    4330      MOVEA.l a1,a0               * copy to a0
00B015DC  4CDF 0202               4331      MOVEM.l (sp)+,a1/d1         * restore other regs
00B015E0  4A80                    4332      TST.l       d0              * set flags on length
00B015E2  4E75                    4333      RTS
00B015E4                          4334  
00B015E4                          4335  
00B015E4                          4336  *************************************************************************************
00B015E4                          4337  *
00B015E4                          4338  * perform CHR$()
00B015E4                          4339  
00B015E4                          4340  LAB_CHRS
00B015E4  6100 0130               4341      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00B015E8                          4342                              * Itemp
00B015E8                          4343  LAB_MKCHR
00B015E8  7201                    4344      MOVEQ       #1,d1               * string is single byte
00B015EA  6100 FE32               4345      BSR     LAB_2115            * make string space d1 bytes long
00B015EE                          4346                              * return a0/Sutill = pointer, others unchanged
00B015EE  1080                    4347      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00B015F0  6000 FE12               4348      BRA     LAB_RTST            * push string on descriptor stack
00B015F4                          4349                              * a0 = pointer, d1 = length
00B015F4                          4350  
00B015F4                          4351  
00B015F4                          4352  *************************************************************************************
00B015F4                          4353  *
00B015F4                          4354  * perform LEFT$()
00B015F4                          4355  
00B015F4                          4356  * enter with a0 is descriptor, d0 & Itemp is word 1
00B015F4                          4357  
00B015F4                          4358  LAB_LEFT
00B015F4  C141                    4359      EXG     d0,d1               * word in d1
00B015F6  6100 F79E               4360      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B015FA                          4361  
00B015FA  4A81                    4362      TST.l       d1              * test returned length
00B015FC  6722                    4363      BEQ.s       LAB_231C            * branch if null return
00B015FE                          4364  
00B015FE  7000                    4365      MOVEQ       #0,d0               * clear start offset
00B01600  B268 0004               4366      CMP.w       4(a0),d1            * compare word parameter with string length
00B01604  651A                    4367      BCS.s       LAB_231C            * branch if string length > word parameter
00B01606                          4368  
00B01606  6014                    4369      BRA.s       LAB_2317            * go copy whole string
00B01608                          4370  
00B01608                          4371  
00B01608                          4372  *************************************************************************************
00B01608                          4373  *
00B01608                          4374  * perform RIGHT$()
00B01608                          4375  
00B01608                          4376  * enter with a0 is descriptor, d0 & Itemp is word 1
00B01608                          4377  
00B01608                          4378  LAB_RIGHT
00B01608  C141                    4379      EXG     d0,d1               * word in d1
00B0160A  6100 F78A               4380      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B0160E                          4381  
00B0160E  4A81                    4382      TST.l       d1              * test returned length
00B01610  670E                    4383      BEQ.s       LAB_231C            * branch if null return
00B01612                          4384  
00B01612  3028 0004               4385      MOVE.w  4(a0),d0            * get string length
00B01616  9081                    4386      SUB.l       d1,d0               * subtract word
00B01618  6406                    4387      BCC.s       LAB_231C            * branch if string length > word parameter
00B0161A                          4388  
00B0161A                          4389                              * else copy whole string
00B0161A                          4390  LAB_2316
00B0161A  7000                    4391      MOVEQ       #0,d0               * clear start offset
00B0161C                          4392  LAB_2317
00B0161C  3228 0004               4393      MOVE.w  4(a0),d1            * else make parameter = length
00B01620                          4394  
00B01620                          4395  * get here with ...
00B01620                          4396  *   a0 - points to descriptor
00B01620                          4397  *   d0 - is offset from string start
00B01620                          4398  *   d1 - is required string length
00B01620                          4399  
00B01620                          4400  LAB_231C
00B01620  2248                    4401      MOVEA.l a0,a1               * save string descriptor pointer
00B01622  6100 FDFA               4402      BSR     LAB_2115            * make string space d1 bytes long
00B01626                          4403                              * return a0/Sutill = pointer, others unchanged
00B01626  2049                    4404      MOVEA.l a1,a0               * restore string descriptor pointer
00B01628  2F00                    4405      MOVE.l  d0,-(sp)            * save start offset (longword)
00B0162A  618A                    4406      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00B0162C                          4407                              * d0 = length, a0 = pointer
00B0162C  D1DF                    4408      ADDA.l  (sp)+,a0            * adjust pointer to start of wanted string
00B0162E  3001                    4409      MOVE.w  d1,d0               * length to d0
00B01630  6100 FF66               4410      BSR     LAB_229E            * store string d0 bytes long from (a0) to
00B01634                          4411                              * (Sutill) return with a0 = pointer,
00B01634                          4412                              * d1 = length
00B01634  6000 FDCE               4413      BRA     LAB_RTST            * push string on descriptor stack
00B01638                          4414                              * a0 = pointer, d1 = length
00B01638                          4415  
00B01638                          4416  
00B01638                          4417  *************************************************************************************
00B01638                          4418  *
00B01638                          4419  * perform MID$()
00B01638                          4420  
00B01638                          4421  * enter with a0 is descriptor, d0 & Itemp is word 1
00B01638                          4422  
00B01638                          4423  LAB_MIDS
00B01638  7E00                    4424      MOVEQ       #0,d7               * clear longword
00B0163A  5347                    4425      SUBQ.w  #1,d7               * set default length = 65535
00B0163C  2F00                    4426      MOVE.l  d0,-(sp)            * save word 1
00B0163E  6100 F76A               4427      BSR     LAB_GBYT            * scan memory
00B01642  B03C 002C               4428      CMP.b       #',',d0         * was it ","
00B01646  660C                    4429      BNE.s       LAB_2358            * branch if not "," (skip second byte get)
00B01648                          4430  
00B01648  101D                    4431      MOVE.b  (a5)+,d0            * increment pointer past ","
00B0164A  2F08                    4432      MOVE.l  a0,-(sp)            * save descriptor pointer
00B0164C  6100 00D8               4433      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00B01650  205F                    4434      MOVEA.l (sp)+,a0            * restore descriptor pointer
00B01652  2E00                    4435      MOVE.l  d0,d7               * copy length
00B01654                          4436  LAB_2358
00B01654  6100 F740               4437      BSR     LAB_1BFB            * scan for ")", else do syntax error then warm
00B01658                          4438                              * start
00B01658  201F                    4439      MOVE.l  (sp)+,d0            * restore word 1
00B0165A  7200                    4440      MOVEQ       #0,d1               * null length
00B0165C  5380                    4441      SUBQ.l  #1,d0               * decrement start index (word 1)
00B0165E  6B00 EAFE               4442      BMI     LAB_FCER            * if was null do function call error then warm
00B01662                          4443                              * start
00B01662                          4444  
00B01662  B068 0004               4445      CMP.w       4(a0),d0            * compare string length with start index
00B01666  64B8                    4446      BCC.s       LAB_231C            * if start not in string do null string (d1=0)
00B01668                          4447  
00B01668  2207                    4448      MOVE.l  d7,d1               * get length back
00B0166A  DE40                    4449      ADD.w       d0,d7               * d7 now = MID$() end
00B0166C  6506                    4450      BCS.s       LAB_2368            * already too long so do RIGHT$ equivalent
00B0166E                          4451  
00B0166E  BE68 0004               4452      CMP.w       4(a0),d7            * compare string length with start index+length
00B01672  65AC                    4453      BCS.s       LAB_231C            * if end in string go do string
00B01674                          4454  
00B01674                          4455  LAB_2368
00B01674  3228 0004               4456      MOVE.w  4(a0),d1            * get string length
00B01678  9240                    4457      SUB.w       d0,d1               * subtract start offset
00B0167A  60A4                    4458      BRA.s       LAB_231C            * go do string (effectively RIGHT$)
00B0167C                          4459  
00B0167C                          4460  
00B0167C                          4461  *************************************************************************************
00B0167C                          4462  *
00B0167C                          4463  * perform LCASE$()
00B0167C                          4464  
00B0167C                          4465  LAB_LCASE
00B0167C  6100 FF34               4466      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00B01680                          4467                              * returns with d0 = length, a0 = pointer
00B01680  2200                    4468      MOVE.l  d0,d1               * copy the string length
00B01682  6756                    4469      BEQ.s       NoString            * if null go return a null string
00B01684                          4470  
00B01684                          4471  * else copy and change the string
00B01684                          4472  
00B01684  2248                    4473      MOVEA.l a0,a1               * copy the string address
00B01686  6100 FD96               4474      BSR     LAB_2115            * make a string space d1 bytes long
00B0168A  D1C1                    4475      ADDA.l  d1,a0               * new string end
00B0168C  D3C1                    4476      ADDA.l  d1,a1               * old string end
00B0168E  3401                    4477      MOVE.w  d1,d2               * copy length for loop
00B01690  5342                    4478      SUBQ.w  #1,d2               * -1 for DBF loop
00B01692                          4479  LC_loop
00B01692  1021                    4480      MOVE.b  -(a1),d0            * get byte from string
00B01694                          4481  
00B01694  B03C 005B               4482      CMP.b       #$5B,d0         * compare with "Z"+1
00B01698  640A                    4483      BCC.s       NoUcase         * if > "Z" skip change
00B0169A                          4484  
00B0169A  B03C 0041               4485      CMP.b       #$41,d0         * compare with "A"
00B0169E  6504                    4486      BCS.s       NoUcase         * if < "A" skip change
00B016A0                          4487  
00B016A0  0000 0020               4488      ORI.b       #$20,d0         * convert upper case to lower case
00B016A4                          4489  NoUcase
00B016A4  1100                    4490      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00B016A6  51CA FFEA               4491      DBF     d2,LC_loop          * decrement and loop if not all done
00B016AA                          4492  
00B016AA  602E                    4493      BRA.s       NoString            * tidy up & exit (branch always)
00B016AC                          4494  
00B016AC                          4495  
00B016AC                          4496  *************************************************************************************
00B016AC                          4497  *
00B016AC                          4498  * perform UCASE$()
00B016AC                          4499  
00B016AC                          4500  LAB_UCASE
00B016AC  6100 FF04               4501      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00B016B0                          4502                              * returns with d0 = length, a0 = pointer
00B016B0  2200                    4503      MOVE.l  d0,d1               * copy the string length
00B016B2  6726                    4504      BEQ.s       NoString            * if null go return a null string
00B016B4                          4505  
00B016B4                          4506  * else copy and change the string
00B016B4                          4507  
00B016B4  2248                    4508      MOVEA.l a0,a1               * copy the string address
00B016B6  6100 FD66               4509      BSR     LAB_2115            * make a string space d1 bytes long
00B016BA  D1C1                    4510      ADDA.l  d1,a0               * new string end
00B016BC  D3C1                    4511      ADDA.l  d1,a1               * old string end
00B016BE  3401                    4512      MOVE.w  d1,d2               * copy length for loop
00B016C0  5342                    4513      SUBQ.w  #1,d2               * -1 for DBF loop
00B016C2                          4514  UC_loop
00B016C2  1021                    4515      MOVE.b  -(a1),d0            * get a byte from the string
00B016C4                          4516  
00B016C4  B03C 0061               4517      CMP.b       #$61,d0         * compare with "a"
00B016C8  650A                    4518      BCS.s       NoLcase         * if < "a" skip change
00B016CA                          4519  
00B016CA  B03C 007B               4520      CMP.b       #$7B,d0         * compare with "z"+1
00B016CE  6404                    4521      BCC.s       NoLcase         * if > "z" skip change
00B016D0                          4522  
00B016D0  0200 00DF               4523      ANDI.b  #$DF,d0         * convert lower case to upper case
00B016D4                          4524  NoLcase
00B016D4  1100                    4525      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00B016D6  51CA FFEA               4526      DBF     d2,UC_loop          * decrement and loop if not all done
00B016DA                          4527  
00B016DA                          4528  NoString
00B016DA  6000 FD28               4529      BRA     LAB_RTST            * push string on descriptor stack
00B016DE                          4530                              * a0 = pointer, d1 = length
00B016DE                          4531  
00B016DE                          4532  
00B016DE                          4533  *************************************************************************************
00B016DE                          4534  *
00B016DE                          4535  * perform SADD()
00B016DE                          4536  
00B016DE                          4537  LAB_SADD
00B016DE  101D                    4538      MOVE.b  (a5)+,d0            * increment pointer
00B016E0  6100 F8D6               4539      BSR     LAB_GVAR            * get variable address in a0
00B016E4  6100 F6B0               4540      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B016E8  4A2B 0619               4541      TST.b       Dtypef(a3)          * test data type flag
00B016EC  6A00 EA50               4542      BPL     LAB_TMER            * if numeric do Type missmatch Error
00B016F0                          4543  
00B016F0                          4544  * if you want a non existant variable to return a null value then set the novar
00B016F0                          4545  * value at the top of this file to some non zero value
00B016F0                          4546  
00B016F0                 FALSE    4547   ifne   novar
00B016F0                          4548   endc
00B016F0                          4549  
00B016F0  2010                    4550      MOVE.l  (a0),d0         * get string address
00B016F2  6000 FBB4               4551      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B016F6                          4552  
00B016F6                          4553  
00B016F6                          4554  *************************************************************************************
00B016F6                          4555  *
00B016F6                          4556  * perform LEN()
00B016F6                          4557  
00B016F6                          4558  LAB_LENS
00B016F6  487A FBB0               4559      PEA     LAB_AYFC(pc)        * set return address to convert d0 to signed
00B016FA                          4560                              * longword in FAC1
00B016FA  6000 FEB6               4561      BRA     LAB_22B6            * pop string off descriptor stack or from memory
00B016FE                          4562                              * returns with d0 = length, a0 = pointer
00B016FE                          4563  
00B016FE                          4564  
00B016FE                          4565  *************************************************************************************
00B016FE                          4566  *
00B016FE                          4567  * perform ASC()
00B016FE                          4568  
00B016FE                          4569  LAB_ASC
00B016FE  6100 FEB2               4570      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00B01702                          4571                              * returns with d0 = length, a0 = pointer
00B01702  4A40                    4572      TST.w       d0              * test length
00B01704  6700 EA58               4573      BEQ     LAB_FCER            * if null do function call error then warm start
00B01708                          4574  
00B01708  1010                    4575      MOVE.b  (a0),d0         * get first character byte
00B0170A  6000 FBBC               4576      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00B0170E                          4577  
00B0170E                          4578  
00B0170E                          4579  *************************************************************************************
00B0170E                          4580  *
00B0170E                          4581  * increment and get byte, result in d0 and Itemp
00B0170E                          4582  
00B0170E                          4583  LAB_SGBY
00B0170E  6100 F698               4584      BSR     LAB_IGBY            * increment & scan memory
00B01712                          4585  
00B01712                          4586  
00B01712                          4587  *************************************************************************************
00B01712                          4588  *
00B01712                          4589  * get byte parameter, result in d0 and Itemp
00B01712                          4590  
00B01712                          4591  LAB_GTBY
00B01712  6100 F51C               4592      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B01716                          4593                              * else do type mismatch
00B01716                          4594  
00B01716                          4595  
00B01716                          4596  *************************************************************************************
00B01716                          4597  *
00B01716                          4598  * evaluate byte expression, result in d0 and Itemp
00B01716                          4599  
00B01716                          4600  LAB_EVBY
00B01716  6100 F9D4               4601      BSR     LAB_EVPI            * evaluate positive integer expression
00B0171A                          4602                              * result in d0 and Itemp
00B0171A  7280                    4603      MOVEQ       #$80,d1         * set mask/2
00B0171C  D281                    4604      ADD.l       d1,d1               * =$FFFFFF00
00B0171E  C280                    4605      AND.l       d0,d1               * check top 24 bits
00B01720  6600 EA3C               4606      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00B01724                          4607  
00B01724  4E75                    4608      RTS
00B01726                          4609  
00B01726                          4610  
00B01726                          4611  *************************************************************************************
00B01726                          4612  *
00B01726                          4613  * get word parameter, result in d0 and Itemp
00B01726                          4614  
00B01726                          4615  LAB_GTWO
00B01726  6100 F508               4616      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B0172A                          4617                              * else do type mismatch
00B0172A  6100 F9C0               4618      BSR     LAB_EVPI            * evaluate positive integer expression
00B0172E                          4619                              * result in d0 and Itemp
00B0172E  4840                    4620      SWAP        d0              * copy high word to low word
00B01730  4A40                    4621      TST.w       d0              * set flags
00B01732  6600 EA2A               4622      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00B01736                          4623  
00B01736  4840                    4624      SWAP        d0              * copy high word to low word
00B01738  4E75                    4625      RTS
00B0173A                          4626  
00B0173A                          4627  
00B0173A                          4628  *************************************************************************************
00B0173A                          4629  *
00B0173A                          4630  * perform VAL()
00B0173A                          4631  
00B0173A                          4632  LAB_VAL
00B0173A  6100 FE76               4633      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00B0173E                          4634                              * returns with d0 = length, a0 = pointer
00B0173E  6722                    4635      BEQ.s       LAB_VALZ            * string was null so set result = $00
00B01740                          4636                              * clear FAC1 exponent & sign & return
00B01740                          4637  
00B01740  2C4D                    4638      MOVEA.l a5,a6               * save BASIC execute pointer
00B01742  2A48                    4639      MOVEA.l a0,a5               * copy string pointer to execute pointer
00B01744  D1C0                    4640      ADDA.l  d0,a0               * string end+1
00B01746  1010                    4641      MOVE.b  (a0),d0         * get byte from string+1
00B01748  3F00                    4642      MOVE.w  d0,-(sp)            * save it
00B0174A  2F08                    4643      MOVE.l  a0,-(sp)            * save address
00B0174C  10BC 0000               4644      MOVE.b  #0,(a0)         * null terminate string
00B01750  6100 F658               4645      BSR     LAB_GBYT            * scan memory
00B01754  6100 1142               4646      BSR     LAB_2887            * get FAC1 from string
00B01758  205F                    4647      MOVEA.l (sp)+,a0            * restore pointer
00B0175A  301F                    4648      MOVE.w  (sp)+,d0            * pop byte
00B0175C  1080                    4649      MOVE.b  d0,(a0)         * restore to memory
00B0175E  2A4E                    4650      MOVEA.l a6,a5               * restore BASIC execute pointer
00B01760  4E75                    4651      RTS
00B01762                          4652  
00B01762                          4653  LAB_VALZ
00B01762  3740 05F8               4654      MOVE.w  d0,FAC1_e(a3)       * clear FAC1 exponent & sign
00B01766  4E75                    4655      RTS
00B01768                          4656  
00B01768                          4657  
00B01768                          4658  *************************************************************************************
00B01768                          4659  *
00B01768                          4660  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00B01768                          4661  
00B01768                          4662  LAB_GADB
00B01768  6100 F4C6               4663      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B0176C                          4664                              * else do type mismatch
00B0176C  6100 F986               4665      BSR     LAB_EVIR            * evaluate integer expression
00B01770                          4666                              * (does FC error not OF error if out of range)
00B01770  2F00                    4667      MOVE.l  d0,-(sp)            * copy to stack
00B01772  6100 F62A               4668      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00B01776  619A                    4669      BSR.s       LAB_GTBY            * get byte parameter, result in d0 and Itemp
00B01778  205F                    4670      MOVEA.l (sp)+,a0            * pull address
00B0177A  4E75                    4671      RTS
00B0177C                          4672  
00B0177C                          4673  
00B0177C                          4674  *************************************************************************************
00B0177C                          4675  *
00B0177C                          4676  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00B0177C                          4677  
00B0177C                          4678  LAB_GADW
00B0177C  611E                    4679      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00B0177E                          4680                              * address returned in d0 and on the stack
00B0177E  6100 F61E               4681      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00B01782  6100 F4AC               4682      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B01786                          4683                              * else do type mismatch
00B01786  6100 F96C               4684      BSR     LAB_EVIR            * evaluate integer expression
00B0178A                          4685                              * result in d0 and Itemp
00B0178A  4840                    4686      SWAP        d0              * swap words
00B0178C  4A40                    4687      TST.w       d0              * test high word
00B0178E  6706                    4688      BEQ.s       LAB_XGADW           * exit if null
00B01790                          4689  
00B01790  5240                    4690      ADDQ.w  #1,d0               * increment word
00B01792  6600 E9CA               4691      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00B01796                          4692  
00B01796                          4693  LAB_XGADW
00B01796  4840                    4694      SWAP        d0              * swap words back
00B01798  205F                    4695      MOVEA.l (sp)+,a0            * pull address
00B0179A  4E75                    4696      RTS
00B0179C                          4697  
00B0179C                          4698  
00B0179C                          4699  *************************************************************************************
00B0179C                          4700  *
00B0179C                          4701  * get even address (for word or longword memory actions)
00B0179C                          4702  * address returned in d0 and on the stack
00B0179C                          4703  * does address error if the address is odd
00B0179C                          4704  
00B0179C                          4705  LAB_GEAD
00B0179C  6100 F492               4706      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B017A0                          4707                              * else do type mismatch
00B017A0  6100 F952               4708      BSR     LAB_EVIR            * evaluate integer expression
00B017A4                          4709                              * (does FC error not OF error if out of range)
00B017A4  0800 0000               4710      BTST        #0,d0               * test low bit of longword
00B017A8  6600 E970               4711      BNE     LAB_ADER            * if address is odd do address error/warm start
00B017AC                          4712  
00B017AC  2057                    4713      MOVEA.l (sp),a0         * copy return address
00B017AE  2E80                    4714      MOVE.l  d0,(sp)         * even address on stack
00B017B0  4ED0                    4715      JMP     (a0)                * effectively RTS
00B017B2                          4716  
00B017B2                          4717  
00B017B2                          4718  *************************************************************************************
00B017B2                          4719  *
00B017B2                          4720  * perform PEEK()
00B017B2                          4721  
00B017B2                          4722  LAB_PEEK
00B017B2  6100 F940               4723      BSR     LAB_EVIR            * evaluate integer expression
00B017B6                          4724                              * (does FC error not OF error if out of range)
00B017B6  2040                    4725      MOVEA.l d0,a0               * copy to address register
00B017B8  1010                    4726      MOVE.b  (a0),d0         * get byte
00B017BA  6000 FB0C               4727      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00B017BE                          4728  
00B017BE                          4729  
00B017BE                          4730  *************************************************************************************
00B017BE                          4731  *
00B017BE                          4732  * perform POKE
00B017BE                          4733  
00B017BE                          4734  LAB_POKE
00B017BE  61A8                    4735      BSR.s       LAB_GADB            * get two parameters for POKE or WAIT
00B017C0                          4736                              * first parameter in a0, second in d0
00B017C0  1080                    4737      MOVE.b  d0,(a0)         * put byte in memory
00B017C2  4E75                    4738      RTS
00B017C4                          4739  
00B017C4                          4740  
00B017C4                          4741  *************************************************************************************
00B017C4                          4742  *
00B017C4                          4743  * perform DEEK()
00B017C4                          4744  
00B017C4                          4745  LAB_DEEK
00B017C4  6100 F92E               4746      BSR     LAB_EVIR            * evaluate integer expression
00B017C8                          4747                              * (does FC error not OF error if out of range)
00B017C8  E208                    4748      LSR.b       #1,d0               * shift bit 0 to carry
00B017CA  6500 E94E               4749      BCS     LAB_ADER            * if address is odd do address error/warm start
00B017CE                          4750  
00B017CE  D000                    4751      ADD.b       d0,d0               * shift byte back
00B017D0  C188                    4752      EXG     d0,a0               * copy to address register
00B017D2  7000                    4753      MOVEQ       #0,d0               * clear top bits
00B017D4  3010                    4754      MOVE.w  (a0),d0         * get word
00B017D6  6000 FAD0               4755      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B017DA                          4756  
00B017DA                          4757  
00B017DA                          4758  *************************************************************************************
00B017DA                          4759  *
00B017DA                          4760  * perform LEEK()
00B017DA                          4761  
00B017DA                          4762  LAB_LEEK
00B017DA  6100 F918               4763      BSR     LAB_EVIR            * evaluate integer expression
00B017DE                          4764                              * (does FC error not OF error if out of range)
00B017DE  E208                    4765      LSR.b       #1,d0               * shift bit 0 to carry
00B017E0  6500 E938               4766      BCS     LAB_ADER            * if address is odd do address error/warm start
00B017E4                          4767  
00B017E4  D000                    4768      ADD.b       d0,d0               * shift byte back
00B017E6  C188                    4769      EXG     d0,a0               * copy to address register
00B017E8  2010                    4770      MOVE.l  (a0),d0         * get longword
00B017EA  6000 FABC               4771      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B017EE                          4772  
00B017EE                          4773  
00B017EE                          4774  *************************************************************************************
00B017EE                          4775  *
00B017EE                          4776  * perform DOKE
00B017EE                          4777  
00B017EE                          4778  LAB_DOKE
00B017EE  618C                    4779      BSR.s       LAB_GADW            * get two parameters for DOKE or WAIT
00B017F0                          4780                              * first parameter in a0, second in d0
00B017F0  3080                    4781      MOVE.w  d0,(a0)         * put word in memory
00B017F2  4E75                    4782      RTS
00B017F4                          4783  
00B017F4                          4784  
00B017F4                          4785  *************************************************************************************
00B017F4                          4786  *
00B017F4                          4787  * perform LOKE
00B017F4                          4788  
00B017F4                          4789  LAB_LOKE
00B017F4  61A6                    4790      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00B017F6                          4791                              * address returned in d0 and on the stack
00B017F6  6100 F5A6               4792      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00B017FA  6100 F434               4793      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00B017FE                          4794                              * else do type mismatch
00B017FE  6100 F8F4               4795      BSR     LAB_EVIR            * evaluate integer value (no sign check)
00B01802  205F                    4796      MOVEA.l (sp)+,a0            * pull address
00B01804  2080                    4797      MOVE.l  d0,(a0)         * put longword in memory
00B01806                          4798  RTS_015
00B01806  4E75                    4799      RTS
00B01808                          4800  
00B01808                          4801  
00B01808                          4802  *************************************************************************************
00B01808                          4803  *
00B01808                          4804  * perform SWAP
00B01808                          4805  
00B01808                          4806  LAB_SWAP
00B01808  6100 F7AE               4807      BSR     LAB_GVAR            * get variable 1 address in a0
00B0180C  2F08                    4808      MOVE.l  a0,-(sp)            * save variable 1 address
00B0180E  182B 0619               4809      MOVE.b  Dtypef(a3),d4       * copy variable 1 data type, $80=string,
00B01812                          4810                              * $40=inetger, $00=float
00B01812                          4811  
00B01812  6100 F58A               4812      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00B01816  6100 F7A0               4813      BSR     LAB_GVAR            * get variable 2 address in a0
00B0181A  245F                    4814      MOVEA.l (sp)+,a2            * restore variable 1 address
00B0181C  B82B 0619               4815      CMP.b       Dtypef(a3),d4       * compare variable 1 data type with variable 2
00B01820                          4816                              * data type
00B01820  6600 E91C               4817      BNE     LAB_TMER            * if not both the same type do "Type mismatch"
00B01824                          4818                              * error then warm start
00B01824                          4819  
00B01824                          4820  * if you do want a non existant variable to return an error then leave the novar
00B01824                          4821  * value at the top of this file set to zero
00B01824                          4822  
00B01824                 TRUE     4823   ifeq   novar
00B01824                          4824  
00B01824  2010                    4825      MOVE.l  (a0),d0         * get variable 2
00B01826  20D2                    4826      MOVE.l  (a2),(a0)+          * copy variable 1 to variable 2
00B01828  24C0                    4827      MOVE.l  d0,(a2)+            * save variable 2 to variable 1
00B0182A                          4828  
00B0182A  4A04                    4829      TST.b       d4              * check data type
00B0182C  6AD8                    4830      BPL.s       RTS_015         * exit if not string
00B0182E                          4831  
00B0182E  3010                    4832      MOVE.w  (a0),d0         * get string 2 length
00B01830  3092                    4833      MOVE.w  (a2),(a0)           * copy string 1 length to string 2 length
00B01832  3480                    4834      MOVE.w  d0,(a2)         * save string 2 length to string 1 length
00B01834                          4835  
00B01834                          4836   endc
00B01834                          4837  
00B01834                          4838  
00B01834                          4839  * if you want a non existant variable to return a null value then set the novar
00B01834                          4840  * value at the top of this file to some non zero value
00B01834                          4841  
00B01834                 FALSE    4842   ifne   novar
00B01834                          4843                              * value get
00B01834                          4844                              * value get and the new value save
00B01834                          4845                              * new length save
00B01834                          4846                              * new value save
00B01834                          4847   endc
00B01834                          4848  
00B01834  4E75                    4849      RTS
00B01836                          4850  
00B01836                          4851  
00B01836                          4852  *************************************************************************************
00B01836                          4853  *
00B01836                          4854  * perform USR
00B01836                          4855  
00B01836                          4856  LAB_USR
00B01836  4EAB 046A               4857      JSR     Usrjmp(a3)          * do user vector
00B0183A  6000 F55A               4858      BRA     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B0183E                          4859  
00B0183E                          4860  
00B0183E                          4861  *************************************************************************************
00B0183E                          4862  *
00B0183E                          4863  * perform LOAD
00B0183E                          4864  
00B0183E                          4865  LAB_LOAD
00B0183E  4EEB 047C               4866      JMP     V_LOAD(a3)          * do load vector
00B01842                          4867  
00B01842                          4868  
00B01842                          4869  *************************************************************************************
00B01842                          4870  *
00B01842                          4871  * perform SAVE
00B01842                          4872  
00B01842                          4873  LAB_SAVE
00B01842  4EEB 0482               4874      JMP     V_SAVE(a3)          * do save vector
00B01846                          4875  
00B01846                          4876  
00B01846                          4877  *************************************************************************************
00B01846                          4878  *
00B01846                          4879  * perform CALL
00B01846                          4880  
00B01846                          4881  LAB_CALL
00B01846  487A F562               4882      PEA     LAB_GBYT(pc)        * put return address on stack
00B0184A  6100 FF50               4883      BSR     LAB_GEAD            * get even address for word/long memory actions
00B0184E                          4884                              * address returned in d0 and on the stack
00B0184E  4E75                    4885      RTS                     * effectively calls the routine
00B01850                          4886  
00B01850                          4887  * if the called routine exits correctly then it will return via the get byte routine.
00B01850                          4888  * this will then get the next byte for the interpreter and return
00B01850                          4889  
00B01850                          4890  
00B01850                          4891  *************************************************************************************
00B01850                          4892  *
00B01850                          4893  * perform WAIT
00B01850                          4894  
00B01850                          4895  LAB_WAIT
00B01850  6100 FF16               4896      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00B01854                          4897                              * first parameter in a0, second in d0
00B01854  2F08                    4898      MOVE.l  a0,-(sp)            * save address
00B01856  3F00                    4899      MOVE.w  d0,-(sp)            * save byte
00B01858  7400                    4900      MOVEQ       #0,d2               * clear mask
00B0185A  6100 F54E               4901      BSR     LAB_GBYT            * scan memory
00B0185E  6706                    4902      BEQ.s       LAB_2441            * skip if no third argument
00B01860                          4903  
00B01860  6100 F538               4904      BSR     LAB_SCGB            * scan for "," & get byte,
00B01864                          4905                              * else do syntax error/warm start
00B01864  2400                    4906      MOVE.l  d0,d2               * copy mask
00B01866                          4907  LAB_2441
00B01866  321F                    4908      MOVE.w  (sp)+,d1            * get byte
00B01868  205F                    4909      MOVEA.l (sp)+,a0            * get address
00B0186A                          4910  LAB_2445
00B0186A  1010                    4911      MOVE.b  (a0),d0         * read memory byte
00B0186C  B500                    4912      EOR.b       d2,d0               * EOR with second argument (mask)
00B0186E  C001                    4913      AND.b       d1,d0               * AND with first argument (byte)
00B01870  67F8                    4914      BEQ.s       LAB_2445            * loop if result is zero
00B01872                          4915  
00B01872  4E75                    4916      RTS
00B01874                          4917  
00B01874                          4918  
00B01874                          4919  *************************************************************************************
00B01874                          4920  *
00B01874                          4921  * perform subtraction, FAC1 from FAC2
00B01874                          4922  
00B01874                          4923  LAB_SUBTRACT
00B01874  0A2B 0080 05F9          4924      EORI.b  #$80,FAC1_s(a3)     * complement FAC1 sign
00B0187A  176B 0601 0602          4925      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign byte
00B01880                          4926  
00B01880  102B 05F9               4927      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign byte
00B01884  B12B 0602               4928      EOR.b       d0,FAC_sc(a3)       * EOR with FAC2 sign
00B01888                          4929  
00B01888                          4930  
00B01888                          4931  *************************************************************************************
00B01888                          4932  *
00B01888                          4933  * add FAC2 to FAC1
00B01888                          4934  
00B01888                          4935  LAB_ADD
00B01888  102B 05F8               4936      MOVE.b  FAC1_e(a3),d0       * get exponent
00B0188C  6700 0338               4937      BEQ     LAB_279B            * FAC1 was zero so copy FAC2 to FAC1 & return
00B01890                          4938  
00B01890                          4939                              * FAC1 is non zero
00B01890  41EB 05FC               4940      LEA     FAC2_m(a3),a0       * set pointer1 to FAC2 mantissa
00B01894  102B 0600               4941      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00B01898  6746                    4942      BEQ.s       RTS_016         * exit if zero
00B0189A                          4943  
00B0189A  902B 05F8               4944      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00B0189E  6722                    4945      BEQ.s       LAB_24A8            * branch if = (go add mantissa)
00B018A0                          4946  
00B018A0  650A                    4947      BCS.s       LAB_249C            * branch if FAC2 < FAC1
00B018A2                          4948  
00B018A2                          4949                              * FAC2 > FAC1
00B018A2  376B 0600 05F8          4950      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy sign and exponent of FAC2
00B018A8  4400                    4951      NEG.b       d0              * negate exponent difference (make diff -ve)
00B018AA  5148                    4952      SUBQ.w  #8,a0               * pointer1 to FAC1
00B018AC                          4953  
00B018AC                          4954  LAB_249C
00B018AC  4400                    4955      NEG.b       d0              * negate exponent difference (make diff +ve)
00B018AE  2F01                    4956      MOVE.l  d1,-(sp)            * save d1
00B018B0  B03C 0020               4957      CMP.b       #32,d0          * compare exponent diff with 32
00B018B4  6D04                    4958      BLT.s       LAB_2467            * branch if range >= 32
00B018B6                          4959  
00B018B6  7200                    4960      MOVEQ       #0,d1               * clear d1
00B018B8  6004                    4961      BRA.s       LAB_2468            * go clear smaller mantissa
00B018BA                          4962  
00B018BA                          4963  LAB_2467
00B018BA  2210                    4964      MOVE.l  (a0),d1         * get FACx mantissa
00B018BC  E0A9                    4965      LSR.l       d0,d1               * shift d0 times right
00B018BE                          4966  LAB_2468
00B018BE  2081                    4967      MOVE.l  d1,(a0)         * save it back
00B018C0  221F                    4968      MOVE.l  (sp)+,d1            * restore d1
00B018C2                          4969  
00B018C2                          4970                              * exponents are equal now do mantissa add or
00B018C2                          4971                              * subtract
00B018C2                          4972  LAB_24A8
00B018C2  4A2B 0602               4973      TST.b       FAC_sc(a3)          * test sign compare (FAC1 EOR FAC2)
00B018C6  6B1A                    4974      BMI.s       LAB_24F8            * if <> go do subtract
00B018C8                          4975  
00B018C8  202B 05FC               4976      MOVE.l  FAC2_m(a3),d0       * get FAC2 mantissa
00B018CC  D0AB 05F4               4977      ADD.l       FAC1_m(a3),d0       * add FAC1 mantissa
00B018D0  640A                    4978      BCC.s       LAB_24F7            * save and exit if no carry (FAC1 is normal)
00B018D2                          4979  
00B018D2  E290                    4980      ROXR.l  #1,d0               * else shift carry back into mantissa
00B018D4  522B 05F8               4981      ADDQ.b  #1,FAC1_e(a3)       * increment FAC1 exponent
00B018D8  6500 E880               4982      BCS     LAB_OFER            * if carry do overflow error & warm start
00B018DC                          4983  
00B018DC                          4984  LAB_24F7
00B018DC  2740 05F4               4985      MOVE.l  d0,FAC1_m(a3)       * save mantissa
00B018E0                          4986  RTS_016
00B018E0  4E75                    4987      RTS
00B018E2                          4988                              * signs are different
00B018E2                          4989  LAB_24F8
00B018E2  43EB 05F4               4990      LEA     FAC1_m(a3),a1       * pointer 2 to FAC1
00B018E6  B3C8                    4991      CMPA.l  a0,a1               * compare pointers
00B018E8  6602                    4992      BNE.s       LAB_24B4            * branch if <>
00B018EA                          4993  
00B018EA  5049                    4994      ADDQ.w  #8,a1               * else pointer2 to FAC2
00B018EC                          4995  
00B018EC                          4996                              * take smaller from bigger (take sign of bigger)
00B018EC                          4997  LAB_24B4
00B018EC  2011                    4998      MOVE.l  (a1),d0         * get larger mantissa
00B018EE  2210                    4999      MOVE.l  (a0),d1         * get smaller mantissa
00B018F0  2740 05F4               5000      MOVE.l  d0,FAC1_m(a3)       * save larger mantissa
00B018F4  93AB 05F4               5001      SUB.l       d1,FAC1_m(a3)       * subtract smaller
00B018F8                          5002  
00B018F8                          5003  
00B018F8                          5004  *************************************************************************************
00B018F8                          5005  *
00B018F8                          5006  * do +/- (carry is sign) & normalise FAC1
00B018F8                          5007  
00B018F8                          5008  LAB_24D0
00B018F8  640A                    5009      BCC.s       LAB_24D5            * branch if result is +ve
00B018FA                          5010  
00B018FA                          5011                              * erk! subtract is the wrong way round so
00B018FA                          5012                              * negate everything
00B018FA  0A2B 00FF 05F9          5013      EORI.b  #$FF,FAC1_s(a3)     * complement FAC1 sign
00B01900  44AB 05F4               5014      NEG.l       FAC1_m(a3)          * negate FAC1 mantissa
00B01904                          5015  
00B01904                          5016  
00B01904                          5017  *************************************************************************************
00B01904                          5018  *
00B01904                          5019  * normalise FAC1
00B01904                          5020  
00B01904                          5021  LAB_24D5
00B01904  202B 05F4               5022      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B01908  6B2E                    5023      BMI.s       LAB_24DA            * mantissa is normal so just exit
00B0190A                          5024  
00B0190A  6606                    5025      BNE.s       LAB_24D9            * mantissa is not zero so go normalise FAC1
00B0190C                          5026  
00B0190C  3740 05F8               5027      MOVE.w  d0,FAC1_e(a3)       * else make FAC1 = +zero
00B01910  4E75                    5028      RTS
00B01912                          5029  
00B01912                          5030  LAB_24D9
00B01912  2F01                    5031      MOVE.l  d1,-(sp)            * save d1
00B01914  2200                    5032      MOVE.l  d0,d1               * mantissa to d1
00B01916  7000                    5033      MOVEQ       #0,d0               * clear d0
00B01918  102B 05F8               5034      MOVE.b  FAC1_e(a3),d0       * get exponent byte
00B0191C  6714                    5035      BEQ.s       LAB_24D8            * if exponent is zero then clean up and exit
00B0191E                          5036  LAB_24D6
00B0191E  D281                    5037      ADD.l       d1,d1               * shift mantissa, ADD is quicker for a single
00B01920                          5038                              * shift
00B01920  5BC8 FFFC               5039      DBMI        d0,LAB_24D6         * decrement exponent and loop if mantissa and
00B01924                          5040                              * exponent +ve
00B01924                          5041  
00B01924  4A40                    5042      TST.w       d0              * test exponent
00B01926  670A                    5043      BEQ.s       LAB_24D8            * if exponent is zero make FAC1 zero
00B01928                          5044  
00B01928  6A02                    5045      BPL.s       LAB_24D7            * if exponent is >zero go save FAC1
00B0192A                          5046  
00B0192A  7001                    5047      MOVEQ       #1,d0               * else set for zero after correction
00B0192C                          5048  LAB_24D7
00B0192C  5300                    5049      SUBQ.b  #1,d0               * adjust exponent for loop
00B0192E  2741 05F4               5050      MOVE.l  d1,FAC1_m(a3)       * save normalised mantissa
00B01932                          5051  LAB_24D8
00B01932  221F                    5052      MOVE.l  (sp)+,d1            * restore d1
00B01934  1740 05F8               5053      MOVE.b  d0,FAC1_e(a3)       * save corrected exponent
00B01938                          5054  LAB_24DA
00B01938  4E75                    5055      RTS
00B0193A                          5056  
00B0193A                          5057  
00B0193A                          5058  *************************************************************************************
00B0193A                          5059  *
00B0193A                          5060  * perform LOG()
00B0193A                          5061  
00B0193A                          5062  LAB_LOG
00B0193A  4A2B 05F9               5063      TST.b       FAC1_s(a3)          * test sign
00B0193E  6B00 E81E               5064      BMI     LAB_FCER            * if -ve do function call error/warm start
00B01942                          5065  
00B01942  7E00                    5066      MOVEQ       #0,d7               * clear d7
00B01944  1747 0602               5067      MOVE.b  d7,FAC_sc(a3)       * clear sign compare
00B01948  1E2B 05F8               5068      MOVE.b  FAC1_e(a3),d7       * get exponent
00B0194C  6700 E810               5069      BEQ     LAB_FCER            * if 0 do function call error/warm start
00B01950                          5070  
00B01950  0487 00000081           5071      SUB.l       #$81,d7         * normalise exponent
00B01956  177C 0081 05F8          5072      MOVE.b  #$81,FAC1_e(a3)     * force a value between 1 and 2
00B0195C  2C2B 05F4               5073      MOVE.l  FAC1_m(a3),d6       * copy mantissa
00B01960                          5074  
00B01960  277C 80000000 05FC      5075      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00B01968  377C 8100 0600          5076      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00B0196E  6100 FF18               5077      BSR     LAB_ADD         * find arg+1
00B01972  7000                    5078      MOVEQ       #0,d0               * setup for calc skip
00B01974  3740 0600               5079      MOVE.w  d0,FAC2_e(a3)       * set FAC1 for zero result
00B01978  DC86                    5080      ADD.l       d6,d6               * shift 1 bit out
00B0197A  2746 05FC               5081      MOVE.l  d6,FAC2_m(a3)       * put back FAC2
00B0197E  6758                    5082      BEQ.s       LAB_LONN            * if 0 skip calculation
00B01980                          5083  
00B01980  377C 8000 0600          5084      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for .5
00B01986  6100 0130               5085      BSR     LAB_DIVIDE          * do (arg-1)/(arg+1)
00B0198A  4A2B 05F8               5086      TST.b       FAC1_e(a3)          * test exponent
00B0198E  6748                    5087      BEQ.s       LAB_LONN            * if 0 skip calculation
00B01990                          5088  
00B01990  122B 05F8               5089      MOVE.b  FAC1_e(a3),d1       * get exponent
00B01994  0401 0082               5090      SUB.b       #$82,d1         * normalise and two integer bits
00B01998  4401                    5091      NEG.b       d1              * negate for shift
00B0199A                          5092  **  CMP.b       #$1F,d1         * will mantissa vanish?
00B0199A                          5093  **  BGT.s       LAB_dunno           * if so do ???
00B0199A                          5094  
00B0199A  202B 05F4               5095      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B0199E  E2A8                    5096      LSR.l       d1,d0               * shift in two integer bits
00B019A0                          5097  
00B019A0                          5098  * d0 = arg
00B019A0                          5099  * d0 = x, d1 = y
00B019A0                          5100  * d2 = x1, d3 = y1
00B019A0                          5101  * d4 = shift count
00B019A0                          5102  * d5 = loop count
00B019A0                          5103  * d6 = z
00B019A0                          5104  * a0 = table pointer
00B019A0                          5105  
00B019A0  7C00                    5106      MOVEQ       #0,d6               * z = 0
00B019A2  223C 40000000           5107      MOVE.l  #1<<30,d1           * y = 1
00B019A8  41FA 13FE               5108      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic tangent table
00B019AC  7A1E                    5109      MOVEQ       #30,d5          * loop 31 times
00B019AE  7801                    5110      MOVEQ       #1,d4               * set shift count
00B019B0  6006                    5111      BRA.s       LAB_LOCC            * entry point for loop
00B019B2                          5112  
00B019B2                          5113  LAB_LAAD
00B019B2  E8A2                    5114      ASR.l       d4,d2               * x1 >> i
00B019B4  9282                    5115      SUB.l       d2,d1               * y = y - x1
00B019B6  DC90                    5116      ADD.l       (a0),d6         * z = z + tanh(i)
00B019B8                          5117  LAB_LOCC
00B019B8  2400                    5118      MOVE.l  d0,d2               * x1 = x
00B019BA  2601                    5119      MOVE.l  d1,d3               * y1 = Y
00B019BC  E8A3                    5120      ASR.l       d4,d3               * y1 >> i
00B019BE  6402                    5121      BCC.s       LAB_LOLP
00B019C0                          5122  
00B019C0  5283                    5123      ADDQ.l  #1,d3
00B019C2                          5124  LAB_LOLP
00B019C2  9083                    5125      SUB.l       d3,d0               * x = x - y1
00B019C4  6AEC                    5126      BPL.s       LAB_LAAD            * branch if > 0
00B019C6                          5127  
00B019C6  2002                    5128      MOVE.l  d2,d0               * get x back
00B019C8  5848                    5129      ADDQ.w  #4,a0               * next entry
00B019CA  5284                    5130      ADDQ.l  #1,d4               * next i
00B019CC  E28B                    5131      LSR.l       #1,d3               * /2
00B019CE  6704                    5132      BEQ.s       LAB_LOCX            * branch y1 = 0
00B019D0                          5133  
00B019D0  51CD FFF0               5134      DBF     d5,LAB_LOLP         * decrement and loop if not done
00B019D4                          5135  
00B019D4                          5136                              * now sort out the result
00B019D4                          5137  LAB_LOCX
00B019D4  DC86                    5138      ADD.l       d6,d6               * *2
00B019D6  2006                    5139      MOVE.l  d6,d0               * setup for d7 = 0
00B019D8                          5140  LAB_LONN
00B019D8  2800                    5141      MOVE.l  d0,d4               * save cordic result
00B019DA  7A00                    5142      MOVEQ       #0,d5               * set default exponent sign
00B019DC  4A87                    5143      TST.l       d7              * check original exponent sign
00B019DE  6716                    5144      BEQ.s       LAB_LOXO            * branch if original was 0
00B019E0                          5145  
00B019E0  6A04                    5146      BPL.s       LAB_LOXP            * branch if was +ve
00B019E2                          5147  
00B019E2  4487                    5148      NEG.l       d7              * make original exponent +ve
00B019E4  7A80                    5149      MOVEQ       #$80-$100,d5        * make sign -ve
00B019E6                          5150  LAB_LOXP
00B019E6  1745 05F9               5151      MOVE.b  d5,FAC1_s(a3)       * save original exponent sign
00B019EA  4847                    5152      SWAP        d7              * 16 bit shift
00B019EC  E18F                    5153      LSL.l       #8,d7               * easy first part
00B019EE  7A88                    5154      MOVEQ       #$88-$100,d5        * start with byte
00B019F0                          5155  LAB_LONE
00B019F0  5385                    5156      SUBQ.l  #1,d5               * decrement exponent
00B019F2  DE87                    5157      ADD.l       d7,d7               * shift mantissa
00B019F4  6AFA                    5158      BPL.s       LAB_LONE            * loop if not normal
00B019F6                          5159  
00B019F6                          5160  LAB_LOXO
00B019F6  2747 05F4               5161      MOVE.l  d7,FAC1_m(a3)       * save original exponent as mantissa
00B019FA  1745 05F8               5162      MOVE.b  d5,FAC1_e(a3)       * save exponent for this
00B019FE  277C B17217F8 05FC      5163      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00B01A06  377C 8000 0600          5164      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00B01A0C  176B 05F9 0602          5165      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00B01A12  6118                    5166      BSR.s       LAB_MULTIPLY        * do multiply
00B01A14  2744 05FC               5167      MOVE.l  d4,FAC2_m(a3)       * save cordic result
00B01A18  6710                    5168      BEQ.s       LAB_LOWZ            * branch if zero
00B01A1A                          5169  
00B01A1A  377C 8200 0600          5170      MOVE.w  #$8200,FAC2_e(a3)       * set exponent & sign
00B01A20  176B 05F9 0602          5171      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * clear sign compare
00B01A26  6100 FE60               5172      BSR     LAB_ADD         * and add for final result
00B01A2A                          5173  
00B01A2A                          5174  LAB_LOWZ
00B01A2A  4E75                    5175      RTS
00B01A2C                          5176  
00B01A2C                          5177  
00B01A2C                          5178  *************************************************************************************
00B01A2C                          5179  *
00B01A2C                          5180  * multiply FAC1 by FAC2
00B01A2C                          5181  
00B01A2C                          5182  LAB_MULTIPLY
00B01A2C  48E7 F800               5183      MOVEM.l d0-d4,-(sp)         * save registers
00B01A30  4A2B 05F8               5184      TST.b       FAC1_e(a3)          * test FAC1 exponent
00B01A34  6776                    5185      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00B01A36                          5186  
00B01A36  102B 0600               5187      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00B01A3A  6770                    5188      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00B01A3C                          5189  
00B01A3C  176B 0602 05F9          5190      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare becomes sign
00B01A42                          5191  
00B01A42  D02B 05F8               5192      ADD.b       FAC1_e(a3),d0       * multiply exponents by adding
00B01A46  640A                    5193      BCC.s       LAB_MNOC            * branch if no carry
00B01A48                          5194  
00B01A48  0400 0080               5195      SUB.b       #$80,d0         * normalise result
00B01A4C  6400 E70C               5196      BCC     LAB_OFER            * if no carry do overflow
00B01A50                          5197  
00B01A50  6006                    5198      BRA.s       LAB_MADD            * branch
00B01A52                          5199  
00B01A52                          5200                              * no carry for exponent add
00B01A52                          5201  LAB_MNOC
00B01A52  0400 0080               5202      SUB.b       #$80,d0         * normalise result
00B01A56  6554                    5203      BCS.s       LAB_MUUF            * return zero if underflow
00B01A58                          5204  
00B01A58                          5205  LAB_MADD
00B01A58  1740 05F8               5206      MOVE.b  d0,FAC1_e(a3)       * save exponent
00B01A5C                          5207  
00B01A5C                          5208                              * d1 (FAC1) x d2 (FAC2)
00B01A5C  222B 05F4               5209      MOVE.l  FAC1_m(a3),d1       * get FAC1 mantissa
00B01A60  242B 05FC               5210      MOVE.l  FAC2_m(a3),d2       * get FAC2 mantissa
00B01A64                          5211  
00B01A64  3801                    5212      MOVE.w  d1,d4               * copy low word FAC1
00B01A66  2001                    5213      MOVE.l  d1,d0               * copy long word FAC1
00B01A68  4840                    5214      SWAP        d0              * high word FAC1 to low word FAC1
00B01A6A  3600                    5215      MOVE.w  d0,d3               * copy high word FAC1
00B01A6C                          5216  
00B01A6C  C2C2                    5217      MULU        d2,d1               * low word FAC2 x low word FAC1
00B01A6E  C0C2                    5218      MULU        d2,d0               * low word FAC2 x high word FAC1
00B01A70  4842                    5219      SWAP        d2              * high word FAC2 to low word FAC2
00B01A72  C8C2                    5220      MULU        d2,d4               * high word FAC2 x low word FAC1
00B01A74  C6C2                    5221      MULU        d2,d3               * high word FAC2 x high word FAC1
00B01A76                          5222  
00B01A76                          5223  * done multiply, now add partial products
00B01A76                          5224  
00B01A76                          5225  *           d1 =                    aaaa  ----  FAC2_L x FAC1_L
00B01A76                          5226  *           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
00B01A76                          5227  *           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
00B01A76                          5228  *           d3 =            cccc  bbbb          FAC2_H x FAC1_H
00B01A76                          5229  *           product =       mmmm  mmmm
00B01A76                          5230  
00B01A76  0681 00008000           5231      ADD.L       #$8000,d1           * round up lowest word
00B01A7C  4241                    5232      CLR.w       d1              * clear low word, don't need it
00B01A7E  4841                    5233      SWAP        d1              * align high word
00B01A80  D280                    5234      ADD.l       d0,d1               * add FAC2_L x FAC1_H (can't be carry)
00B01A82                          5235  LAB_MUF1
00B01A82  D284                    5236      ADD.l       d4,d1               * now add intermediate (FAC2_H x FAC1_L)
00B01A84  6406                    5237      BCC.s       LAB_MUF2            * branch if no carry
00B01A86                          5238  
00B01A86  0683 00010000           5239      ADD.l       #$10000,d3          * else correct result
00B01A8C                          5240  LAB_MUF2
00B01A8C  0681 00008000           5241      ADD.l       #$8000,d1           * round up low word
00B01A92  4241                    5242      CLR.w       d1              * clear low word
00B01A94  4841                    5243      SWAP        d1              * align for final add
00B01A96  D283                    5244      ADD.l       d3,d1               * add FAC2_H x FAC1_H, result
00B01A98  6B08                    5245      BMI.s       LAB_MUF3            * branch if normalisation not needed
00B01A9A                          5246  
00B01A9A  D281                    5247      ADD.l       d1,d1               * shift mantissa
00B01A9C  532B 05F8               5248      SUBQ.b  #1,FAC1_e(a3)       * adjust exponent
00B01AA0  670A                    5249      BEQ.s       LAB_MUUF            * branch if underflow
00B01AA2                          5250  
00B01AA2                          5251  LAB_MUF3
00B01AA2  2741 05F4               5252      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00B01AA6                          5253  LAB_MUEX
00B01AA6  4CDF 001F               5254      MOVEM.l (sp)+,d0-d4         * restore registers
00B01AAA  4E75                    5255      RTS
00B01AAC                          5256                              * either zero or underflow result
00B01AAC                          5257  LAB_MUUF
00B01AAC  7000                    5258      MOVEQ       #0,d0               * quick clear
00B01AAE  2740 05F4               5259      MOVE.l  d0,FAC1_m(a3)       * clear mantissa
00B01AB2  3740 05F8               5260      MOVE.w  d0,FAC1_e(a3)       * clear sign and exponent
00B01AB6  60EE                    5261      BRA.s       LAB_MUEX            * restore regs & exit
00B01AB8                          5262  
00B01AB8                          5263  
00B01AB8                          5264  *************************************************************************************
00B01AB8                          5265  *
00B01AB8                          5266  * do FAC2/FAC1, result in FAC1
00B01AB8                          5267  * fast hardware divide version
00B01AB8                          5268  
00B01AB8                          5269  LAB_DIVIDE
00B01AB8  2F07                    5270      MOVE.l  d7,-(sp)            * save d7
00B01ABA  7000                    5271      MOVEQ       #0,d0               * clear FAC2 exponent
00B01ABC  2400                    5272      MOVE.l  d0,d2               * clear FAC1 exponent
00B01ABE                          5273  
00B01ABE  142B 05F8               5274      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00B01AC2  6700 E682               5275      BEQ     LAB_DZER            * if zero go do /0 error
00B01AC6                          5276  
00B01AC6  102B 0600               5277      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00B01ACA  6766                    5278      BEQ.s       LAB_DIV0            * if zero return zero
00B01ACC                          5279  
00B01ACC  9042                    5280      SUB.w       d2,d0               * get result exponent by subtracting
00B01ACE  0640 0080               5281      ADD.w       #$80,d0         * correct 16 bit exponent result
00B01AD2                          5282  
00B01AD2  176B 0602 05F9          5283      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare is result sign
00B01AD8                          5284  
00B01AD8                          5285  * now to do 32/32 bit mantissa divide
00B01AD8                          5286  
00B01AD8  422B 0603               5287      CLR.b       flag(a3)            * clear 'flag' byte
00B01ADC  262B 05F4               5288      MOVE.l  FAC1_m(a3),d3       * get FAC1 mantissa
00B01AE0  282B 05FC               5289      MOVE.l  FAC2_m(a3),d4       * get FAC2 mantissa
00B01AE4  B883                    5290      CMP.l       d3,d4               * compare FAC2 with FAC1 mantissa
00B01AE6  6744                    5291      BEQ.s       LAB_MAN1            * set mantissa result = 1 if equal
00B01AE8                          5292  
00B01AE8  6506                    5293      BCS.s       AC1gtAC2            * branch if FAC1 > FAC2
00B01AEA                          5294  
00B01AEA  9883                    5295      SUB.l       d3,d4               * subtract FAC1 from FAC2, result now must be <1
00B01AEC  562B 0603               5296      ADDQ.b  #3,flag(a3)         * FAC2>FAC1 so set 'flag' byte
00B01AF0                          5297  AC1gtAC2
00B01AF0  6146                    5298      BSR.s       LAB_32_16           * do 32/16 divide
00B01AF2  4841                    5299      SWAP        d1              * move 16 bit result to high word
00B01AF4  2802                    5300      MOVE.l  d2,d4               * copy remainder longword
00B01AF6  6142                    5301      BSR.s       LAB_3216            * do 32/16 divide again (skip copy d4 to d2)
00B01AF8  84C5                    5302      DIVU.w  d5,d2               * now divide remainder to make guard word
00B01AFA  1E2B 0603               5303      MOVE.b  flag(a3),d7         * now normalise, get flag byte back
00B01AFE  6708                    5304      BEQ.s       LAB_DIVX            * skip add if null
00B01B00                          5305  
00B01B00                          5306  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
00B01B00                          5307  
00B01B00  E20F                    5308      LSR.b       #1,d7               * shift 1 into eXtend
00B01B02  E291                    5309      ROXR.l  #1,d1               * shift extend result >>
00B01B04  E252                    5310      ROXR.w  #1,d2               * shift extend guard word >>
00B01B06  5200                    5311      ADDQ.b  #1,d0               * adjust exponent
00B01B08                          5312  
00B01B08                          5313  * now round result to 32 bits
00B01B08                          5314  
00B01B08                          5315  LAB_DIVX
00B01B08  D442                    5316      ADD.w       d2,d2               * guard bit into eXtend bit
00B01B0A  6408                    5317      BCC.s       L_DIVRND            * branch if guard=0
00B01B0C                          5318  
00B01B0C  5281                    5319      ADDQ.l  #1,d1               * add guard to mantissa
00B01B0E  6404                    5320      BCC.s       L_DIVRND            * branch if no overflow
00B01B10                          5321  
00B01B10                          5322  LAB_SET1
00B01B10  E291                    5323      ROXR.l  #1,d1               * shift extend result >>
00B01B12  5240                    5324      ADDQ.w  #1,d0               * adjust exponent
00B01B14                          5325  
00B01B14                          5326                              * test for over/under flow
00B01B14                          5327  L_DIVRND
00B01B14  3600                    5328      MOVE.w  d0,d3               * copy exponent
00B01B16  6B1A                    5329      BMI.s       LAB_DIV0            * if -ve return zero
00B01B18                          5330  
00B01B18  0243 FF00               5331      ANDI.w  #$FF00,d3           * mask word high byte
00B01B1C  6600 E63C               5332      BNE     LAB_OFER            * branch if overflow
00B01B20                          5333  
00B01B20                          5334                              * move result into FAC1
00B01B20                          5335  LAB_XDIV
00B01B20  2E1F                    5336      MOVE.l  (sp)+,d7            * restore d7
00B01B22  1740 05F8               5337      MOVE.b  d0,FAC1_e(a3)       * save result exponent
00B01B26  2741 05F4               5338      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00B01B2A  4E75                    5339      RTS
00B01B2C                          5340  
00B01B2C                          5341  * FAC1 mantissa = FAC2 mantissa so set result mantissa
00B01B2C                          5342  
00B01B2C                          5343  LAB_MAN1
00B01B2C  7201                    5344      MOVEQ       #1,d1               * set bit
00B01B2E  E2A9                    5345      LSR.l       d1,d1               * bit into eXtend
00B01B30  60DE                    5346      BRA.s       LAB_SET1            * set mantissa, adjust exponent and exit
00B01B32                          5347  
00B01B32                          5348  * result is zero
00B01B32                          5349  
00B01B32                          5350  LAB_DIV0
00B01B32  7000                    5351      MOVEQ       #0,d0               * zero exponent & sign
00B01B34  2200                    5352      MOVE.l  d0,d1               * zero mantissa
00B01B36  60E8                    5353      BRA     LAB_XDIV            * exit divide
00B01B38                          5354  
00B01B38                          5355  * divide 16 bits into 32, AB/Ex
00B01B38                          5356  *
00B01B38                          5357  * d4            AAAA    BBBB            * 32 bit numerator
00B01B38                          5358  * d3            EEEE    xxxx            * 16 bit denominator
00B01B38                          5359  *
00B01B38                          5360  * returns -
00B01B38                          5361  *
00B01B38                          5362  * d1            xxxx    DDDD            * 16 bit result
00B01B38                          5363  * d2                HHHH    IIII        * 32 bit remainder
00B01B38                          5364  
00B01B38                          5365  LAB_32_16
00B01B38  2404                    5366      MOVE.l  d4,d2               * copy FAC2 mantissa        (AB)
00B01B3A                          5367  LAB_3216
00B01B3A  2A03                    5368      MOVE.l  d3,d5               * copy FAC1 mantissa        (EF)
00B01B3C  4245                    5369      CLR.w       d5              * clear low word d1     (Ex)
00B01B3E  4845                    5370      SWAP        d5              * swap high word to low word    (xE)
00B01B40                          5371  
00B01B40                          5372  * d3            EEEE    FFFF            * denominator copy
00B01B40                          5373  * d5        0000    EEEE                * denominator high word
00B01B40                          5374  * d2            AAAA    BBBB            * numerator copy
00B01B40                          5375  * d4            AAAA    BBBB            * numerator
00B01B40                          5376  
00B01B40  88C5                    5377      DIVU.w  d5,d4               * do FAC2/FAC1 high word    (AB/E)
00B01B42  6802                    5378      BVC.s       LAB_LT_1            * if no overflow DIV was ok
00B01B44                          5379  
00B01B44  78FF                    5380      MOVEQ       #-1,d4          * else set default value
00B01B46                          5381  
00B01B46                          5382  * done the divide, now check the result, we have ...
00B01B46                          5383  
00B01B46                          5384  * d3            EEEE    FFFF            * denominator copy
00B01B46                          5385  * d5        0000    EEEE                * denominator high word
00B01B46                          5386  * d2            AAAA    BBBB            * numerator copy
00B01B46                          5387  * d4            MMMM    DDDD            * result MOD and DIV
00B01B46                          5388  
00B01B46                          5389  LAB_LT_1
00B01B46  3C04                    5390      MOVE.w  d4,d6               * copy 16 bit result
00B01B48  3204                    5391      MOVE.w  d4,d1               * copy 16 bit result again
00B01B4A                          5392  
00B01B4A                          5393  * we now have ..
00B01B4A                          5394  * d3            EEEE    FFFF            * denominator copy
00B01B4A                          5395  * d5        0000    EEEE                * denominator high word
00B01B4A                          5396  * d6            xxxx  DDDD          * result DIV copy
00B01B4A                          5397  * d1            xxxx  DDDD          * result DIV copy
00B01B4A                          5398  * d2            AAAA    BBBB            * numerator copy
00B01B4A                          5399  * d4            MMMM    DDDD            * result MOD and DIV
00B01B4A                          5400  
00B01B4A                          5401  * now multiply out 32 bit denominator by 16 bit result
00B01B4A                          5402  * QRS = AB*D
00B01B4A                          5403  
00B01B4A  CCC3                    5404      MULU.w  d3,d6               * FFFF * DDDD =       rrrr  SSSS
00B01B4C  C8C5                    5405      MULU.w  d5,d4               * EEEE * DDDD = QQQQ  rrrr
00B01B4E                          5406  
00B01B4E                          5407  * we now have ..
00B01B4E                          5408  * d3            EEEE    FFFF            * denominator copy
00B01B4E                          5409  * d5        0000    EEEE                * denominator high word
00B01B4E                          5410  * d6                rrrr  SSSS      * 48 bit result partial low
00B01B4E                          5411  * d1            xxxx  DDDD          * result DIV copy
00B01B4E                          5412  * d2            AAAA    BBBB            * numerator copy
00B01B4E                          5413  * d4            QQQQ    rrrr            * 48 bit result partial
00B01B4E                          5414  
00B01B4E  3E06                    5415      MOVE.w  d6,d7               * copy low word of low multiply
00B01B50                          5416  
00B01B50                          5417  * d7                xxxx    SSSS        * 48 bit result partial low
00B01B50                          5418  
00B01B50  4246                    5419      CLR.w       d6              * clear low word of low multiply
00B01B52  4846                    5420      SWAP        d6              * high word of low multiply to low word
00B01B54                          5421  
00B01B54                          5422  * d6            0000    rrrr            * high word of 48 bit result partial low
00B01B54                          5423  
00B01B54  D886                    5424      ADD.l       d6,d4
00B01B56                          5425  
00B01B56                          5426  * d4            QQQQ    RRRR            * 48 bit result partial high longword
00B01B56                          5427  
00B01B56  7C00                    5428      MOVEQ       #0,d6               * clear to extend numerator to 48 bits
00B01B58                          5429  
00B01B58                          5430  * now do GHI = AB0 - QRS (which is the remainder)
00B01B58                          5431  
00B01B58  9C47                    5432      SUB.w       d7,d6               * low word subtract
00B01B5A                          5433  
00B01B5A                          5434  * d6                xxxx    IIII        * remainder low word
00B01B5A                          5435  
00B01B5A  9584                    5436      SUBX.l  d4,d2               * high longword subtract
00B01B5C                          5437  
00B01B5C                          5438  * d2            GGGG    HHHH            * remainder high longword
00B01B5C                          5439  
00B01B5C                          5440  * now if we got the divide correct then the remainder high longword will be +ve
00B01B5C                          5441  
00B01B5C  6A08                    5442      BPL.s       L_DDIV          * branch if result is ok (<needed)
00B01B5E                          5443  
00B01B5E                          5444  * remainder was -ve so DDDD is too big
00B01B5E                          5445  
00B01B5E                          5446  LAB_REMM
00B01B5E  5341                    5447      SUBQ.w  #1,d1               * adjust DDDD
00B01B60                          5448  
00B01B60                          5449  * d3                xxxx    FFFF        * denominator copy
00B01B60                          5450  * d6                xxxx    IIII        * remainder low word
00B01B60                          5451  
00B01B60  DC43                    5452      ADD.w       d3,d6               * add EF*1 low remainder low word
00B01B62                          5453  
00B01B62                          5454  * d5            0000    EEEE            * denominator high word
00B01B62                          5455  * d2            GGGG    HHHH            * remainder high longword
00B01B62                          5456  
00B01B62  D585                    5457      ADDX.l  d5,d2               * add extend EF*1 to remainder high longword
00B01B64  6BF8                    5458      BMI.s       LAB_REMM            * loop if result still too big
00B01B66                          5459  
00B01B66                          5460  * all done and result correct or <
00B01B66                          5461  
00B01B66                          5462  L_DDIV
00B01B66  4842                    5463      SWAP        d2              * remainder mid word to high word
00B01B68                          5464  
00B01B68                          5465  * d2            HHHH    GGGG            * (high word /should/ be $0000)
00B01B68                          5466  
00B01B68  3406                    5467      MOVE.w  d6,d2               * remainder in high word
00B01B6A                          5468  
00B01B6A                          5469  * d2                HHHH    IIII        * now is 32 bit remainder
00B01B6A                          5470  * d1            xxxx    DDDD            * 16 bit result
00B01B6A                          5471  
00B01B6A  4E75                    5472      RTS
00B01B6C                          5473  
00B01B6C                          5474  
00B01B6C                          5475  *************************************************************************************
00B01B6C                          5476  *
00B01B6C                          5477  * unpack memory (a0) into FAC1
00B01B6C                          5478  
00B01B6C                          5479  LAB_UFAC
00B01B6C  2010                    5480      MOVE.l  (a0),d0         * get packed value
00B01B6E  4840                    5481      SWAP        d0              * exponent and sign into least significant word
00B01B70  3740 05F8               5482      MOVE.w  d0,FAC1_e(a3)       * save exponent and sign
00B01B74  6708                    5483      BEQ.s       LAB_NB1T            * branch if exponent (and the rest) zero
00B01B76                          5484  
00B01B76  807C 0080               5485      OR.w        #$80,d0         * set MSb
00B01B7A  4840                    5486      SWAP        d0              * word order back to normal
00B01B7C  E180                    5487      ASL.l       #8,d0               * shift exponent & clear guard byte
00B01B7E                          5488  LAB_NB1T
00B01B7E  2740 05F4               5489      MOVE.l  d0,FAC1_m(a3)       * move into FAC1
00B01B82                          5490  
00B01B82  102B 05F8               5491      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B01B86  4E75                    5492      RTS
00B01B88                          5493  
00B01B88                          5494  
00B01B88                          5495  *************************************************************************************
00B01B88                          5496  *
00B01B88                          5497  * set numeric variable, pack FAC1 into Lvarpl
00B01B88                          5498  
00B01B88                          5499  LAB_PFAC
00B01B88  2F08                    5500      MOVE.l  a0,-(sp)            * save pointer
00B01B8A  206B 04D6               5501      MOVEA.l Lvarpl(a3),a0       * get destination pointer
00B01B8E  082B 0006 0619          5502      BTST        #6,Dtypef(a3)       * test data type
00B01B94  670C                    5503      BEQ.s       LAB_277C            * branch if floating
00B01B96                          5504  
00B01B96  6100 00C6               5505      BSR     LAB_2831            * convert FAC1 floating to fixed
00B01B9A                          5506                              * result in d0 and Itemp
00B01B9A  2080                    5507      MOVE.l  d0,(a0)         * save in var
00B01B9C  205F                    5508      MOVE.l  (sp)+,a0            * restore pointer
00B01B9E  4E75                    5509      RTS
00B01BA0                          5510  
00B01BA0                          5511  
00B01BA0                          5512  *************************************************************************************
00B01BA0                          5513  *
00B01BA0                          5514  * normalise round and pack FAC1 into (a0)
00B01BA0                          5515  
00B01BA0                          5516  LAB_2778
00B01BA0  2F08                    5517      MOVE.l  a0,-(sp)            * save pointer
00B01BA2                          5518  LAB_277C
00B01BA2  6100 FD60               5519      BSR     LAB_24D5            * normalise FAC1
00B01BA6  612C                    5520      BSR.s       LAB_27BA            * round FAC1
00B01BA8  202B 05F4               5521      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00B01BAC  E098                    5522      ROR.l       #8,d0               * align 24/32 bit mantissa
00B01BAE  4840                    5523      SWAP        d0              * exponent/sign into 0-15
00B01BB0  C07C 007F               5524      AND.w       #$7F,d0         * clear exponent and sign bit
00B01BB4  022B 0080 05F9          5525      ANDI.b  #$80,FAC1_s(a3)     * clear non sign bits in sign
00B01BBA  806B 05F8               5526      OR.w        FAC1_e(a3),d0       * OR in exponent and sign
00B01BBE  4840                    5527      SWAP        d0              * move exponent and sign back to 16-31
00B01BC0  2080                    5528      MOVE.l  d0,(a0)         * store in destination
00B01BC2  205F                    5529      MOVE.l  (sp)+,a0            * restore pointer
00B01BC4  4E75                    5530      RTS
00B01BC6                          5531  
00B01BC6                          5532  
00B01BC6                          5533  *************************************************************************************
00B01BC6                          5534  *
00B01BC6                          5535  * copy FAC2 to FAC1
00B01BC6                          5536  
00B01BC6                          5537  LAB_279B
00B01BC6  376B 0600 05F8          5538      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy exponent & sign
00B01BCC  276B 05FC 05F4          5539      MOVE.l  FAC2_m(a3),FAC1_m(a3)   * copy mantissa
00B01BD2  4E75                    5540      RTS
00B01BD4                          5541  
00B01BD4                          5542  
00B01BD4                          5543  *************************************************************************************
00B01BD4                          5544  *
00B01BD4                          5545  * round FAC1
00B01BD4                          5546  
00B01BD4                          5547  LAB_27BA
00B01BD4  102B 05F8               5548      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B01BD8  6720                    5549      BEQ.s       LAB_27C4            * branch if zero
00B01BDA                          5550  
00B01BDA  202B 05F4               5551      MOVE.l  FAC1_m(a3),d0       * get FAC1
00B01BDE  0680 00000080           5552      ADD.l       #$80,d0         * round to 24 bit
00B01BE4  640A                    5553      BCC.s       LAB_27C3            * branch if no overflow
00B01BE6                          5554  
00B01BE6  E290                    5555      ROXR.l  #1,d0               * shift FAC1 mantissa
00B01BE8  522B 05F8               5556      ADDQ.b  #1,FAC1_e(a3)       * correct exponent
00B01BEC  6500 E56C               5557      BCS     LAB_OFER            * if carry do overflow error & warm start
00B01BF0                          5558  
00B01BF0                          5559  LAB_27C3
00B01BF0  C03C 0000               5560      AND.b       #$00,d0         * clear guard byte
00B01BF4  2740 05F4               5561      MOVE.l  d0,FAC1_m(a3)       * save back to FAC1
00B01BF8  4E75                    5562      RTS
00B01BFA                          5563  
00B01BFA                          5564  LAB_27C4
00B01BFA  1740 05F9               5565      MOVE.b  d0,FAC1_s(a3)       * make zero always +ve
00B01BFE                          5566  RTS_017
00B01BFE  4E75                    5567      RTS
00B01C00                          5568  
00B01C00                          5569  
00B01C00                          5570  *************************************************************************************
00B01C00                          5571  *
00B01C00                          5572  * get FAC1 sign
00B01C00                          5573  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00B01C00                          5574  
00B01C00                          5575  LAB_27CA
00B01C00  7000                    5576      MOVEQ       #0,d0               * clear d0
00B01C02  102B 05F8               5577      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B01C06  67F6                    5578      BEQ.s       RTS_017         * exit if zero (already correct SGN(0)=0)
00B01C08                          5579  
00B01C08                          5580  
00B01C08                          5581  *************************************************************************************
00B01C08                          5582  *
00B01C08                          5583  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00B01C08                          5584  * no = 0 check
00B01C08                          5585  
00B01C08                          5586  LAB_27CE
00B01C08  102B 05F9               5587      MOVE.b  FAC1_s(a3),d0       * else get FAC1 sign (b7)
00B01C0C                          5588  
00B01C0C                          5589  
00B01C0C                          5590  *************************************************************************************
00B01C0C                          5591  *
00B01C0C                          5592  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00B01C0C                          5593  * no = 0 check, sign in d0
00B01C0C                          5594  
00B01C0C                          5595  LAB_27D0
00B01C0C  4880                    5596      EXT.w       d0              * make word
00B01C0E  48C0                    5597      EXT.l       d0              * make longword
00B01C10  E080                    5598      ASR.l       #8,d0               * move sign bit through byte to carry
00B01C12  65EA                    5599      BCS.s       RTS_017         * exit if carry set
00B01C14                          5600  
00B01C14  7001                    5601      MOVEQ       #1,d0               * set result for +ve sign
00B01C16  4E75                    5602      RTS
00B01C18                          5603  
00B01C18                          5604  
00B01C18                          5605  *************************************************************************************
00B01C18                          5606  *
00B01C18                          5607  * perform SGN()
00B01C18                          5608  
00B01C18                          5609  LAB_SGN
00B01C18  61E6                    5610      BSR.s       LAB_27CA            * get FAC1 sign
00B01C1A                          5611                              * return d0=-1/-ve d0=+1/+ve
00B01C1A                          5612  
00B01C1A                          5613  
00B01C1A                          5614  *************************************************************************************
00B01C1A                          5615  *
00B01C1A                          5616  * save d0 as integer longword
00B01C1A                          5617  
00B01C1A                          5618  LAB_27DB
00B01C1A  2740 05F4               5619      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00B01C1E  377C A000 05F8          5620      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent & sign
00B01C24  D080                    5621      ADD.l       d0,d0               * top bit into carry
00B01C26  6000 FCD0               5622      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00B01C2A                          5623  
00B01C2A                          5624  
00B01C2A                          5625  *************************************************************************************
00B01C2A                          5626  *
00B01C2A                          5627  * perform ABS()
00B01C2A                          5628  
00B01C2A                          5629  LAB_ABS
00B01C2A  177C 0000 05F9          5630      MOVE.b  #0,FAC1_s(a3)       * clear FAC1 sign
00B01C30  4E75                    5631      RTS
00B01C32                          5632  
00B01C32                          5633  
00B01C32                          5634  *************************************************************************************
00B01C32                          5635  *
00B01C32                          5636  * compare FAC1 with FAC2
00B01C32                          5637  * returns d0=+1 Cb=0 if FAC1 > FAC2
00B01C32                          5638  * returns d0= 0 Cb=0 if FAC1 = FAC2
00B01C32                          5639  * returns d0=-1 Cb=1 if FAC1 < FAC2
00B01C32                          5640  
00B01C32                          5641  LAB_27FA
00B01C32  122B 0600               5642      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00B01C36  67C8                    5643      BEQ.s       LAB_27CA            * branch if FAC2 exponent=0 & get FAC1 sign
00B01C38                          5644                              * d0=-1,C=1/-ve d0=+1,C=0/+ve
00B01C38                          5645  
00B01C38  102B 0602               5646      MOVE.b  FAC_sc(a3),d0       * get FAC sign compare
00B01C3C  6BCA                    5647      BMI.s       LAB_27CE            * if signs <> do return d0=-1,C=1/-ve
00B01C3E                          5648                              * d0=+1,C=0/+ve & return
00B01C3E                          5649  
00B01C3E  102B 05F9               5650      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00B01C42  B22B 05F8               5651      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00B01C46  660A                    5652      BNE.s       LAB_2828            * branch if different
00B01C48                          5653  
00B01C48  222B 05FC               5654      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00B01C4C  B2AB 05F4               5655      CMP.l       FAC1_m(a3),d1       * compare mantissas
00B01C50  6708                    5656      BEQ.s       LAB_282F            * exit if mantissas equal
00B01C52                          5657  
00B01C52                          5658  * gets here if number <> FAC1
00B01C52                          5659  
00B01C52                          5660  LAB_2828
00B01C52  65B8                    5661      BCS.s       LAB_27D0            * if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
00B01C54                          5662                              * C=0/+ve
00B01C54                          5663  
00B01C54  0A00 0080               5664      EORI.b  #$80,d0         * else toggle FAC1 sign
00B01C58                          5665  LAB_282E
00B01C58  60B2                    5666      BRA.s       LAB_27D0            * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00B01C5A                          5667  
00B01C5A                          5668  LAB_282F
00B01C5A  7000                    5669      MOVEQ       #0,d0               * clear result
00B01C5C  4E75                    5670      RTS
00B01C5E                          5671  
00B01C5E                          5672  
00B01C5E                          5673  *************************************************************************************
00B01C5E                          5674  *
00B01C5E                          5675  * convert FAC1 floating to fixed
00B01C5E                          5676  * result in d0 and Itemp, sets flags correctly
00B01C5E                          5677  
00B01C5E                          5678  LAB_2831
00B01C5E  202B 05F4               5679      MOVE.l  FAC1_m(a3),d0       * copy mantissa
00B01C62  6730                    5680      BEQ.s       LAB_284J            * branch if mantissa = 0
00B01C64                          5681  
00B01C64  2F01                    5682      MOVE.l  d1,-(sp)            * save d1
00B01C66  72A0                    5683      MOVEQ       #$A0,d1         * set for no floating bits
00B01C68  922B 05F8               5684      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent
00B01C6C  6500 E4EC               5685      BCS     LAB_OFER            * do overflow if too big
00B01C70                          5686  
00B01C70  660E                    5687      BNE.s       LAB_284G            * branch if exponent was not $A0
00B01C72                          5688  
00B01C72  4A2B 05F9               5689      TST.b       FAC1_s(a3)          * test FAC1 sign
00B01C76  6A1A                    5690      BPL.s       LAB_284H            * branch if FAC1 +ve
00B01C78                          5691  
00B01C78  4480                    5692      NEG.l       d0
00B01C7A  6916                    5693      BVS.s       LAB_284H            * branch if was $80000000
00B01C7C                          5694  
00B01C7C  6000 E4DC               5695      BRA     LAB_OFER            * do overflow if too big
00B01C80                          5696  
00B01C80                          5697  LAB_284G
00B01C80  B23C 0020               5698      CMP.b       #$20,d1         * compare with minimum result for integer
00B01C84  6502                    5699      BCS.s       LAB_284L            * if < minimum just do shift
00B01C86                          5700  
00B01C86  7000                    5701      MOVEQ       #0,d0               * else return zero
00B01C88                          5702  LAB_284L
00B01C88  E2A8                    5703      LSR.l       d1,d0               * shift integer
00B01C8A                          5704  
00B01C8A  4A2B 05F9               5705      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00B01C8E  6A02                    5706      BPL.s       LAB_284H            * branch if FAC1 +ve
00B01C90                          5707  
00B01C90  4480                    5708      NEG.l       d0              * negate integer value
00B01C92                          5709  LAB_284H
00B01C92  221F                    5710      MOVE.l  (sp)+,d1            * restore d1
00B01C94                          5711  LAB_284J
00B01C94  2740 048E               5712      MOVE.l  d0,Itemp(a3)        * save result to Itemp
00B01C98  4E75                    5713      RTS
00B01C9A                          5714  
00B01C9A                          5715  
00B01C9A                          5716  *************************************************************************************
00B01C9A                          5717  *
00B01C9A                          5718  * perform INT()
00B01C9A                          5719  
00B01C9A                          5720  LAB_INT
00B01C9A  70A0                    5721      MOVEQ       #$A0,d0         * set for no floating bits
00B01C9C  902B 05F8               5722      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00B01CA0  6310                    5723      BLS.s       LAB_IRTS            * exit if exponent >= $A0
00B01CA2                          5724                              * (too big for fraction part!)
00B01CA2                          5725  
00B01CA2  B03C 0020               5726      CMP.b       #$20,d0         * compare with minimum result for integer
00B01CA6  6400 025E               5727      BCC     LAB_POZE            * if >= minimum go return 0
00B01CAA                          5728                              * (too small for integer part!)
00B01CAA                          5729  
00B01CAA  72FF                    5730      MOVEQ       #-1,d1          * set integer mask
00B01CAC  E1A1                    5731      ASL.l       d0,d1               * shift mask [8+2*d0]
00B01CAE  C3AB 05F4               5732      AND.l       d1,FAC1_m(a3)       * mask mantissa
00B01CB2                          5733  LAB_IRTS
00B01CB2  4E75                    5734      RTS
00B01CB4                          5735  
00B01CB4                          5736  
00B01CB4                          5737  *************************************************************************************
00B01CB4                          5738  *
00B01CB4                          5739  * print " in line [LINE #]"
00B01CB4                          5740  
00B01CB4                          5741  LAB_2953
00B01CB4  41FA 17FA               5742      LEA     LAB_LMSG(pc),a0     * point to " in line " message
00B01CB8  6100 ED24               5743      BSR     LAB_18C3            * print null terminated string
00B01CBC                          5744  
00B01CBC                          5745                              * Print Basic line #
00B01CBC  202B 04B6               5746      MOVE.l  Clinel(a3),d0       * get current line
00B01CC0                          5747  
00B01CC0                          5748  
00B01CC0                          5749  *************************************************************************************
00B01CC0                          5750  *
00B01CC0                          5751  * print d0 as unsigned integer
00B01CC0                          5752  
00B01CC0                          5753  LAB_295E
00B01CC0  43FA 0DE8               5754      LEA     Bin2dec(pc),a1      * get table address
00B01CC4  7200                    5755      MOVEQ       #0,d1               * table index
00B01CC6  41EB 0630               5756      LEA     Usdss(a3),a0        * output string start
00B01CCA  2401                    5757      MOVE.l  d1,d2               * output string index
00B01CCC                          5758  LAB_2967
00B01CCC  2631 1000               5759      MOVE.l  (a1,d1.w),d3        * get table value
00B01CD0  6714                    5760      BEQ.s       LAB_2969            * exit if end marker
00B01CD2                          5761  
00B01CD2  782F                    5762      MOVEQ       #'0'-1,d4           * set character to "0"-1
00B01CD4                          5763  LAB_2968
00B01CD4  5244                    5764      ADDQ.w  #1,d4               * next numeric character
00B01CD6  9083                    5765      SUB.l       d3,d0               * subtract table value
00B01CD8  6AFA                    5766      BPL.s       LAB_2968            * not overdone so loop
00B01CDA                          5767  
00B01CDA  D083                    5768      ADD.l       d3,d0               * correct value
00B01CDC  1184 2000               5769      MOVE.b  d4,(a0,d2.w)        * character out to string
00B01CE0  5841                    5770      ADDQ.w  #4,d1               * increment table pointer
00B01CE2  5242                    5771      ADDQ.w  #1,d2               * increment output string pointer
00B01CE4  60E6                    5772      BRA.s       LAB_2967            * loop
00B01CE6                          5773  
00B01CE6                          5774  LAB_2969
00B01CE6  0600 0030               5775      ADD.b       #'0',d0         * make last character
00B01CEA  1180 2000               5776      MOVE.b  d0,(a0,d2.w)        * character out to string
00B01CEE  5348                    5777      SUBQ.w  #1,a0               * decrement a0 (allow simple loop)
00B01CF0                          5778  
00B01CF0                          5779                              * now find non zero start of string
00B01CF0                          5780  LAB_296A
00B01CF0  5248                    5781      ADDQ.w  #1,a0               * increment a0 (this will never carry to b16)
00B01CF2  43EB 0639               5782      LEA     BHsend-1(a3),a1     * get string end
00B01CF6  B1C9                    5783      CMPA.l  a1,a0               * are we at end
00B01CF8  6700 ECE4               5784      BEQ     LAB_18C3            * if so print null terminated string and RETURN
00B01CFC                          5785  
00B01CFC  0C10 0030               5786      CMPI.b  #'0',(a0)           * is character "0" ?
00B01D00  67EE                    5787      BEQ.s       LAB_296A            * loop if so
00B01D02                          5788  
00B01D02  6000 ECDA               5789      BRA     LAB_18C3            * print null terminated string from memory & RET
00B01D06                          5790  
00B01D06                          5791  
00B01D06                          5792  *************************************************************************************
00B01D06                          5793  *
00B01D06                          5794  * convert FAC1 to ASCII string result in (a0)
00B01D06                          5795  * STR$() function enters here
00B01D06                          5796  
00B01D06                          5797  * now outputs 7 significant digits
00B01D06                          5798  
00B01D06                          5799  * d0 is character out
00B01D06                          5800  * d1 is save index
00B01D06                          5801  * d2 is gash
00B01D06                          5802  
00B01D06                          5803  * a0 is output string pointer
00B01D06                          5804  
00B01D06                          5805  LAB_2970
00B01D06  43EB 062A               5806      LEA     Decss(a3),a1        * set output string start
00B01D0A                          5807  
00B01D0A  7420                    5808      MOVEQ       #' ',d2         * character = " ", assume +ve
00B01D0C  08AB 0007 05F9          5809      BCLR.b  #7,FAC1_s(a3)       * test and clear FAC1 sign (b7)
00B01D12  6702                    5810      BEQ.s       LAB_2978            * branch if +ve
00B01D14                          5811  
00B01D14  742D                    5812      MOVEQ       #'-',d2         * else character = "-"
00B01D16                          5813  LAB_2978
00B01D16  1282                    5814      MOVE.b  d2,(a1)         * save the sign character
00B01D18  142B 05F8               5815      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00B01D1C  6608                    5816      BNE.s       LAB_2989            * branch if FAC1<>0
00B01D1E                          5817  
00B01D1E                          5818                              * exponent was $00 so FAC1 is 0
00B01D1E  7030                    5819      MOVEQ       #'0',d0         * set character = "0"
00B01D20  7201                    5820      MOVEQ       #1,d1               * set output string index
00B01D22  6000 01A4               5821      BRA     LAB_2A89            * save last character, [EOT] & exit
00B01D26                          5822  
00B01D26                          5823                              * FAC1 is some non zero value
00B01D26                          5824  LAB_2989
00B01D26  177C 0000 0610          5825      MOVE.b  #0,numexp(a3)       * clear number exponent count
00B01D2C  B43C 0081               5826      CMP.b       #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
00B01D30                          5827  
00B01D30  6448                    5828      BCC.s       LAB_299C            * branch if FAC1=>1
00B01D32                          5829  
00B01D32                          5830                              * else FAC1 < 1
00B01D32  277C 98968000 05FC      5831      MOVE.l  #$98968000,FAC2_m(a3)   * 10000000 mantissa
00B01D3A  377C 9800 0600          5832      MOVE.w  #$9800,FAC2_e(a3)       * 10000000 exponent & sign
00B01D40  176B 05F9 0602          5833      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make FAC1 sign sign compare
00B01D46  6100 FCE4               5834      BSR     LAB_MULTIPLY        * do FAC2*FAC1
00B01D4A                          5835  
00B01D4A  177C 00F9 0610          5836      MOVE.b  #$F9,numexp(a3)     * set number exponent count (-7)
00B01D50  6028                    5837      BRA.s       LAB_299C            * go test for fit
00B01D52                          5838  
00B01D52                          5839  LAB_29B9
00B01D52  376B 05F8 0600          5840      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00B01D58  276B 05F4 05FC          5841      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00B01D5E  176B 05F9 0602          5842      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * save FAC1_s as sign compare
00B01D64                          5843  
00B01D64  277C CCCCCCCD 05F4      5844      MOVE.l  #$CCCCCCCD,FAC1_m(a3)   * 1/10 mantissa
00B01D6C  377C 7D00 05F8          5845      MOVE.w  #$7D00,FAC1_e(a3)       * 1/10 exponent & sign
00B01D72  6100 FCB8               5846      BSR     LAB_MULTIPLY        * do FAC2*FAC1, effectively divide by 10 but
00B01D76                          5847                              * faster
00B01D76                          5848  
00B01D76  522B 0610               5849      ADDQ.b  #1,numexp(a3)       * increment number exponent count
00B01D7A                          5850  LAB_299C
00B01D7A  277C 98967F70 05FC      5851      MOVE.l  #$98967F70,FAC2_m(a3)   * 9999999.4375 mantissa
00B01D82  377C 9800 0600          5852      MOVE.w  #$9800,FAC2_e(a3)       * 9999999.4375 exponent & sign
00B01D88                          5853                              * (max before scientific notation)
00B01D88  6100 014C               5854      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00B01D8C                          5855                              * returns d0=+1 C=0 if FAC1 > FAC2
00B01D8C                          5856                              * returns d0= 0 C=0 if FAC1 = FAC2
00B01D8C                          5857                              * returns d0=-1 C=1 if FAC1 < FAC2
00B01D8C  62C4                    5858      BHI.s       LAB_29B9            * go do /10 if FAC1 > 9999999.4375
00B01D8E                          5859  
00B01D8E  6750                    5860      BEQ.s       LAB_29C3            * branch if FAC1 = 9999999.4375
00B01D90                          5861  
00B01D90                          5862                              * FAC1 < 9999999.4375
00B01D90  277C F423F800 05FC      5863      MOVE.l  #$F423F800,FAC2_m(a3)   * set mantissa for 999999.5
00B01D98  377C 9400 0600          5864      MOVE.w  #$9400,FAC2_e(a3)       * set exponent for 999999.5
00B01D9E                          5865  
00B01D9E  41EB 05F4               5866      LEA     FAC1_m(a3),a0       * set pointer for x10
00B01DA2                          5867  LAB_29A7
00B01DA2  6100 0132               5868      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00B01DA6                          5869                              * returns d0=+1 C=0 if FAC1 > FAC2
00B01DA6                          5870                              * returns d0= 0 C=0 if FAC1 = FAC2
00B01DA6                          5871                              * returns d0=-1 C=1 if FAC1 < FAC2
00B01DA6  6220                    5872      BHI.s       LAB_29C0            * branch if FAC1 > 99999.9375,no decimal places
00B01DA8                          5873  
00B01DA8                          5874                              * FAC1 <= 999999.5 so do x 10
00B01DA8  2010                    5875      MOVE.l  (a0),d0         * get FAC1 mantissa
00B01DAA  1228 0004               5876      MOVE.b  4(a0),d1            * get FAC1 exponent
00B01DAE  2400                    5877      MOVE.l  d0,d2               * copy it
00B01DB0  E488                    5878      LSR.l       #2,d0               * /4
00B01DB2  D082                    5879      ADD.l       d2,d0               * add FAC1 (x1.125)
00B01DB4  6404                    5880      BCC.s       LAB_29B7            * branch if no carry
00B01DB6                          5881  
00B01DB6  E290                    5882      ROXR.l  #1,d0               * shift carry back in
00B01DB8  5201                    5883      ADDQ.b  #1,d1               * increment exponent (never overflows)
00B01DBA                          5884  LAB_29B7
00B01DBA  5601                    5885      ADDQ.b  #3,d1               * correct exponent ( 8 x 1.125 = 10 )
00B01DBC                          5886                              * (never overflows)
00B01DBC  2080                    5887      MOVE.l  d0,(a0)         * save new mantissa
00B01DBE  1141 0004               5888      MOVE.b  d1,4(a0)            * save new exponent
00B01DC2  532B 0610               5889      SUBQ.b  #1,numexp(a3)       * decrement number exponent count
00B01DC6  60DA                    5890      BRA.s       LAB_29A7            * go test again
00B01DC8                          5891  
00B01DC8                          5892                              * now we have just the digits to do
00B01DC8                          5893  LAB_29C0
00B01DC8  277C 80000000 05FC      5894      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 0.5
00B01DD0  377C 8000 0600          5895      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for 0.5
00B01DD6  176B 05F9 0602          5896      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00B01DDC  6100 FAAA               5897      BSR     LAB_ADD         * add the 0.5 to FAC1 (round FAC1)
00B01DE0                          5898  
00B01DE0                          5899  LAB_29C3
00B01DE0  6100 FE7C               5900      BSR     LAB_2831            * convert FAC1 floating to fixed
00B01DE4                          5901                              * result in d0 and Itemp
00B01DE4  7401                    5902      MOVEQ       #$01,d2         * set default digits before dp = 1
00B01DE6  102B 0610               5903      MOVE.b  numexp(a3),d0       * get number exponent count
00B01DEA  5000                    5904      ADD.b       #8,d0               * allow 7 digits before point
00B01DEC  6B0C                    5905      BMI.s       LAB_29D9            * if -ve then 1 digit before dp
00B01DEE                          5906  
00B01DEE  B03C 0009               5907      CMP.b       #$09,d0         * d0>=9 if n>=1E7
00B01DF2  6406                    5908      BCC.s       LAB_29D9            * branch if >= $09
00B01DF4                          5909  
00B01DF4                          5910                              * < $08
00B01DF4  5300                    5911      SUBQ.b  #1,d0               * take 1 from digit count
00B01DF6  1400                    5912      MOVE.b  d0,d2               * copy byte
00B01DF8  7002                    5913      MOVEQ       #$02,d0         * set exponent adjust
00B01DFA                          5914  LAB_29D9
00B01DFA  7200                    5915      MOVEQ       #0,d1               * set output string index
00B01DFC  5500                    5916      SUBQ.b  #2,d0               * -2
00B01DFE  1740 0611               5917      MOVE.b  d0,expcnt(a3)       * save exponent adjust
00B01E02  1742 0610               5918      MOVE.b  d2,numexp(a3)       * save digits before dp count
00B01E06  1002                    5919      MOVE.b  d2,d0               * copy digits before dp count
00B01E08  6702                    5920      BEQ.s       LAB_29E4            * branch if no digits before dp
00B01E0A                          5921  
00B01E0A  6A14                    5922      BPL.s       LAB_29F7            * branch if digits before dp
00B01E0C                          5923  
00B01E0C                          5924  LAB_29E4
00B01E0C  5281                    5925      ADDQ.l  #1,d1               * increment index
00B01E0E  13BC 002E 1000          5926      MOVE.b  #'.',(a1,d1.w)      * save to output string
00B01E14                          5927  
00B01E14  4A02                    5928      TST.b       d2              * test digits before dp count
00B01E16  6708                    5929      BEQ.s       LAB_29F7            * branch if no digits before dp
00B01E18                          5930  
00B01E18  5281                    5931      ADDQ.l  #1,d1               * increment index
00B01E1A  13BC 0030 1000          5932      MOVE.b  #'0',(a1,d1.w)      * save to output string
00B01E20                          5933  LAB_29F7
00B01E20  7400                    5934      MOVEQ       #0,d2               * clear index (point to 1,000,000)
00B01E22  7080                    5935      MOVEQ       #$80-$100,d0        * set output character
00B01E24                          5936  LAB_29FB
00B01E24  41FA 111E               5937      LEA     LAB_2A9A(pc),a0     * get base of table
00B01E28  2630 2000               5938      MOVE.l  (a0,d2.w),d3        * get table value
00B01E2C                          5939  LAB_29FD
00B01E2C  5200                    5940      ADDQ.b  #1,d0               * increment output character
00B01E2E  D7AB 048E               5941      ADD.l       d3,Itemp(a3)        * add to (now fixed) mantissa
00B01E32  0800 0007               5942      BTST        #7,d0               * set test sense (z flag only)
00B01E36  6504                    5943      BCS.s       LAB_2A18            * did carry so has wrapped past zero
00B01E38                          5944  
00B01E38  67F2                    5945      BEQ.s       LAB_29FD            * no wrap and +ve test so try again
00B01E3A                          5946  
00B01E3A  6002                    5947      BRA.s       LAB_2A1A            * found this digit
00B01E3C                          5948  
00B01E3C                          5949  LAB_2A18
00B01E3C  66EE                    5950      BNE.s       LAB_29FD            * wrap and -ve test so try again
00B01E3E                          5951  
00B01E3E                          5952  LAB_2A1A
00B01E3E  6406                    5953      BCC.s       LAB_2A21            * branch if +ve test result
00B01E40                          5954  
00B01E40  4400                    5955      NEG.b       d0              * negate the digit number
00B01E42  0600 000B               5956      ADD.b       #$0B,d0         * and subtract from 11 decimal
00B01E46                          5957  LAB_2A21
00B01E46  0600 002F               5958      ADD.b       #$2F,d0         * add "0"-1 to result
00B01E4A  5842                    5959      ADDQ.w  #4,d2               * increment index to next less power of ten
00B01E4C  5241                    5960      ADDQ.w  #1,d1               * increment output string index
00B01E4E  1600                    5961      MOVE.b  d0,d3               * copy character to d3
00B01E50  C63C 007F               5962      AND.b       #$7F,d3         * mask out top bit
00B01E54  1383 1000               5963      MOVE.b  d3,(a1,d1.w)        * save to output string
00B01E58  532B 0610               5964      SUB.b       #1,numexp(a3)       * decrement # of characters before the dp
00B01E5C  6608                    5965      BNE.s       LAB_2A3B            * branch if still characters to do
00B01E5E                          5966  
00B01E5E                          5967                              * else output the point
00B01E5E  5281                    5968      ADDQ.l  #1,d1               * increment index
00B01E60  13BC 002E 1000          5969      MOVE.b  #'.',(a1,d1.w)      * save to output string
00B01E66                          5970  LAB_2A3B
00B01E66  C03C 0080               5971      AND.b       #$80,d0         * mask test sense bit
00B01E6A  0A00 0080               5972      EORI.b  #$80,d0         * invert it
00B01E6E  B43C 001C               5973      CMP.b       #LAB_2A9B-LAB_2A9A,d2   * compare table index with max+4
00B01E72  66B0                    5974      BNE.s       LAB_29FB            * loop if not max
00B01E74                          5975  
00B01E74                          5976                              * now remove trailing zeroes
00B01E74                          5977  LAB_2A4B
00B01E74  1031 1000               5978      MOVE.b  (a1,d1.w),d0        * get character from output string
00B01E78  5381                    5979      SUBQ.l  #1,d1               * decrement output string index
00B01E7A  B03C 0030               5980      CMP.b       #'0',d0         * compare with "0"
00B01E7E  67F4                    5981      BEQ.s       LAB_2A4B            * loop until non "0" character found
00B01E80                          5982  
00B01E80  B03C 002E               5983      CMP.b       #'.',d0         * compare with "."
00B01E84  6702                    5984      BEQ.s       LAB_2A58            * branch if was dp
00B01E86                          5985  
00B01E86                          5986                              * else restore last character
00B01E86  5281                    5987      ADDQ.l  #1,d1               * increment output string index
00B01E88                          5988  LAB_2A58
00B01E88  13BC 002B 1002          5989      MOVE.b  #'+',2(a1,d1.w)     * save character "+" to output string
00B01E8E  4A2B 0611               5990      TST.b       expcnt(a3)          * test exponent count
00B01E92  6738                    5991      BEQ.s       LAB_2A8C            * if zero go set null terminator & exit
00B01E94                          5992  
00B01E94                          5993                              * exponent isn't zero so write exponent
00B01E94  6A0A                    5994      BPL.s       LAB_2A68            * branch if exponent count +ve
00B01E96                          5995  
00B01E96  13BC 002D 1002          5996      MOVE.b  #'-',2(a1,d1.w)     * save character "-" to output string
00B01E9C  442B 0611               5997      NEG.b       expcnt(a3)          * convert -ve to +ve
00B01EA0                          5998  LAB_2A68
00B01EA0  13BC 0045 1001          5999      MOVE.b  #'E',1(a1,d1.w)     * save character "E" to output string
00B01EA6  142B 0611               6000      MOVE.b  expcnt(a3),d2       * get exponent count
00B01EAA  702F                    6001      MOVEQ       #$2F,d0         * one less than "0" character
00B01EAC                          6002  LAB_2A74
00B01EAC  5200                    6003      ADDQ.b  #1,d0               * increment 10's character
00B01EAE  0402 000A               6004      SUB.b       #$0A,d2         * subtract 10 from exponent count
00B01EB2  64F8                    6005      BCC.s       LAB_2A74            * loop while still >= 0
00B01EB4                          6006  
00B01EB4  0602 003A               6007      ADD.b       #$3A,d2         * add character ":", $30+$0A, result is 10-value
00B01EB8  1380 1003               6008      MOVE.b  d0,3(a1,d1.w)       * save 10's character to output string
00B01EBC  1382 1004               6009      MOVE.b  d2,4(a1,d1.w)       * save 1's character to output string
00B01EC0  13BC 0000 1005          6010      MOVE.b  #0,5(a1,d1.w)       * save null terminator after last character
00B01EC6  600A                    6011      BRA.s       LAB_2A91            * go set string pointer (a0) and exit
00B01EC8                          6012  
00B01EC8                          6013  LAB_2A89
00B01EC8  1380 1000               6014      MOVE.b  d0,(a1,d1.w)        * save last character to output string
00B01ECC                          6015  LAB_2A8C
00B01ECC  13BC 0000 1001          6016      MOVE.b  #0,1(a1,d1.w)       * save null terminator after last character
00B01ED2                          6017  LAB_2A91
00B01ED2  2049                    6018      MOVEA.l a1,a0               * set result string pointer (a0)
00B01ED4  4E75                    6019      RTS
00B01ED6                          6020  
00B01ED6                          6021  
00B01ED6                          6022  *************************************************************************************
00B01ED6                          6023  *
00B01ED6                          6024  * fast compare FAC1 with FAC2
00B01ED6                          6025  * assumes both are +ve and FAC2>0
00B01ED6                          6026  * returns d0=+1 C=0 if FAC1 > FAC2
00B01ED6                          6027  * returns d0= 0 C=0 if FAC1 = FAC2
00B01ED6                          6028  * returns d0=-1 C=1 if FAC1 < FAC2
00B01ED6                          6029  
00B01ED6                          6030  LAB_27F0
00B01ED6  7000                    6031      MOVEQ       #0,d0               * set for FAC1 = FAC2
00B01ED8  122B 0600               6032      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00B01EDC  B22B 05F8               6033      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00B01EE0  660A                    6034      BNE.s       LAB_27F1            * branch if different
00B01EE2                          6035  
00B01EE2  222B 05FC               6036      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00B01EE6  B2AB 05F4               6037      CMP.l       FAC1_m(a3),d1       * compare mantissas
00B01EEA  6708                    6038      BEQ.s       LAB_27F3            * exit if mantissas equal
00B01EEC                          6039  
00B01EEC                          6040  LAB_27F1
00B01EEC  6504                    6041      BCS.s       LAB_27F2            * if FAC1 > FAC2 return d0=+1,C=0
00B01EEE                          6042  
00B01EEE  5380                    6043      SUBQ.l  #1,d0               * else FAC1 < FAC2 return d0=-1,C=1
00B01EF0  4E75                    6044      RTS
00B01EF2                          6045  
00B01EF2                          6046  LAB_27F2
00B01EF2  5280                    6047      ADDQ.l  #1,d0
00B01EF4                          6048  LAB_27F3
00B01EF4  4E75                    6049      RTS
00B01EF6                          6050  
00B01EF6                          6051  
00B01EF6                          6052  *************************************************************************************
00B01EF6                          6053  *
00B01EF6                          6054  * make FAC1 = 1
00B01EF6                          6055  
00B01EF6                          6056  LAB_POON
00B01EF6  277C 80000000 05F4      6057      MOVE.l  #$80000000,FAC1_m(a3)   * 1 mantissa
00B01EFE  377C 8100 05F8          6058      MOVE.w  #$8100,FAC1_e(a3)       * 1 exonent & sign
00B01F04  4E75                    6059      RTS
00B01F06                          6060  
00B01F06                          6061  
00B01F06                          6062  *************************************************************************************
00B01F06                          6063  *
00B01F06                          6064  * make FAC1 = 0
00B01F06                          6065  
00B01F06                          6066  LAB_POZE
00B01F06  7000                    6067      MOVEQ       #0,d0               * clear longword
00B01F08  2740 05F4               6068      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00B01F0C  3740 05F8               6069      MOVE.w  d0,FAC1_e(a3)       * 0 exonent & sign
00B01F10  4E75                    6070      RTS
00B01F12                          6071  
00B01F12                          6072  
00B01F12                          6073  *************************************************************************************
00B01F12                          6074  *
00B01F12                          6075  * perform power function
00B01F12                          6076  * the number is in FAC2, the power is in FAC1
00B01F12                          6077  * no longer trashes Itemp
00B01F12                          6078  
00B01F12                          6079  LAB_POWER
00B01F12  4A2B 05F8               6080      TST.b       FAC1_e(a3)          * test power
00B01F16  67DE                    6081      BEQ.s       LAB_POON            * if zero go return 1
00B01F18                          6082  
00B01F18  4A2B 0600               6083      TST.b       FAC2_e(a3)          * test number
00B01F1C  67E8                    6084      BEQ.s       LAB_POZE            * if zero go return 0
00B01F1E                          6085  
00B01F1E  1F2B 0601               6086      MOVE.b  FAC2_s(a3),-(sp)        * save number sign
00B01F22  6A20                    6087      BPL.s       LAB_POWP            * power of positive number
00B01F24                          6088  
00B01F24  7200                    6089      MOVEQ       #0,d1               * clear d1
00B01F26  1741 0601               6090      MOVE.b  d1,FAC2_s(a3)       * make sign +ve
00B01F2A                          6091  
00B01F2A                          6092                              * number sign was -ve and can only be raised to
00B01F2A                          6093                              * an integer power which gives an x +j0 result,
00B01F2A                          6094                              * else do 'function call' error
00B01F2A  122B 05F8               6095      MOVE.b  FAC1_e(a3),d1       * get power exponent
00B01F2E  0441 0080               6096      SUB.w       #$80,d1         * normalise to .5
00B01F32  6300 E22A               6097      BLS     LAB_FCER            * if 0<power<1 then do 'function call' error
00B01F36                          6098  
00B01F36                          6099                              * now shift all the integer bits out
00B01F36  202B 05F4               6100      MOVE.l  FAC1_m(a3),d0       * get power mantissa
00B01F3A  E3A0                    6101      ASL.l       d1,d0               * shift mantissa
00B01F3C  6600 E220               6102      BNE     LAB_FCER            * if power<>INT(power) then do 'function call'
00B01F40                          6103                              * error
00B01F40                          6104  
00B01F40  6502                    6105      BCS.s       LAB_POWP            * if integer value odd then leave result -ve
00B01F42                          6106  
00B01F42  1E80                    6107      MOVE.b  d0,(sp)         * save result sign +ve
00B01F44                          6108  LAB_POWP
00B01F44  2F2B 05F4               6109      MOVE.l  FAC1_m(a3),-(sp)        * save power mantissa
00B01F48  3F2B 05F8               6110      MOVE.w  FAC1_e(a3),-(sp)        * save power sign & exponent
00B01F4C                          6111  
00B01F4C  6100 FC78               6112      BSR     LAB_279B            * copy number to FAC1
00B01F50  6100 F9E8               6113      BSR     LAB_LOG         * find log of number
00B01F54                          6114  
00B01F54  301F                    6115      MOVE.w  (sp)+,d0            * get power sign & exponent
00B01F56  275F 05FC               6116      MOVE.l  (sp)+,FAC2_m(a3)        * get power mantissa
00B01F5A  3740 0600               6117      MOVE.w  d0,FAC2_e(a3)       * save sign & exponent to FAC2
00B01F5E  1740 0602               6118      MOVE.b  d0,FAC_sc(a3)       * save sign as sign compare
00B01F62  102B 05F9               6119      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00B01F66  B12B 0602               6120      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00B01F6A                          6121  
00B01F6A  6100 FAC0               6122      BSR     LAB_MULTIPLY        * multiply by power
00B01F6E  6158                    6123      BSR.s       LAB_EXP         * find exponential
00B01F70  175F 05F9               6124      MOVE.b  (sp)+,FAC1_s(a3)        * restore number sign
00B01F74  4E75                    6125      RTS
00B01F76                          6126  
00B01F76                          6127  
00B01F76                          6128  *************************************************************************************
00B01F76                          6129  *
00B01F76                          6130  * do - FAC1
00B01F76                          6131  
00B01F76                          6132  LAB_GTHAN
00B01F76  4A2B 05F8               6133      TST.b       FAC1_e(a3)          * test for non zero FAC1
00B01F7A  6706                    6134      BEQ.s       RTS_020         * branch if null
00B01F7C                          6135  
00B01F7C  0A2B 0080 05F9          6136      EORI.b  #$80,FAC1_s(a3)     * (else) toggle FAC1 sign bit
00B01F82                          6137  RTS_020
00B01F82  4E75                    6138      RTS
00B01F84                          6139  
00B01F84                          6140  
00B01F84                          6141  *************************************************************************************
00B01F84                          6142  *
00B01F84                          6143                              * return +1
00B01F84                          6144  LAB_EX1
00B01F84  277C 80000000 05F4      6145      MOVE.l  #$80000000,FAC1_m(a3)   * +1 mantissa
00B01F8C  377C 8100 05F8          6146      MOVE.w  #$8100,FAC1_e(a3)       * +1 sign & exponent
00B01F92  4E75                    6147      RTS
00B01F94                          6148                              * do over/under flow
00B01F94                          6149  LAB_EXOU
00B01F94  4A2B 05F9               6150      TST.b       FAC1_s(a3)          * test sign
00B01F98  6A00 E1C0               6151      BPL     LAB_OFER            * was +ve so do overflow error
00B01F9C                          6152  
00B01F9C                          6153                              * else underflow so return zero
00B01F9C  7000                    6154      MOVEQ       #0,d0               * clear longword
00B01F9E  2740 05F4               6155      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00B01FA2  3740 05F8               6156      MOVE.w  d0,FAC1_e(a3)       * 0 sign & exponent
00B01FA6  4E75                    6157      RTS
00B01FA8                          6158                              * fraction was zero so do 2^n
00B01FA8                          6159  LAB_EXOF
00B01FA8  277C 80000000 05F4      6160      MOVE.l  #$80000000,FAC1_m(a3)   * +n mantissa
00B01FB0  177C 0000 05F9          6161      MOVE.b  #0,FAC1_s(a3)       * clear sign
00B01FB6  4A2B 0618               6162      TST.b       cosout(a3)          * test sign flag
00B01FBA  6A02                    6163      BPL.s       LAB_EXOL            * branch if +ve
00B01FBC                          6164  
00B01FBC  4481                    6165      NEG.l       d1              * else do 1/2^n
00B01FBE                          6166  LAB_EXOL
00B01FBE  0601 0081               6167      ADD.b       #$81,d1         * adjust exponent
00B01FC2  1741 05F8               6168      MOVE.b  d1,FAC1_e(a3)       * save exponent
00B01FC6  4E75                    6169      RTS
00B01FC8                          6170  
00B01FC8                          6171  * perform EXP() (x^e)
00B01FC8                          6172  * valid input range is -88 to +88
00B01FC8                          6173  
00B01FC8                          6174  LAB_EXP
00B01FC8  102B 05F8               6175      MOVE.b  FAC1_e(a3),d0       * get exponent
00B01FCC  67B6                    6176      BEQ.s       LAB_EX1         * return 1 for zero in
00B01FCE                          6177  
00B01FCE  B03C 0064               6178      CMP.b       #$64,d0         * compare exponent with min
00B01FD2  65B0                    6179      BCS.s       LAB_EX1         * if smaller just return 1
00B01FD4                          6180  
00B01FD4                          6181  **  MOVEM.l d1-d6/a0,-(sp)      * save the registers
00B01FD4  177C 0000 0618          6182      MOVE.b  #0,cosout(a3)       * flag +ve number
00B01FDA  222B 05F4               6183      MOVE.l  FAC1_m(a3),d1       * get mantissa
00B01FDE  B03C 0087               6184      CMP.b       #$87,d0         * compare exponent with max
00B01FE2  62B0                    6185      BHI.s       LAB_EXOU            * go do over/under flow if greater
00B01FE4                          6186  
00B01FE4  6608                    6187      BNE.s       LAB_EXCM            * branch if less
00B01FE6                          6188  
00B01FE6                          6189                              * else is 2^7
00B01FE6  B2BC B00F33C7           6190      CMP.l       #$B00F33C7,d1       * compare mantissa with n*2^7 max
00B01FEC  64A6                    6191      BCC.s       LAB_EXOU            * if => go over/underflow
00B01FEE                          6192  
00B01FEE                          6193  LAB_EXCM
00B01FEE  4A2B 05F9               6194      TST.b       FAC1_s(a3)          * test sign
00B01FF2  6A0C                    6195      BPL.s       LAB_EXPS            * branch if arg +ve
00B01FF4                          6196  
00B01FF4  177C 00FF 0618          6197      MOVE.b  #$FF,cosout(a3)     * flag -ve number
00B01FFA  177C 0000 05F9          6198      MOVE.b  #0,FAC1_s(a3)       * take absolute value
00B02000                          6199  LAB_EXPS
00B02000                          6200                              * now do n/LOG(2)
00B02000  277C B8AA3B29 05FC      6201      MOVE.l  #$B8AA3B29,FAC2_m(a3)   * 1/LOG(2) mantissa
00B02008  377C 8100 0600          6202      MOVE.w  #$8100,FAC2_e(a3)       * 1/LOG(2) exponent & sign
00B0200E  177C 0000 0602          6203      MOVE.b  #0,FAC_sc(a3)       * we know they're both +ve
00B02014  6100 FA16               6204      BSR     LAB_MULTIPLY        * effectively divide by log(2)
00B02018                          6205  
00B02018                          6206                              * max here is +/- 127
00B02018                          6207                              * now separate integer and fraction
00B02018  177C 0000 063D          6208      MOVE.b  #0,tpower(a3)       * clear exponent add byte
00B0201E  1A2B 05F8               6209      MOVE.b  FAC1_e(a3),d5       * get exponent
00B02022  0405 0080               6210      SUB.b       #$80,d5         * normalise
00B02026  6324                    6211      BLS.s       LAB_ESML            * branch if < 1 (d5 is 0 or -ve)
00B02028                          6212  
00B02028                          6213                              * result is > 1
00B02028  202B 05F4               6214      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B0202C  2200                    6215      MOVE.l  d0,d1               * copy it
00B0202E  2C05                    6216      MOVE.l  d5,d6               * copy normalised exponent
00B02030                          6217  
00B02030  4446                    6218      NEG.w       d6              * make -ve
00B02032  0646 0020               6219      ADD.w       #32,d6          * is now 32-d6
00B02036  ECA9                    6220      LSR.l       d6,d1               * just integer bits
00B02038  1741 063D               6221      MOVE.b  d1,tpower(a3)       * set exponent add byte
00B0203C                          6222  
00B0203C  EBA8                    6223      LSL.l       d5,d0               * shift out integer bits
00B0203E  6700 FF68               6224      BEQ     LAB_EXOF            * fraction is zero so do 2^n
00B02042                          6225  
00B02042  2740 05F4               6226      MOVE.l  d0,FAC1_m(a3)       * fraction to FAC1
00B02046  377C 8000 05F8          6227      MOVE.w  #$8000,FAC1_e(a3)       * set exponent & sign
00B0204C                          6228  
00B0204C                          6229                              * multiple was < 1
00B0204C                          6230  LAB_ESML
00B0204C  277C B17217F8 05FC      6231      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00B02054  377C 8000 0600          6232      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00B0205A  177C 0000 0602          6233      MOVE.b  #0,FAC_sc(a3)       * clear sign compare
00B02060  6100 F9CA               6234      BSR     LAB_MULTIPLY        * multiply by log(2)
00B02064                          6235  
00B02064  202B 05F4               6236      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B02068  1A2B 05F8               6237      MOVE.b  FAC1_e(a3),d5       * get exponent
00B0206C  0445 0082               6238      SUB.w       #$82,d5         * normalise and -2 (result is -1 to -30)
00B02070  4445                    6239      NEG.w       d5              * make +ve
00B02072  EAA8                    6240      LSR.l       d5,d0               * shift for 2 integer bits
00B02074                          6241  
00B02074                          6242  * d0 = arg
00B02074                          6243  * d6 = x, d1 = y
00B02074                          6244  * d2 = x1, d3 = y1
00B02074                          6245  * d4 = shift count
00B02074                          6246  * d5 = loop count
00B02074                          6247                              * now do cordic set-up
00B02074  7200                    6248      MOVEQ       #0,d1               * y = 0
00B02076  2C3C 26A3D110           6249      MOVE.l  #KFCTSEED,d6        * x = 1 with jkh inverse factored out
00B0207C  41FA 0D2A               6250      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic arctan table
00B02080  7800                    6251      MOVEQ       #0,d4               * clear shift count
00B02082                          6252   
00B02082                          6253                              * cordic loop, shifts 4 and 13 (and 39
00B02082                          6254                              * if it went that far) need to be repeated
00B02082  7A03                    6255      MOVEQ       #3,d5               * 4 loops
00B02084  6136                    6256      BSR.s       LAB_EXCC            * do loops 1 through 4
00B02086  5948                    6257      SUBQ.w  #4,a0               * do table entry again
00B02088  5384                    6258      SUBQ.l  #1,d4               * do shift count again
00B0208A  7A09                    6259      MOVEQ       #9,d5               * 10 loops
00B0208C  612E                    6260      BSR.s       LAB_EXCC            * do loops 4 (again) through 13
00B0208E  5948                    6261      SUBQ.w  #4,a0               * do table entry again
00B02090  5384                    6262      SUBQ.l  #1,d4               * do shift count again
00B02092  7A12                    6263      MOVEQ       #18,d5          * 19 loops
00B02094  6126                    6264      BSR.s       LAB_EXCC            * do loops 13 (again) through 31
00B02096                          6265   
00B02096                          6266                              * now get the result
00B02096  4A2B 0618               6267      TST.b       cosout(a3)          * test sign flag
00B0209A  6A06                    6268      BPL.s       LAB_EXPL            * branch if +ve
00B0209C                          6269  
00B0209C  4481                    6270      NEG.l       d1              * do -y
00B0209E  442B 063D               6271      NEG.b       tpower(a3)          * do -exp
00B020A2                          6272  LAB_EXPL
00B020A2  7083                    6273      MOVEQ       #$83-$100,d0        * set exponent
00B020A4  DC81                    6274      ADD.l       d1,d6               * y = y +/- x
00B020A6  6B06                    6275      BMI.s       LAB_EXRN            * branch if result normal
00B020A8                          6276  
00B020A8                          6277  LAB_EXNN
00B020A8  5380                    6278      SUBQ.l  #1,d0               * decrement exponent
00B020AA  DC86                    6279      ADD.l       d6,d6               * shift mantissa
00B020AC  6AFA                    6280      BPL.s       LAB_EXNN            * loop if not normal
00B020AE                          6281  
00B020AE                          6282  LAB_EXRN
00B020AE  2746 05F4               6283      MOVE.l  d6,FAC1_m(a3)       * save exponent result
00B020B2  D02B 063D               6284      ADD.b       tpower(a3),d0       * add integer part
00B020B6  1740 05F8               6285      MOVE.b  d0,FAC1_e(a3)       * save exponent
00B020BA                          6286  **  MOVEM.l (sp)+,d1-d6/a0      * restore registers
00B020BA  4E75                    6287      RTS
00B020BC                          6288   
00B020BC                          6289                              * cordic loop
00B020BC                          6290  LAB_EXCC
00B020BC  5284                    6291      ADDQ.l  #1,d4               * increment shift count
00B020BE  2406                    6292      MOVE.l  d6,d2               * x1 = x
00B020C0  E8A2                    6293      ASR.l       d4,d2               * x1 >> n
00B020C2  2601                    6294      MOVE.l  d1,d3               * y1 = y
00B020C4  E8A3                    6295      ASR.l       d4,d3               * y1 >> n
00B020C6  4A80                    6296      TST.l       d0              * test arg
00B020C8  6B0C                    6297      BMI.s       LAB_EXAD            * branch if -ve
00B020CA                          6298  
00B020CA  D282                    6299      ADD.l       d2,d1               * y = y + x1
00B020CC  DC83                    6300      ADD.l       d3,d6               * x = x + y1
00B020CE  9098                    6301      SUB.l       (a0)+,d0            * arg = arg - atnh(a0)
00B020D0  51CD FFEA               6302      DBF     d5,LAB_EXCC         * decrement and loop if not done
00B020D4                          6303  
00B020D4  4E75                    6304      RTS
00B020D6                          6305  
00B020D6                          6306  LAB_EXAD
00B020D6  9282                    6307      SUB.l       d2,d1               * y = y - x1
00B020D8  9C83                    6308      SUB.l       d3,d6               * x = x + y1
00B020DA  D098                    6309      ADD.l       (a0)+,d0            * arg = arg + atnh(a0)
00B020DC  51CD FFDE               6310      DBF     d5,LAB_EXCC         * decrement and loop if not done
00B020E0                          6311  
00B020E0  4E75                    6312      RTS
00B020E2                          6313  
00B020E2                          6314  
00B020E2                          6315  *************************************************************************************
00B020E2                          6316  *
00B020E2                          6317  * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
00B020E2                          6318  * to get 19th next number in sequence after seed n. This version of the PRNG uses
00B020E2                          6319  * the Galois method and a sample of 65536 bytes produced gives the following values.
00B020E2                          6320  
00B020E2                          6321  * Entropy = 7.997442 bits per byte
00B020E2                          6322  * Optimum compression would reduce these 65536 bytes by 0 percent
00B020E2                          6323  
00B020E2                          6324  * Chi square distribution for 65536 samples is 232.01, and
00B020E2                          6325  * randomly would exceed this value 75.00 percent of the time
00B020E2                          6326  
00B020E2                          6327  * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00B020E2                          6328  * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00B020E2                          6329  * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00B020E2                          6330  
00B020E2                          6331  LAB_RND
00B020E2  4A2B 05F8               6332      TST.b       FAC1_e(a3)          * get FAC1 exponent
00B020E6  6708                    6333      BEQ.s       NextPRN         * do next random number if zero
00B020E8                          6334  
00B020E8                          6335                              * else get seed into random number store
00B020E8  41EB 0604               6336      LEA     PRNlword(a3),a0     * set PRNG pointer
00B020EC  6100 FAB2               6337      BSR     LAB_2778            * pack FAC1 into (a0)
00B020F0                          6338  NextPRN
00B020F0  72AF                    6339      MOVEQ       #$AF-$100,d1        * set EOR value
00B020F2  7412                    6340      MOVEQ       #18,d2          * do this 19 times
00B020F4  202B 0604               6341      MOVE.l  PRNlword(a3),d0     * get current
00B020F8                          6342  Ninc0
00B020F8  D080                    6343      ADD.l       d0,d0               * shift left 1 bit
00B020FA  6402                    6344      BCC.s       Ninc1               * branch if bit 32 not set
00B020FC                          6345  
00B020FC  B300                    6346      EOR.b       d1,d0               * do Galois LFSR feedback
00B020FE                          6347  Ninc1
00B020FE  51CA FFF8               6348      DBF     d2,Ninc0            * loop
00B02102                          6349  
00B02102  2740 0604               6350      MOVE.l  d0,PRNlword(a3)     * save back to seed word
00B02106  2740 05F4               6351      MOVE.l  d0,FAC1_m(a3)       * copy to FAC1 mantissa
00B0210A  377C 8000 05F8          6352      MOVE.w  #$8000,FAC1_e(a3)       * set the exponent and clear the sign
00B02110  6000 F7F2               6353      BRA     LAB_24D5            * normalise FAC1 & return
00B02114                          6354  
00B02114                          6355  
00B02114                          6356  *************************************************************************************
00B02114                          6357  *
00B02114                          6358  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
00B02114                          6359  * x = angle in radians
00B02114                          6360  
00B02114                          6361  LAB_TAN
00B02114  6138                    6362      BSR.s       LAB_SIN         * go do SIN/COS cordic compute
00B02116  376B 05F8 0600          6363      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00B0211C  276B 05F4 05FC          6364      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00B02122  2741 05F4               6365      MOVE.l  d1,FAC1_m(a3)       * get COS(x) mantissa
00B02126  1743 05F8               6366      MOVE.b  d3,FAC1_e(a3)       * get COS(x) exponent
00B0212A  6700 E02E               6367      BEQ     LAB_OFER            * do overflow if COS = 0
00B0212E                          6368  
00B0212E  6100 F7D4               6369      BSR     LAB_24D5            * normalise FAC1
00B02132  6000 F984               6370      BRA     LAB_DIVIDE          * do FAC2/FAC1 and return, FAC_sc set by SIN
00B02136                          6371                              * COS calculation
00B02136                          6372  
00B02136                          6373  
00B02136                          6374  *************************************************************************************
00B02136                          6375  *
00B02136                          6376  * cordic SIN(x), COS(x) routine
00B02136                          6377  * x = angle in radians
00B02136                          6378  
00B02136                          6379  LAB_COS
00B02136  277C C90FDAA3 05FC      6380      MOVE.l  #$C90FDAA3,FAC2_m(a3)   * pi/2 mantissa (LSB is rounded up so
00B0213E                          6381                              * COS(PI/2)=0)
00B0213E  377C 8100 0600          6382      MOVE.w  #$8100,FAC2_e(a3)       * pi/2 exponent and sign
00B02144  176B 05F9 0602          6383      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00B0214A  6100 F73C               6384      BSR     LAB_ADD         * add FAC2 to FAC1, adjust for COS(x)
00B0214E                          6385  
00B0214E                          6386  
00B0214E                          6387  *************************************************************************************
00B0214E                          6388  *
00B0214E                          6389  * SIN/COS cordic calculator
00B0214E                          6390  
00B0214E                          6391  LAB_SIN
00B0214E  177C 0000 0618          6392      MOVE.b  #0,cosout(a3)       * set needed result
00B02154                          6393  
00B02154  277C A2F9836F 05FC      6394      MOVE.l  #$A2F9836F,FAC2_m(a3)   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
00B0215C  377C 7F00 0600          6395      MOVE.w  #$7F00,FAC2_e(a3)       * 1/pi exponent & sign
00B02162  176B 05F9 0602          6396      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00B02168  6100 F8C2               6397      BSR     LAB_MULTIPLY        * multiply by 1/pi
00B0216C                          6398  
00B0216C  102B 05F8               6399      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B02170  671C                    6400      BEQ.s       LAB_SCZE            * branch if zero
00B02172                          6401  
00B02172  41FA 0B34               6402      LEA     TAB_SNCO(pc),a0     * get pointer to constants table
00B02176  2C2B 05F4               6403      MOVE.l  FAC1_m(a3),d6       * get FAC1 mantissa
00B0217A  5300                    6404      SUBQ.b  #1,d0               * 2 radians in 360 degrees so /2
00B0217C  6710                    6405      BEQ.s       LAB_SCZE            * branch if zero
00B0217E                          6406  
00B0217E  0400 0080               6407      SUB.b       #$80,d0         * normalise exponent
00B02182  6B18                    6408      BMI.s       LAB_SCL0            * branch if < 1
00B02184                          6409  
00B02184                          6410                              * X is > 1
00B02184  B03C 0020               6411      CMP.b       #$20,d0         * is it >= 2^32
00B02188  6404                    6412      BCC.s       LAB_SCZE            * may as well do zero
00B0218A                          6413  
00B0218A  E1AE                    6414      LSL.l       d0,d6               * shift out integer part bits
00B0218C  6618                    6415      BNE.s       LAB_CORD            * if fraction go test quadrant and adjust
00B0218E                          6416  
00B0218E                          6417                              * else no fraction so do zero
00B0218E                          6418  LAB_SCZE
00B0218E  7481                    6419      MOVEQ       #$81-$100,d2        * set exponent for 1.0
00B02190  7600                    6420      MOVEQ       #0,d3               * set exponent for 0.0
00B02192  203C 80000000           6421      MOVE.l  #$80000000,d0       * mantissa for 1.0
00B02198  2203                    6422      MOVE.l  d3,d1               * mantissa for 0.0
00B0219A  6062                    6423      BRA.s       outloop         * go output it
00B0219C                          6424  
00B0219C                          6425                              * x is < 1
00B0219C                          6426  LAB_SCL0
00B0219C  4400                    6427      NEG.b       d0              * make +ve
00B0219E  B03C 001E               6428      CMP.b       #$1E,d0         * is it <= 2^-30
00B021A2  64EA                    6429      BCC.s       LAB_SCZE            * may as well do zero
00B021A4                          6430  
00B021A4  E0AE                    6431      LSR.l       d0,d6               * shift out <= 2^-32 bits
00B021A6                          6432  
00B021A6                          6433  * cordic calculator, argument in d6
00B021A6                          6434  * table pointer in a0, returns in d0-d3
00B021A6                          6435  
00B021A6                          6436  LAB_CORD
00B021A6  176B 05F9 0602          6437      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * copy as sign compare for TAN
00B021AC  DC86                    6438      ADD.l       d6,d6               * shift 0.5 bit into carry
00B021AE  6406                    6439      BCC.s       LAB_LTPF            * branch if less than 0.5
00B021B0                          6440  
00B021B0  0A2B 00FF 05F9          6441      EORI.b  #$FF,FAC1_s(a3)     * toggle result sign
00B021B6                          6442  LAB_LTPF
00B021B6  DC86                    6443      ADD.l       d6,d6               * shift 0.25 bit into carry
00B021B8  640C                    6444      BCC.s       LAB_LTPT            * branch if less than 0.25
00B021BA                          6445  
00B021BA  0A2B 00FF 0618          6446      EORI.b  #$FF,cosout(a3)     * toggle needed result
00B021C0  0A2B 00FF 0602          6447      EORI.b  #$FF,FAC_sc(a3)     * toggle sign compare for TAN
00B021C6                          6448  
00B021C6                          6449  LAB_LTPT
00B021C6  E48E                    6450      LSR.l       #2,d6               * shift the bits back (clear integer bits)
00B021C8  67C4                    6451      BEQ.s       LAB_SCZE            * no fraction so go do zero
00B021CA                          6452  
00B021CA                          6453                              * set start values
00B021CA  7A01                    6454      MOVEQ       #1,d5               * set bit count
00B021CC  2028 FFFC               6455      MOVE.l  -4(a0),d0           * get multiply constant (1st itteration d0)
00B021D0  2200                    6456      MOVE.l  d0,d1               * 1st itteration d1
00B021D2  9C98                    6457      SUB.l       (a0)+,d6            * 1st always +ve so do 1st step
00B021D4  6008                    6458      BRA.s       mainloop            * jump into routine
00B021D6                          6459  
00B021D6                          6460  subloop
00B021D6  9C98                    6461      SUB.l       (a0)+,d6            * z = z - arctan(i)/2pi
00B021D8  9083                    6462      SUB.l       d3,d0               * x = x - y1
00B021DA  D282                    6463      ADD.l       d2,d1               * y = y + x1
00B021DC  6012                    6464      BRA.s       nexta               * back to main loop
00B021DE                          6465  
00B021DE                          6466  mainloop
00B021DE  2400                    6467      MOVE.l  d0,d2               * x1 = x
00B021E0  EAA2                    6468      ASR.l       d5,d2               * / (2 ^ i)
00B021E2  2601                    6469      MOVE.l  d1,d3               * y1 = y
00B021E4  EAA3                    6470      ASR.l       d5,d3               * / (2 ^ i)
00B021E6  4A86                    6471      TST.l       d6              * test sign (is 2^0 bit)
00B021E8  6AEC                    6472      BPL.s       subloop         * go do subtract if > 1
00B021EA                          6473  
00B021EA  DC98                    6474      ADD.l       (a0)+,d6            * z = z + arctan(i)/2pi
00B021EC  D083                    6475      ADD.l       d3,d0               * x = x + y1
00B021EE  9282                    6476      SUB.l       d2,d1               * y = y + x1
00B021F0                          6477  nexta
00B021F0  5285                    6478      ADDQ.l  #1,d5               * i = i + 1
00B021F2  BABC 0000001E           6479      CMP.l       #$1E,d5         * check end condition
00B021F8  66E4                    6480      BNE.s       mainloop            * loop if not all done
00B021FA                          6481  
00B021FA                          6482                              * now untangle output value
00B021FA  7481                    6483      MOVEQ       #$81-$100,d2        * set exponent for 0 to .99 rec.
00B021FC  2602                    6484      MOVE.l  d2,d3               * copy it for cos output
00B021FE                          6485  outloop
00B021FE  4A2B 0618               6486      TST.b       cosout(a3)          * did we want cos output?
00B02202  6B04                    6487      BMI.s       subexit         * if so skip
00B02204                          6488  
00B02204  C141                    6489      EXG     d0,d1               * swap SIN and COS mantissas
00B02206  C543                    6490      EXG     d2,d3               * swap SIN and COS exponents
00B02208                          6491  subexit
00B02208  2740 05F4               6492      MOVE.l  d0,FAC1_m(a3)       * set result mantissa
00B0220C  1742 05F8               6493      MOVE.b  d2,FAC1_e(a3)       * set result exponent
00B02210  6000 F6F2               6494      BRA     LAB_24D5            * normalise FAC1 & return
00B02214                          6495  
00B02214                          6496  
00B02214                          6497  
00B02214                          6498  *************************************************************************************
00B02214                          6499  *
00B02214                          6500  * perform ATN()
00B02214                          6501  
00B02214                          6502  LAB_ATN
00B02214  102B 05F8               6503      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00B02218  6700 00AA               6504      BEQ     RTS_021         * ATN(0) = 0 so skip calculation
00B0221C                          6505  
00B0221C  177C 0000 0618          6506      MOVE.b  #0,cosout(a3)       * set result needed
00B02222  B03C 0081               6507      CMP.b       #$81,d0         * compare exponent with 1
00B02226  6528                    6508      BCS.s       LAB_ATLE            * branch if n<1
00B02228                          6509  
00B02228  6608                    6510      BNE.s       LAB_ATGO            * branch if n>1
00B0222A                          6511  
00B0222A  202B 05F4               6512      MOVE.l  FAC1_m(a3),d0       * get mantissa
00B0222E  D080                    6513      ADD.l       d0,d0               * shift left
00B02230  671E                    6514      BEQ.s       LAB_ATLE            * branch if n=1
00B02232                          6515  
00B02232                          6516  LAB_ATGO
00B02232  277C 80000000 05FC      6517      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00B0223A  377C 8100 0600          6518      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00B02240  176B 05F9 0602          6519      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00B02246  6100 F870               6520      BSR     LAB_DIVIDE          * do 1/n
00B0224A  177C 00FF 0618          6521      MOVE.b  #$FF,cosout(a3)     * set inverse result needed
00B02250                          6522  LAB_ATLE
00B02250  202B 05F4               6523      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00B02254  7282                    6524      MOVEQ       #$82,d1         * set to correct exponent
00B02256  922B 05F8               6525      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent (always <= 1)
00B0225A  E2A8                    6526      LSR.l       d1,d0               * shift in two integer part bits
00B0225C  41FA 0ACA               6527      LEA     TAB_ATNC(pc),a0     * get pointer to arctan table
00B02260  7C00                    6528      MOVEQ       #0,d6               * Z = 0
00B02262  223C 40000000           6529      MOVE.l  #1<<30,d1           * y = 1
00B02268  7A1D                    6530      MOVEQ       #29,d5          * loop 30 times
00B0226A  7801                    6531      MOVEQ       #1,d4               * shift counter
00B0226C  6006                    6532      BRA.s       LAB_ATCD            * enter loop
00B0226E                          6533  
00B0226E                          6534  LAB_ATNP
00B0226E  E8A2                    6535      ASR.l       d4,d2               * x1 / 2^i
00B02270  D282                    6536      ADD.l       d2,d1               * y = y + x1
00B02272  DC90                    6537      ADD.l       (a0),d6         * z = z + atn(i)
00B02274                          6538  LAB_ATCD
00B02274  2400                    6539      MOVE.l  d0,d2               * x1 = x
00B02276  2601                    6540      MOVE.l  d1,d3               * y1 = y
00B02278  E8A3                    6541      ASR.l       d4,d3               * y1 / 2^i
00B0227A                          6542  LAB_CATN
00B0227A  9083                    6543      SUB.l       d3,d0               * x = x - y1
00B0227C  6AF0                    6544      BPL.s       LAB_ATNP            * branch if x >= 0
00B0227E                          6545  
00B0227E  2002                    6546      MOVE.l  d2,d0               * else get x back
00B02280  5848                    6547      ADDQ.w  #4,a0               * increment pointer
00B02282  5284                    6548      ADDQ.l  #1,d4               * increment i
00B02284  E283                    6549      ASR.l       #1,d3               * y1 / 2^i
00B02286  51CD FFF2               6550      DBF     d5,LAB_CATN         * decrement and loop if not done
00B0228A                          6551  
00B0228A  177C 0082 05F8          6552      MOVE.b  #$82,FAC1_e(a3)     * set new exponent
00B02290  2746 05F4               6553      MOVE.l  d6,FAC1_m(a3)       * save mantissa
00B02294  6100 F66E               6554      BSR     LAB_24D5            * normalise FAC1
00B02298                          6555  
00B02298  4A2B 0618               6556      TST.b       cosout(a3)          * was it > 1 ?
00B0229C  6A26                    6557      BPL.s       RTS_021         * branch if not
00B0229E                          6558  
00B0229E  1E2B 05F9               6559      MOVE.b  FAC1_s(a3),d7       * get sign
00B022A2  177C 0000 05F9          6560      MOVE.b  #0,FAC1_s(a3)       * clear sign
00B022A8  277C C90FDAA2 05FC      6561      MOVE.l  #$C90FDAA2,FAC2_m(a3)   * set -(pi/2)
00B022B0  377C 8180 0600          6562      MOVE.w  #$8180,FAC2_e(a3)       * set exponent and sign
00B022B6  177C 00FF 0602          6563      MOVE.b  #$FF,FAC_sc(a3)     * set sign compare
00B022BC  6100 F5CA               6564      BSR     LAB_ADD         * perform addition, FAC2 to FAC1
00B022C0  1747 05F9               6565      MOVE.b  d7,FAC1_s(a3)       * restore sign
00B022C4                          6566  RTS_021
00B022C4  4E75                    6567      RTS
00B022C6                          6568  
00B022C6                          6569  
00B022C6                          6570  *************************************************************************************
00B022C6                          6571  *
00B022C6                          6572  * perform BITSET
00B022C6                          6573  
00B022C6                          6574  LAB_BITSET
00B022C6  6100 F4A0               6575      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00B022CA                          6576                              * first parameter in a0, second in d0
00B022CA  B03C 0008               6577      CMP.b       #$08,d0         * only 0 to 7 are allowed
00B022CE  6400 DE8E               6578      BCC     LAB_FCER            * branch if > 7
00B022D2                          6579  
00B022D2  01D0                    6580      BSET        d0,(a0)         * set bit
00B022D4  4E75                    6581      RTS
00B022D6                          6582  
00B022D6                          6583  
00B022D6                          6584  *************************************************************************************
00B022D6                          6585  *
00B022D6                          6586  * perform BITCLR
00B022D6                          6587  
00B022D6                          6588  LAB_BITCLR
00B022D6  6100 F490               6589      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00B022DA                          6590                              * first parameter in a0, second in d0
00B022DA  B03C 0008               6591      CMP.b       #$08,d0         * only 0 to 7 are allowed
00B022DE  6400 DE7E               6592      BCC     LAB_FCER            * branch if > 7
00B022E2                          6593  
00B022E2  0190                    6594      BCLR        d0,(a0)         * clear bit
00B022E4  4E75                    6595      RTS
00B022E6                          6596  
00B022E6                          6597  
00B022E6                          6598  *************************************************************************************
00B022E6                          6599  *
00B022E6                          6600  * perform BITTST()
00B022E6                          6601  
00B022E6                          6602  LAB_BTST
00B022E6  101D                    6603      MOVE.b  (a5)+,d0            * increment BASIC pointer
00B022E8  6100 F47E               6604      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00B022EC                          6605                              * first parameter in a0, second in d0
00B022EC  B03C 0008               6606      CMP.b       #$08,d0         * only 0 to 7 are allowed
00B022F0  6400 DE6C               6607      BCC     LAB_FCER            * branch if > 7
00B022F4                          6608  
00B022F4  2200                    6609      MOVE.l  d0,d1               * copy bit # to test
00B022F6  6100 EAB2               6610      BSR     LAB_GBYT            * get next BASIC byte
00B022FA  B03C 0029               6611      CMP.b       #')',d0         * is next character ")"
00B022FE  6600 DE6A               6612      BNE     LAB_SNER            * if not ")" go do syntax error, then warm start
00B02302                          6613  
00B02302  6100 EAA4               6614      BSR     LAB_IGBY            * update execute pointer (to character past ")")
00B02306  7000                    6615      MOVEQ       #0,d0               * set the result as zero
00B02308  0310                    6616      BTST        d1,(a0)         * test bit
00B0230A  6700 F90E               6617      BEQ     LAB_27DB            * branch if zero (already correct)
00B0230E                          6618  
00B0230E  70FF                    6619      MOVEQ       #-1,d0          * set for -1 result
00B02310  6000 F908               6620      BRA     LAB_27DB            * go do SGN tail
00B02314                          6621  
00B02314                          6622  
00B02314                          6623  *************************************************************************************
00B02314                          6624  *
00B02314                          6625  * perform USING$()
00B02314                          6626  
00B02314  =00000000               6627  fsd EQU  0                  *   (sp) format string descriptor pointer
00B02314  =00000004               6628  fsti    EQU  4                  *  4(sp) format string this index
00B02314  =00000006               6629  fsli    EQU  6                  *  6(sp) format string last index
00B02314  =00000008               6630  fsdpi   EQU  8                  *  8(sp) format string decimal point index
00B02314  =0000000A               6631  fsdc    EQU 10                  * 10(sp) format string decimal characters
00B02314  =00000008               6632  fend    EQU 12-4                    *  x(sp) end-4, fsd is popped by itself
00B02314                          6633  
00B02314  =00000023               6634  ofchr   EQU '#'                 * the overflow character
00B02314                          6635  
00B02314                          6636  LAB_USINGS
00B02314  4A2B 0619               6637      TST.b       Dtypef(a3)          * test data type, $80=string
00B02318  6A00 DDFC               6638      BPL     LAB_FOER            * if not string type go do format error
00B0231C                          6639  
00B0231C  246B 05F4               6640      MOVEA.l FAC1_m(a3),a2       * get the format string descriptor pointer
00B02320  3E2A 0004               6641      MOVE.w  4(a2),d7            * get the format string length
00B02324  6700 DDF0               6642      BEQ     LAB_FOER            * if null string go do format error
00B02328                          6643  
00B02328                          6644  * clear the format string values
00B02328                          6645  
00B02328  7000                    6646      MOVEQ       #0,d0               * clear d0
00B0232A  3F00                    6647      MOVE.w  d0,-(sp)            * clear the format string decimal characters
00B0232C  3F00                    6648      MOVE.w  d0,-(sp)            * clear the format string decimal point index
00B0232E  3F00                    6649      MOVE.w  d0,-(sp)            * clear the format string last index
00B02330  3F00                    6650      MOVE.w  d0,-(sp)            * clear the format string this index
00B02332  2F0A                    6651      MOVE.l  a2,-(sp)            * save the format string descriptor pointer
00B02334                          6652  
00B02334                          6653  * make a null return string for the first string add
00B02334                          6654  
00B02334  7200                    6655      MOVEQ       #0,d1               * make a null string
00B02336  2041                    6656      MOVEA.l d1,a0               * with a null pointer
00B02338  6100 F0CA               6657      BSR     LAB_RTST            * push a string on the descriptor stack
00B0233C                          6658                              * a0 = pointer, d1 = length
00B0233C                          6659  
00B0233C                          6660  * do the USING$() function next value
00B0233C                          6661  
00B0233C  101D                    6662      MOVE.b  (a5)+,d0            * get the next BASIC byte
00B0233E                          6663  LAB_U002
00B0233E  B03C 002C               6664      CMP.b       #',',d0         * compare with comma
00B02342  6600 DE26               6665      BNE     LAB_SNER            * if not "," go do syntax error
00B02346                          6666  
00B02346  6100 028E               6667      BSR     LAB_ProcFo          * process the format string
00B0234A  4A02                    6668      TST.b       d2              * test the special characters flag
00B0234C  6700 DDC8               6669      BEQ     LAB_FOER            * if no special characters go do format error
00B02350                          6670  
00B02350  6100 E8F6               6671      BSR     LAB_EVEX            * evaluate the expression
00B02354  4A2B 0619               6672      TST.b       Dtypef(a3)          * test the data type
00B02358  6B00 DDE4               6673      BMI     LAB_TMER            * if string type go do type missmatch error
00B0235C                          6674  
00B0235C  4A2B 05F8               6675      TST.b       FAC1_e(a3)          * test FAC1 exponent
00B02360  6732                    6676      BEQ.s       LAB_U004            * if FAC1 = 0 skip the rounding
00B02362                          6677  
00B02362  322F 000A               6678      MOVE.w  fsdc(sp),d1         * get the format string decimal character count
00B02366  B27C 0008               6679      CMP.w       #8,d1               * compare the fraction digit count with 8
00B0236A  6428                    6680      BCC.s       LAB_U004            * if >= 8 skip the rounding
00B0236C                          6681  
00B0236C  3001                    6682      MOVE.w  d1,d0               * else copy the fraction digit count
00B0236E  D241                    6683      ADD.w       d1,d1               * * 2
00B02370  D240                    6684      ADD.w       d0,d1               * * 3
00B02372  D241                    6685      ADD.w       d1,d1               * * 6
00B02374  41FA 0844               6686      LEA     LAB_P_10(pc),a0     * get the rounding table base
00B02378  2770 1002 05FC          6687      MOVE.l  2(a0,d1.w),FAC2_m(a3)   * get the rounding mantissa
00B0237E  3030 1000               6688      MOVE.w  (a0,d1.w),d0        * get the rounding exponent
00B02382  0440 0100               6689      SUB.w       #$100,d0            * effectively divide the mantissa by 2
00B02386  3740 0600               6690      MOVE.w  d0,FAC2_e(a3)       * save the rounding exponent
00B0238A  177C 0000 0602          6691      MOVE.b  #$00,FAC_sc(a3)     * clear the sign compare
00B02390  6100 F4F6               6692      BSR     LAB_ADD         * round the value to n places
00B02394                          6693  LAB_U004
00B02394  6100 F970               6694      BSR     LAB_2970            * convert FAC1 to string - not on stack
00B02398                          6695  
00B02398  6100 01FE               6696      BSR     LAB_DupFmt          * duplicate the processed format string section
00B0239C                          6697                              * returns length in d1, pointer in a0
00B0239C                          6698  
00B0239C                          6699  * process the number string, length in d6, decimal point index in d2
00B0239C                          6700  
00B0239C  45EB 062A               6701      LEA     Decss(a3),a2        * set the number string start
00B023A0  7C00                    6702      MOVEQ       #0,d6               * clear the number string index
00B023A2  782E                    6703      MOVEQ       #'.',d4         * set the decimal point character
00B023A4                          6704  LAB_U005
00B023A4  3406                    6705      MOVE.w  d6,d2               * save the index to flag the decimal point
00B023A6                          6706  LAB_U006
00B023A6  5246                    6707      ADDQ.w  #1,d6               * increment the number string index
00B023A8  1032 6000               6708      MOVE.b  (a2,d6.w),d0        * get a number string character
00B023AC  677A                    6709      BEQ.s       LAB_U010            * if null then number complete
00B023AE                          6710  
00B023AE  B03C 0045               6711      CMP.b       #'E',d0         * compare the character with an "E"
00B023B2  6706                    6712      BEQ.s       LAB_U008            * was sx[.x]Esxx so go handle sci notation
00B023B4                          6713  
00B023B4  B004                    6714      CMP.b       d4,d0               * compare the character with "."
00B023B6  66EE                    6715      BNE.s       LAB_U006            * if not decimal point go get the next digit
00B023B8                          6716  
00B023B8  60EA                    6717      BRA.s       LAB_U005            * go save the index and get the next digit
00B023BA                          6718  
00B023BA                          6719  * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
00B023BA                          6720  
00B023BA                          6721  LAB_U008
00B023BA  3606                    6722      MOVE.w  d6,d3               * copy the index to the "E"
00B023BC  5343                    6723      SUBQ.w  #1,d3               * -1 gives the last digit index
00B023BE                          6724  
00B023BE  5246                    6725      ADDQ.w  #1,d6               * increment the index to the exponent sign
00B023C0  1032 6000               6726      MOVE.b  (a2,d6.w),d0        * get the exponent sign character
00B023C4  B03C 002D               6727      CMP.b       #'-',d0         * compare the exponent sign with "-"
00B023C8  6600 DD94               6728      BNE     LAB_FCER            * if it wasn't sx[.x]E-xx go do function
00B023CC                          6729                              * call error
00B023CC                          6730  
00B023CC                          6731  * found an sx[.x]E-xx number so check the exponent magnitude
00B023CC                          6732  
00B023CC  5246                    6733      ADDQ.w  #1,d6               * increment the index to the exponent 10s
00B023CE  1032 6000               6734      MOVE.b  (a2,d6.w),d0        * get the exponent 10s character
00B023D2  B03C 0030               6735      CMP.b       #'0',d0         * compare the exponent 10s with "0"
00B023D6  6704                    6736      BEQ.s       LAB_U009            * if it was sx[.x]E-0x go get the exponent
00B023D8                          6737                              * 1s character
00B023D8                          6738  
00B023D8  700A                    6739      MOVEQ       #10,d0          * else start writing at index 10
00B023DA  6008                    6740      BRA.s       LAB_U00A            * go copy the digits
00B023DC                          6741  
00B023DC                          6742  * found an sx[.x]E-0x number so get the exponent magnitude
00B023DC                          6743  
00B023DC                          6744  LAB_U009
00B023DC  5246                    6745      ADDQ.w  #1,d6               * increment the index to the exponent 1s
00B023DE  700F                    6746      MOVEQ       #$0F,d0         * set the mask for the exponent 1s digit
00B023E0  C032 6000               6747      AND.b       (a2,d6.w),d0        * get and convert the exponent 1s digit
00B023E4                          6748  LAB_U00A
00B023E4  3403                    6749      MOVE.w  d3,d2               * copy the number last digit index
00B023E6  0C42 0001               6750      CMPI.w  #1,d2               * is the number of the form sxE-0x
00B023EA  6602                    6751      BNE.s       LAB_U00B            * if it is sx.xE-0x skip the increment
00B023EC                          6752  
00B023EC                          6753                              * else make room for the decimal point
00B023EC  5242                    6754      ADDQ.w  #1,d2               * add 1 to the write index
00B023EE                          6755  LAB_U00B
00B023EE  D440                    6756      ADD.w       d0,d2               * add the exponent 1s to the write index
00B023F0  700A                    6757      MOVEQ       #10,d0          * set the maximum write index
00B023F2  9042                    6758      SUB.w       d2,d0               * compare the index with the maximum
00B023F4  6E0C                    6759      BGT.s       LAB_U00C            * if the index < the maximum continue
00B023F6                          6760  
00B023F6  D440                    6761      ADD.w       d0,d2               * else set the index to the maximum
00B023F8  D640                    6762      ADD.w       d0,d3               * adjust the read index
00B023FA  0C43 0001               6763      CMPI.w  #1,d3               * compare the adjusted index with 1
00B023FE  6E02                    6764      BGT.s       LAB_U00C            * if > 1 continue
00B02400                          6765  
00B02400  7600                    6766      MOVEQ       #0,d3               * else allow for the decimal point
00B02402                          6767  LAB_U00C
00B02402  3C02                    6768      MOVE.w      d2,d6               * copy the write index as the number
00B02404                          6769                              * string length
00B02404  7000                    6770      MOVEQ       #0,d0               * clear d0 to null terminate the number
00B02406                          6771                              * string
00B02406                          6772  LAB_U00D
00B02406  1580 2000               6773      MOVE.b  d0,(a2,d2.w)        * save the character to the number string
00B0240A  5342                    6774      SUBQ.w  #1,d2               * decrement the number write index
00B0240C  0C42 0001               6775      CMPI.w  #1,d2               * compare the number write index with 1
00B02410  6712                    6776      BEQ.s       LAB_U00F            * if at the decimal point go save it
00B02412                          6777  
00B02412                          6778                              * else write a digit to the number string
00B02412  7030                    6779      MOVEQ       #'0',d0         * default to "0"
00B02414  4A43                    6780      TST.w       d3              * test the number read index
00B02416  67EE                    6781      BEQ.s       LAB_U00D            * if zero just go save the "0"
00B02418                          6782  
00B02418                          6783  LAB_U00E
00B02418  1032 3000               6784      MOVE.b  (a2,d3.w),d0        * read the next number digit
00B0241C  5343                    6785      SUBQ.w  #1,d3               * decrement the read index
00B0241E  B004                    6786      CMP.b       d4,d0               * compare the digit with "."
00B02420  66E4                    6787      BNE.s       LAB_U00D            * if not "." go save the digit
00B02422                          6788  
00B02422  60F4                    6789      BRA.s       LAB_U00E            * else go get the next digit
00B02424                          6790  
00B02424                          6791  LAB_U00F
00B02424  1584 2000               6792      MOVE.b  d4,(a2,d2.w)        * save the decimal point
00B02428                          6793  LAB_U010
00B02428  4A42                    6794      TST.w       d2              * test the number string decimal point index
00B0242A  6602                    6795      BNE.s       LAB_U014            * if dp present skip the reset
00B0242C                          6796  
00B0242C  3406                    6797      MOVE.w  d6,d2               * make the decimal point index = the length
00B0242E                          6798  
00B0242E                          6799  * copy the fractional digit characters from the number string
00B0242E                          6800  
00B0242E                          6801  LAB_U014
00B0242E  3602                    6802      MOVE.w  d2,d3               * copy the number string decimal point index
00B02430  5243                    6803      ADDQ.w  #1,d3               * increment the number string index
00B02432  382F 0008               6804      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00B02436                          6805  LAB_U018
00B02436  5244                    6806      ADDQ.w  #1,d4               * increment the new format string index
00B02438  B244                    6807      CMP.w       d4,d1               * compare it with the new format string length
00B0243A  6322                    6808      BLS.s       LAB_U022            * if done the fraction digits go do integer
00B0243C                          6809  
00B0243C  1030 4000               6810      MOVE.b  (a0,d4.w),d0        * get a new format string character
00B02440  B03C 0025               6811      CMP.b       #'%',d0         * compare it with "%"
00B02444  6706                    6812      BEQ.s       LAB_U01C            * if "%" go copy a number character
00B02446                          6813  
00B02446  B03C 0023               6814      CMP.b       #'#',d0         * compare it with "#"
00B0244A  66EA                    6815      BNE.s       LAB_U018            * if not "#" go do the next new format character
00B0244C                          6816  
00B0244C                          6817  LAB_U01C
00B0244C  7030                    6818      MOVEQ       #'0',d0         * default to "0" character
00B0244E  BC43                    6819      CMP.w       d3,d6               * compare the number string index with length
00B02450  6306                    6820      BLS.s       LAB_U020            * if there skip the character get
00B02452                          6821  
00B02452  1032 3000               6822      MOVE.b  (a2,d3.w),d0        * get a character from the number string
00B02456  5243                    6823      ADDQ.w  #1,d3               * increment the number string index
00B02458                          6824  LAB_U020
00B02458  1180 4000               6825      MOVE.b  d0,(a0,d4.w)        * save the number character to the new format
00B0245C                          6826                              * string
00B0245C  60D8                    6827      BRA.s       LAB_U018            * go do the next new format character
00B0245E                          6828  
00B0245E                          6829  * now copy the integer digit characters from the number string
00B0245E                          6830  
00B0245E                          6831  LAB_U022
00B0245E  7C00                    6832      MOVEQ       #0,d6               * clear the sign done flag
00B02460  7A00                    6833      MOVEQ       #0,d5               * clear the sign present flag
00B02462  5342                    6834      SUBQ.w  #1,d2               * decrement the number string index
00B02464  6608                    6835      BNE.s       LAB_U026            * if not now at sign continue
00B02466                          6836  
00B02466  7401                    6837      MOVEQ       #1,d2               * increment the number string index
00B02468  15BC 0030 2000          6838      MOVE.b  #'0',(a2,d2.w)      * replace the point with a zero
00B0246E                          6839  LAB_U026
00B0246E  382F 0008               6840      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00B02472  B244                    6841      CMP.w       d4,d1               * compare it with the new format string length
00B02474  6402                    6842      BCC.s       LAB_U02A            * if within the string go use the index
00B02476                          6843  
00B02476  3801                    6844      MOVE.w  d1,d4               * else set the index to the end of the string
00B02478                          6845  LAB_U02A
00B02478  5344                    6846      SUBQ.w  #1,d4               * decrement the new format string index
00B0247A  6B62                    6847      BMI.s       LAB_U03E            * if all done go test for any overflow
00B0247C                          6848  
00B0247C  1030 4000               6849      MOVE.b  (a0,d4.w),d0        * else get a new format string character
00B02480                          6850  
00B02480  7E30                    6851      MOVEQ       #'0',d7         * default to "0" character
00B02482  B03C 0025               6852      CMP.b       #'%',d0         * compare it with "%"
00B02486  6708                    6853      BEQ.s       LAB_U02B            * if "%" go copy a number character
00B02488                          6854  
00B02488  7E20                    6855      MOVEQ       #' ',d7         * default to " " character
00B0248A  B03C 0023               6856      CMP.b       #'#',d0         * compare it with "#"
00B0248E  6606                    6857      BNE.s       LAB_U02C            * if not "#" go try ","
00B02490                          6858  
00B02490                          6859  LAB_U02B
00B02490  4A42                    6860      TST.w       d2              * test the number string index
00B02492  6634                    6861      BNE.s       LAB_U036            * if not at the sign go get a number character
00B02494                          6862  
00B02494  6042                    6863      BRA.s       LAB_U03C            * else go save the default character
00B02496                          6864  
00B02496                          6865  LAB_U02C
00B02496  B03C 002C               6866      CMP.b       #',',d0         * compare it with ","
00B0249A  6610                    6867      BNE.s       LAB_U030            * if not "," go try the sign characters
00B0249C                          6868  
00B0249C  4A42                    6869      TST.w       d2              * test the number string index
00B0249E  6608                    6870      BNE.s       LAB_U02E            * if not at the sign keep the ","
00B024A0                          6871  
00B024A0  0C30 0025 40FF          6872      CMP.b       #'%',-1(a0,d4.w)        * else compare the next format string character
00B024A6                          6873                              * with "%"
00B024A6  6630                    6874      BNE.s       LAB_U03C            * if not "%" keep the default character
00B024A8                          6875  
00B024A8                          6876  LAB_U02E
00B024A8  1E00                    6877      MOVE.b  d0,d7               * else use the "," character
00B024AA  602C                    6878      BRA.s       LAB_U03C            * go save the character to the string
00B024AC                          6879  
00B024AC                          6880  LAB_U030
00B024AC  B03C 002D               6881      CMP.b       #'-',d0         * compare it with "-"
00B024B0  6710                    6882      BEQ.s       LAB_U034            * if "-" go do the sign character
00B024B2                          6883  
00B024B2  B03C 002B               6884      CMP.b       #'+',d0         * compare it with "+"
00B024B6  66C0                    6885      BNE.s       LAB_U02A            * if not "+" go do the next new format character
00B024B8                          6886  
00B024B8  0C12 002D               6887      CMP.b       #'-',(a2)           * compare the sign character with "-"
00B024BC  6704                    6888      BEQ.s       LAB_U034            * if "-" don't change the sign character
00B024BE                          6889  
00B024BE  14BC 002B               6890      MOVE.b  #'+',(a2)           * else make the sign character "+"
00B024C2                          6891  LAB_U034
00B024C2  1A00                    6892      MOVE.b  d0,d5               * set the sign present flag
00B024C4  4A42                    6893      TST.w       d2              * test the number string index
00B024C6  6708                    6894      BEQ.s       LAB_U038            * if at the sign keep the default character
00B024C8                          6895  
00B024C8                          6896  LAB_U036
00B024C8  1E32 2000               6897      MOVE.b  (a2,d2.w),d7        * else get a character from the number string
00B024CC  5342                    6898      SUBQ.w  #1,d2               * decrement the number string index
00B024CE  6008                    6899      BRA.s       LAB_U03C            * go save the character
00B024D0                          6900  
00B024D0                          6901  LAB_U038
00B024D0  4A06                    6902      TST.b       d6              * test the sign done flag
00B024D2  6604                    6903      BNE.s       LAB_U03C            * if the sign has been done go use the space
00B024D4                          6904                              * character
00B024D4                          6905  
00B024D4  1E12                    6906      MOVE.b  (a2),d7         * else get the sign character
00B024D6  1C07                    6907      MOVE.b  d7,d6               * flag that the sign has been done
00B024D8                          6908  LAB_U03C
00B024D8  1187 4000               6909      MOVE.b  d7,(a0,d4.w)        * save the number character to the new format
00B024DC                          6910                              * string
00B024DC  609A                    6911      BRA.s       LAB_U02A            * go do the next new format character
00B024DE                          6912  
00B024DE                          6913  * test for overflow conditions
00B024DE                          6914  
00B024DE                          6915  LAB_U03E
00B024DE  4A42                    6916      TST.w       d2              * test the number string index
00B024E0  6614                    6917      BNE.s       LAB_U040            * if all the digits aren't done go output
00B024E2                          6918                              * an overflow indication
00B024E2                          6919  
00B024E2                          6920  * test for sign overflows
00B024E2                          6921  
00B024E2  4A05                    6922      TST.b       d5              * test the sign present flag
00B024E4  6754                    6923      BEQ.s       LAB_U04A            * if no sign present go add the string
00B024E6                          6924  
00B024E6                          6925  * there was a sign in the format string
00B024E6                          6926  
00B024E6  4A06                    6927      TST.b       d6              * test the sign done flag
00B024E8  6650                    6928      BNE.s       LAB_U04A            * if the sign is done go add the string
00B024EA                          6929  
00B024EA                          6930  * the sign isn't done so see if it was mandatory
00B024EA                          6931  
00B024EA  0C05 002B               6932      CMPI.b  #'+',d5         * compare the sign with "+"
00B024EE  6706                    6933      BEQ.s       LAB_U040            * if it was "+" go output an overflow
00B024F0                          6934                              * indication
00B024F0                          6935  
00B024F0                          6936  * the sign wasn't mandatory but the number may have been negative
00B024F0                          6937  
00B024F0  0C12 002D               6938      CMP.b       #'-',(a2)           * compare the sign character with "-"
00B024F4  6644                    6939      BNE.s       LAB_U04A            * if it wasn't "-" go add the string
00B024F6                          6940  
00B024F6                          6941  * else the sign was "-" and a sign hasn't been output so ..
00B024F6                          6942  
00B024F6                          6943  * the number overflowed the format string so replace all the special format characters
00B024F6                          6944  * with the overflow character
00B024F6                          6945  
00B024F6                          6946  LAB_U040
00B024F6  7A23                    6947      MOVEQ       #ofchr,d5           * set the overflow character
00B024F8  3E01                    6948      MOVE.w  d1,d7               * copy the new format string length
00B024FA  5347                    6949      SUBQ.w  #1,d7               * adjust for the loop type
00B024FC  3C2F 0004               6950      MOVE.w  fsti(sp),d6         * copy the new format string last index
00B02500  5346                    6951      SUBQ.w  #1,d6               * -1 gives the last character of this string
00B02502  6E02                    6952      BGT.s       LAB_U044            * if not zero continue
00B02504                          6953  
00B02504  3C07                    6954      MOVE.w  d7,d6               * else set the format string index to the end
00B02506                          6955  LAB_U044
00B02506  1031 6000               6956      MOVE.b  (a1,d6.w),d0        * get a character from the format string
00B0250A  0C00 0023               6957      CMPI.b  #'#',d0         * compare it with "#" special format character
00B0250E  671E                    6958      BEQ.s       LAB_U046            * if "#" go use the overflow character
00B02510                          6959  
00B02510  0C00 0025               6960      CMPI.b  #'%',d0         * compare it with "%" special format character
00B02514  6718                    6961      BEQ.s       LAB_U046            * if "%" go use the overflow character
00B02516                          6962  
00B02516  0C00 002C               6963      CMPI.b  #',',d0         * compare it with "," special format character
00B0251A  6712                    6964      BEQ.s       LAB_U046            * if "," go use the overflow character
00B0251C                          6965  
00B0251C  0C00 002B               6966      CMPI.b  #'+',d0         * compare it with "+" special format character
00B02520  670C                    6967      BEQ.s       LAB_U046            * if "+" go use the overflow character
00B02522                          6968  
00B02522  0C00 002D               6969      CMPI.b  #'-',d0         * compare it with "-" special format character
00B02526  6706                    6970      BEQ.s       LAB_U046            * if "-" go use the overflow character
00B02528                          6971  
00B02528  0C00 002E               6972      CMPI.b  #'.',d0         * compare it with "." special format character
00B0252C  6602                    6973      BNE.s       LAB_U048            * if not "." skip the using overflow character
00B0252E                          6974  
00B0252E                          6975  LAB_U046
00B0252E  1005                    6976      MOVE.b  d5,d0               * use the overflow character
00B02530                          6977  LAB_U048
00B02530  1180 7000               6978      MOVE.b  d0,(a0,d7.w)        * save the character to the new format string
00B02534  5346                    6979      SUBQ.w  #1,d6               * decrement the format string index
00B02536  51CF FFCE               6980      DBF     d7,LAB_U044         * decrement the count and loop if not all done
00B0253A                          6981  
00B0253A                          6982  * add the new string to the previous string
00B0253A                          6983  
00B0253A                          6984  LAB_U04A
00B0253A  41EC 0006               6985      LEA     6(a4),a0            * get the descriptor pointer for string 1
00B0253E  274C 05F4               6986      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00B02542  6100 F010               6987      BSR     LAB_224E            * concatenate the strings
00B02546                          6988  
00B02546                          6989  * now check for any tail on the format string
00B02546                          6990  
00B02546  302F 0004               6991      MOVE.w  fsti(sp),d0         * get this index
00B0254A  6720                    6992      BEQ.s       LAB_U04C            * if at start of string skip the output
00B0254C                          6993  
00B0254C  3F40 0006               6994      MOVE.w  d0,fsli(sp)         * save this index to the last index
00B02550  6100 0084               6995      BSR     LAB_ProcFo          * now process the format string
00B02554  4A02                    6996      TST.b       d2              * test the special characters flag
00B02556  6614                    6997      BNE.s       LAB_U04C            * if special characters present skip the output
00B02558                          6998  
00B02558                          6999  * else output the new string part
00B02558                          7000  
00B02558  613E                    7001      BSR.s       LAB_DupFmt          * duplicate the processed format string section
00B0255A  3F6F 0004 0006          7002      MOVE.w  fsti(sp),fsli(sp)       * copy this index to the last index
00B02560                          7003  
00B02560                          7004  * add the new string to the previous string
00B02560                          7005  
00B02560  41EC 0006               7006      LEA     6(a4),a0            * get the descriptor pointer for string 1
00B02564  274C 05F4               7007      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00B02568  6100 EFEA               7008      BSR     LAB_224E            * concatenate the strings
00B0256C                          7009  
00B0256C                          7010  * check for another value or end of function
00B0256C                          7011  
00B0256C                          7012  LAB_U04C
00B0256C  101D                    7013      MOVE.b  (a5)+,d0            * get the next BASIC byte
00B0256E  B03C 0029               7014      CMP.b       #')',d0         * compare with close bracket
00B02572  6600 FDCA               7015      BNE     LAB_U002            * if not ")" go do next value
00B02576                          7016  
00B02576                          7017  * pop the result string off the descriptor stack
00B02576                          7018  
00B02576  204C                    7019      MOVEA.l a4,a0               * copy the result string descriptor pointer
00B02578  222B 04AA               7020      MOVE.l  Sstorl(a3),d1       * save the bottom of string space
00B0257C  6100 F038               7021      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00B02580                          7022                              * d0 = length, a0 = pointer
00B02580  2741 04AA               7023      MOVE.l  d1,Sstorl(a3)       * restore the bottom of string space
00B02584  2248                    7024      MOVEA.l a0,a1               * copy the string result pointer
00B02586  3200                    7025      MOVE.w  d0,d1               * copy the string result length
00B02588                          7026  
00B02588                          7027  * pop the format string off the descriptor stack
00B02588                          7028  
00B02588  205F                    7029      MOVEA.l (sp)+,a0            * pull the format string descriptor pointer
00B0258A  6100 F02A               7030      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00B0258E                          7031                              * d0 = length, a0 = pointer
00B0258E                          7032  
00B0258E  4FEF 0008               7033      LEA     fend(sp),sp         * dump the saved values
00B02592                          7034  
00B02592                          7035  * push the result string back on the descriptor stack and return
00B02592                          7036  
00B02592  2049                    7037      MOVEA.l a1,a0               * copy the result string pointer back
00B02594  6000 EE6E               7038      BRA     LAB_RTST            * push a string on the descriptor stack and
00B02598                          7039                              * return. a0 = pointer, d1 = length
00B02598                          7040  
00B02598                          7041  
00B02598                          7042  *************************************************************************************
00B02598                          7043  *
00B02598                          7044  * duplicate the processed format string section
00B02598                          7045  
00B02598                          7046                              * make a string as long as the format string
00B02598                          7047  LAB_DupFmt
00B02598  226F 0004               7048      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00B0259C  3E29 0004               7049      MOVE.w  4(a1),d7            * get the format string length
00B025A0  342F 000A               7050      MOVE.w  4+fsli(sp),d2       * get the format string last index
00B025A4  3C2F 0008               7051      MOVE.w  4+fsti(sp),d6       * get the format string this index
00B025A8  3206                    7052      MOVE.w  d6,d1               * copy the format string this index
00B025AA  9242                    7053      SUB.w       d2,d1               * subtract the format string last index
00B025AC  6202                    7054      BHI.s       LAB_D002            * if > 0 skip the correction
00B025AE                          7055  
00B025AE  D247                    7056      ADD.w       d7,d1               * else add the format string length as the
00B025B0                          7057                              * correction
00B025B0                          7058  LAB_D002
00B025B0  6100 EE6C               7059      BSR     LAB_2115            * make string space d1 bytes long
00B025B4                          7060                              * return a0/Sutill = pointer, others unchanged
00B025B4                          7061  
00B025B4                          7062  * push the new string on the descriptor stack
00B025B4                          7063  
00B025B4  6100 EE4E               7064      BSR     LAB_RTST            * push a string on the descriptor stack and
00B025B8                          7065                              * return. a0 = pointer, d1 = length
00B025B8                          7066  
00B025B8                          7067  * copy the characters from the format string
00B025B8                          7068  
00B025B8  226F 0004               7069      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00B025BC  2251                    7070      MOVEA.l (a1),a1         * get the format string pointer
00B025BE  7800                    7071      MOVEQ       #0,d4               * clear the new string index
00B025C0                          7072  LAB_D00A
00B025C0  11B1 2000 4000          7073      MOVE.b  (a1,d2.w),(a0,d4.w) * get a character from the format string and
00B025C6                          7074                              * save it to the new string
00B025C6  5244                    7075      ADDQ.w  #1,d4               * increment the new string index
00B025C8  5242                    7076      ADDQ.w  #1,d2               * increment the format string index
00B025CA  BE42                    7077      CMP.w       d2,d7               * compare the format index with the length
00B025CC  6602                    7078      BNE.s       LAB_D00E            * if not there skip the reset
00B025CE                          7079  
00B025CE  7400                    7080      MOVEQ       #0,d2               * else reset the format string index
00B025D0                          7081  LAB_D00E
00B025D0  BC42                    7082      CMP.w       d2,d6               * compare the index with this index
00B025D2  66EC                    7083      BNE.s       LAB_D00A            * if not equal go do the next character
00B025D4                          7084  
00B025D4  4E75                    7085      RTS
00B025D6                          7086  
00B025D6                          7087  
00B025D6                          7088  **************************************************************************************
00B025D6                          7089  *
00B025D6                          7090  * process the format string
00B025D6                          7091  
00B025D6                          7092  LAB_ProcFo
00B025D6  226F 0004               7093      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00B025DA  3E29 0004               7094      MOVE.w  4(a1),d7            * get the format string length
00B025DE  2251                    7095      MOVEA.l (a1),a1         * get the format string pointer
00B025E0  3C2F 000A               7096      MOVE.w  4+fsli(sp),d6       * get the format string last index
00B025E4                          7097  
00B025E4  3F47 000C               7098      MOVE.w  d7,4+fsdpi(sp)      * set the format string decimal point index
00B025E8                          7099  *## MOVE.w  #-1,4+fsdpi(sp)     * set the format string decimal point index
00B025E8  7A00                    7100      MOVEQ       #0,d5               * no decimal point
00B025EA  7600                    7101      MOVEQ       #0,d3               * no decimal characters
00B025EC  7400                    7102      MOVEQ       #0,d2               * no special characters
00B025EE                          7103  LAB_P004
00B025EE  1031 6000               7104      MOVE.b  (a1,d6.w),d0        * get a format string byte
00B025F2                          7105  
00B025F2  B03C 002C               7106      CMP.b       #',',d0         * compare it with ","
00B025F6  6742                    7107      BEQ.s       LAB_P01A            * if "," go do the next format string byte
00B025F8                          7108  
00B025F8  B03C 0023               7109      CMP.b       #'#',d0         * compare it with "#"
00B025FC  6706                    7110      BEQ.s       LAB_P008            * if "#" go flag special characters
00B025FE                          7111  
00B025FE  B03C 0025               7112      CMP.b       #'%',d0         * compare it with "%"
00B02602  6608                    7113      BNE.s       LAB_P00C            * if not "%" go try "+"
00B02604                          7114  
00B02604                          7115  LAB_P008
00B02604  4A85                    7116      TST.l       d5              * test the decimal point flag
00B02606  6A10                    7117      BPL.s       LAB_P00E            * if no point skip counting decimal characters
00B02608                          7118  
00B02608  5243                    7119      ADDQ.w  #1,d3               * else increment the decimal character count
00B0260A  602E                    7120      BRA.s       LAB_P01A            * go do the next character
00B0260C                          7121  
00B0260C                          7122  LAB_P00C
00B0260C  B03C 002B               7123      CMP.b       #'+',d0         * compare it with "+"
00B02610  6706                    7124      BEQ.s       LAB_P00E            * if "+" go flag special characters
00B02612                          7125  
00B02612  B03C 002D               7126      CMP.b       #'-',d0         * compare it with "-"
00B02616  6604                    7127      BNE.s       LAB_P010            * if not "-" go check decimal point
00B02618                          7128  
00B02618                          7129  LAB_P00E
00B02618  8400                    7130      OR.b        d0,d2               * flag special characters
00B0261A  601E                    7131      BRA.s       LAB_P01A            * go do the next character
00B0261C                          7132  
00B0261C                          7133  LAB_P010
00B0261C  B03C 002E               7134      CMP.b       #'.',d0         * compare it with "."
00B02620  6614                    7135      BNE.s       LAB_P018            * if not "." go check next
00B02622                          7136  
00B02622                          7137  * "." a decimal point
00B02622                          7138  
00B02622  4A85                    7139      TST.l       d5              * if there is already a decimal point
00B02624  6B14                    7140      BMI.s       LAB_P01A            * go do the next character
00B02626                          7141  
00B02626  3006                    7142      MOVE.w  d6,d0               * copy the decimal point index
00B02628  906F 000A               7143      SUB.w       4+fsli(sp),d0       * calculate it from the scan start
00B0262C  3F40 000C               7144      MOVE.w  d0,4+fsdpi(sp)      * save the decimal point index
00B02630  7AFF                    7145      MOVEQ       #-1,d5          * flag decimal point
00B02632  8400                    7146      OR.b        d0,d2               * flag special characters
00B02634  6004                    7147      BRA.s       LAB_P01A            * go do the next character
00B02636                          7148  
00B02636                          7149  * was not a special character
00B02636                          7150  
00B02636                          7151  LAB_P018
00B02636  4A02                    7152      TST.b       d2              * test if there have been special characters
00B02638  6608                    7153      BNE.s       LAB_P01E            * if so exit the format string process
00B0263A                          7154  
00B0263A                          7155  LAB_P01A
00B0263A  5246                    7156      ADDQ.w  #1,d6               * increment the format string index
00B0263C  BE46                    7157      CMP.w       d6,d7               * compare it with the format string length
00B0263E  62AE                    7158      BHI.s       LAB_P004            * if length > index go get the next character
00B02640                          7159  
00B02640  7C00                    7160      MOVEQ       #0,d6               * length = index so reset the format string
00B02642                          7161                              * index
00B02642                          7162  LAB_P01E
00B02642  3F46 0008               7163      MOVE.w  d6,4+fsti(sp)       * save the format string this index
00B02646  3F43 000E               7164      MOVE.w  d3,4+fsdc(sp)       * save the format string decimal characters
00B0264A                          7165  
00B0264A  4E75                    7166      RTS
00B0264C                          7167  
00B0264C                          7168  
00B0264C                          7169  *************************************************************************************
00B0264C                          7170  *
00B0264C                          7171  * perform BIN$()
00B0264C                          7172  * # of leading 0s is in d1, the number is in d0
00B0264C                          7173  
00B0264C                          7174  LAB_BINS
00B0264C  B23C 0021               7175      CMP.b       #$21,d1         * max + 1
00B02650  6400 DB0C               7176      BCC     LAB_FCER            * exit if too big ( > or = )
00B02654                          7177  
00B02654  741F                    7178      MOVEQ       #$1F,d2         * bit count-1
00B02656  41EB 061A               7179      LEA     Binss(a3),a0        * point to string
00B0265A  7830                    7180      MOVEQ       #$30,d4         * "0" character for ADDX
00B0265C                          7181  NextB1
00B0265C  7600                    7182      MOVEQ       #0,d3               * clear byte
00B0265E  E288                    7183      LSR.l       #1,d0               * shift bit into Xb
00B02660  D704                    7184      ADDX.b  d4,d3               * add carry and character to zero
00B02662  1183 2000               7185      MOVE.b  d3,(a0,d2.w)        * save character to string
00B02666  51CA FFF4               7186      DBF     d2,NextB1           * decrement and loop if not done
00B0266A                          7187  
00B0266A                          7188  * this is the exit code and is also used by HEX$()
00B0266A                          7189  
00B0266A                          7190  EndBHS
00B0266A  177C 0000 063A          7191      MOVE.b  #0,BHsend(a3)       * null terminate the string
00B02670  4A01                    7192      TST.b       d1              * test # of characters
00B02672  670E                    7193      BEQ.s       NextB2          * go truncate string
00B02674                          7194  
00B02674  4481                    7195      NEG.l       d1              * make -ve
00B02676  0681 0000063A           7196      ADD.l       #BHsend,d1          * effectively (end-length)
00B0267C  41F3 1000               7197      LEA     0(a3,d1.w),a0       * effectively add (end-length) to pointer
00B02680  600E                    7198      BRA.s       BinPr               * go print string
00B02682                          7199  
00B02682                          7200  * truncate string to remove leading "0"s
00B02682                          7201  
00B02682                          7202  NextB2
00B02682  1010                    7203      MOVE.b  (a0),d0         * get byte
00B02684  670A                    7204      BEQ.s       BinPr               * if null then end of string so add 1 and go
00B02686                          7205                              * print it
00B02686                          7206  
00B02686  B03C 0030               7207      CMP.b       #'0',d0         * compare with "0"
00B0268A  660E                    7208      BNE.s       GoPr                * if not "0" then go print string from here
00B0268C                          7209  
00B0268C  5248                    7210      ADDQ.w  #1,a0               * else increment pointer
00B0268E  60F2                    7211      BRA.s       NextB2          * loop always
00B02690                          7212  
00B02690                          7213  * make fixed length output string - ignore overflows!
00B02690                          7214  
00B02690                          7215  BinPr
00B02690  43EB 063A               7216      LEA     BHsend(a3),a1       * get string end
00B02694  B1C9                    7217      CMPA.l  a1,a0               * are we at the string end
00B02696  6602                    7218      BNE.s       GoPr                * branch if not
00B02698                          7219  
00B02698  5348                    7220      SUBQ.w  #1,a0               * else need at least one zero
00B0269A                          7221  GoPr
00B0269A  6000 ED22               7222      BRA     LAB_20AE            * print " terminated string to FAC1, stack & RET
00B0269E                          7223  
00B0269E                          7224  
00B0269E                          7225  *************************************************************************************
00B0269E                          7226  *
00B0269E                          7227  * perform HEX$()
00B0269E                          7228  * # of leading 0s is in d1, the number is in d0
00B0269E                          7229  
00B0269E                          7230  LAB_HEXS
00B0269E  B23C 0009               7231      CMP.b       #$09,d1         * max + 1
00B026A2  6400 DABA               7232      BCC     LAB_FCER            * exit if too big ( > or = )
00B026A6                          7233  
00B026A6  7407                    7234      MOVEQ       #$07,d2         * nibble count-1
00B026A8  41EB 0632               7235      LEA     Hexss(a3),a0        * point to string
00B026AC  7830                    7236      MOVEQ       #$30,d4         * "0" character for ABCD
00B026AE                          7237  NextH1
00B026AE  1600                    7238      MOVE.b  d0,d3               * copy lowest byte
00B026B0  E898                    7239      ROR.l       #4,d0               * shift nibble into 0-3
00B026B2  C63C 000F               7240      AND.b       #$0F,d3         * just this nibble
00B026B6  1A03                    7241      MOVE.b  d3,d5               * copy it
00B026B8  0605 00F6               7242      ADD.b       #$F6,d5         * set extend bit
00B026BC  C704                    7243      ABCD        d4,d3               * decimal add extend and character to zero
00B026BE  1183 2000               7244      MOVE.b  d3,(a0,d2.w)        * save character to string
00B026C2  51CA FFEA               7245      DBF     d2,NextH1           * decrement and loop if not done
00B026C6                          7246  
00B026C6  60A2                    7247      BRA.s       EndBHS          * go process string
00B026C8                          7248  
00B026C8                          7249  
00B026C8                          7250  *************************************************************************************
00B026C8                          7251  *
00B026C8                          7252  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00B026C8                          7253  
00B026C8                          7254  VEC_CC
00B026C8  4A2B 064C               7255      TST.b       ccflag(a3)          * check [CTRL-C] check flag
00B026CC  661E                    7256      BNE.s       RTS_022         * exit if [CTRL-C] check inhibited
00B026CE                          7257  
00B026CE  4EAB 0470               7258      JSR     V_INPT(a3)          * scan input device
00B026D2  640E                    7259      BCC.s       LAB_FBA0            * exit if buffer empty
00B026D4                          7260  
00B026D4  1740 064D               7261      MOVE.b  d0,ccbyte(a3)       * save received byte
00B026D8  177C 0020 064E          7262      MOVE.b  #$20,ccnull(a3)     * set "life" timer for bytes countdown
00B026DE  6000 DEF2               7263      BRA     LAB_1636            * return to BASIC
00B026E2                          7264  
00B026E2                          7265  LAB_FBA0
00B026E2  4A2B 064E               7266      TST.b       ccnull(a3)          * get countdown byte
00B026E6  6704                    7267      BEQ.s       RTS_022         * exit if finished
00B026E8                          7268  
00B026E8  532B 064E               7269      SUBQ.b  #1,ccnull(a3)       * else decrement countdown
00B026EC                          7270  RTS_022
00B026EC  4E75                    7271      RTS
00B026EE                          7272  
00B026EE                          7273  
00B026EE                          7274  *************************************************************************************
00B026EE                          7275  *
00B026EE                          7276  * get byte from input device, no waiting
00B026EE                          7277  * returns with carry set if byte in A
00B026EE                          7278  
00B026EE                          7279  INGET
00B026EE  4EAB 0470               7280      JSR     V_INPT(a3)          * call scan input device
00B026F2  650A                    7281      BCS.s       LAB_FB95            * if byte go reset timer
00B026F4                          7282  
00B026F4  102B 064E               7283      MOVE.b  ccnull(a3),d0       * get countdown
00B026F8  67F2                    7284      BEQ.s       RTS_022         * exit if empty
00B026FA                          7285  
00B026FA  102B 064D               7286      MOVE.b  ccbyte(a3),d0       * get last received byte
00B026FE                          7287  LAB_FB95
00B026FE  177C 0000 064E          7288      MOVE.b  #$00,ccnull(a3)     * clear timer because we got a byte
00B02704  003C 0001               7289      ORI.b       #1,CCR          * set carry, flag we got a byte
00B02708  4E75                    7290      RTS
00B0270A                          7291  
00B0270A                          7292  
00B0270A                          7293  *************************************************************************************
00B0270A                          7294  *
00B0270A                          7295  * perform MAX()
00B0270A                          7296  
00B0270A                          7297  LAB_MAX
00B0270A  6100 E53E               7298      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00B0270E  4A2B 0619               7299      TST.b       Dtypef(a3)          * test data type
00B02712  6B00 DA2A               7300      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00B02716                          7301  
00B02716                          7302  LAB_MAXN
00B02716  612E                    7303      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00B02718                          7304                              * pull FAC2 & compare with FAC1
00B02718  64FC                    7305      BCC.s       LAB_MAXN            * branch if no swap to do
00B0271A                          7306  
00B0271A  6100 F4AA               7307      BSR     LAB_279B            * copy FAC2 to FAC1
00B0271E  60F6                    7308      BRA.s       LAB_MAXN            * go do next
00B02720                          7309  
00B02720                          7310  
00B02720                          7311  *************************************************************************************
00B02720                          7312  *
00B02720                          7313  * perform MIN()
00B02720                          7314  
00B02720                          7315  LAB_MIN
00B02720  6100 E528               7316      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00B02724  4A2B 0619               7317      TST.b       Dtypef(a3)          * test data type
00B02728  6B00 DA14               7318      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00B0272C                          7319  
00B0272C                          7320  LAB_MINN
00B0272C  6118                    7321      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00B0272E                          7322                              * pull FAC2 & compare with FAC1
00B0272E  63FC                    7323      BLS.s       LAB_MINN            * branch if no swap to do
00B02730                          7324  
00B02730  6100 F494               7325      BSR     LAB_279B            * copy FAC2 to FAC1
00B02734  60F6                    7326      BRA.s       LAB_MINN            * go do next (branch always)
00B02736                          7327  
00B02736                          7328  * exit routine. don't bother returning to the loop code
00B02736                          7329  * check for correct exit, else so syntax error
00B02736                          7330  
00B02736                          7331  LAB_MMEC
00B02736  B03C 0029               7332      CMP.b       #')',d0         * is it end of function?
00B0273A  6600 DA2E               7333      BNE     LAB_SNER            * if not do MAX MIN syntax error
00B0273E                          7334  
00B0273E  4FEF 0004               7335      LEA     4(sp),sp            * dump return address (faster)
00B02742  6000 E664               7336      BRA     LAB_IGBY            * update BASIC execute pointer (to chr past ")")
00B02746                          7337                              * and return
00B02746                          7338  
00B02746                          7339  * check for next, evaluate & return or exit
00B02746                          7340  * this is the routine that does most of the work
00B02746                          7341  
00B02746                          7342  LAB_PHFA
00B02746  6100 E662               7343      BSR     LAB_GBYT            * get next BASIC byte
00B0274A  B03C 002C               7344      CMP.b       #',',d0         * is there more ?
00B0274E  66E6                    7345      BNE.s       LAB_MMEC            * if not go do end check
00B02750                          7346  
00B02750  3F2B 05F8               7347      MOVE.w  FAC1_e(a3),-(sp)        * push exponent and sign
00B02754  2F2B 05F4               7348      MOVE.l  FAC1_m(a3),-(sp)        * push mantissa
00B02758                          7349  
00B02758  6100 E4F0               7350      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00B0275C  4A2B 0619               7351      TST.b       Dtypef(a3)          * test data type
00B02760  6B00 D9DC               7352      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00B02764                          7353  
00B02764                          7354  
00B02764                          7355                              * pop FAC2 (MAX/MIN expression so far)
00B02764  275F 05FC               7356      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00B02768                          7357  
00B02768  301F                    7358      MOVE.w  (sp)+,d0            * pop exponent and sign
00B0276A  3740 0600               7359      MOVE.w  d0,FAC2_e(a3)       * save exponent and sign
00B0276E  176B 05F9 0602          7360      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * get FAC1 sign
00B02774  B12B 0602               7361      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00B02778  6000 F4B8               7362      BRA     LAB_27FA            * compare FAC1 with FAC2 & return
00B0277C                          7363                              * returns d0=+1 Cb=0 if FAC1 > FAC2
00B0277C                          7364                              * returns d0= 0 Cb=0 if FAC1 = FAC2
00B0277C                          7365                              * returns d0=-1 Cb=1 if FAC1 < FAC2
00B0277C                          7366  
00B0277C                          7367  
00B0277C                          7368  *************************************************************************************
00B0277C                          7369  *
00B0277C                          7370  * perform WIDTH
00B0277C                          7371  
00B0277C                          7372  LAB_WDTH
00B0277C  B03C 002C               7373      CMP.b       #',',d0         * is next byte ","
00B02780  672C                    7374      BEQ.s       LAB_TBSZ            * if so do tab size
00B02782                          7375  
00B02782  6100 EF8E               7376      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00B02786  4A00                    7377      TST.b       d0              * test result
00B02788  6712                    7378      BEQ.s       LAB_NSTT            * branch if set for infinite line
00B0278A                          7379  
00B0278A  B03C 0010               7380      CMP.b       #$10,d0         * else make min width = 16d
00B0278E  6500 D9CE               7381      BCS     LAB_FCER            * if less do function call error & exit
00B02792                          7382  
00B02792                          7383  * this next compare ensures that we can't exit WIDTH via an error leaving the
00B02792                          7384  * tab size greater than the line length.
00B02792                          7385  
00B02792  B02B 0646               7386      CMP.b       TabSiz(a3),d0       * compare with tab size
00B02796  6404                    7387      BCC.s       LAB_NSTT            * branch if >= tab size
00B02798                          7388  
00B02798  1740 0646               7389      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00B0279C                          7390  LAB_NSTT
00B0279C  1740 064A               7391      MOVE.b  d0,TWidth(a3)       * set the terminal width
00B027A0  6100 E608               7392      BSR     LAB_GBYT            * get BASIC byte back
00B027A4  672C                    7393      BEQ.s       WExit               * exit if no following
00B027A6                          7394  
00B027A6  B03C 002C               7395      CMP.b       #',',d0         * else is it ","
00B027AA  6600 D9BE               7396      BNE     LAB_SNER            * if not do syntax error
00B027AE                          7397  
00B027AE                          7398  LAB_TBSZ
00B027AE  6100 EF5E               7399      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00B027B2  4A00                    7400      TST.b       d0              * test TAB size
00B027B4  6B00 D9A8               7401      BMI     LAB_FCER            * if >127 do function call error & exit
00B027B8                          7402  
00B027B8  B03C 0001               7403      CMP.b       #1,d0               * compare with min-1
00B027BC  6500 D9A0               7404      BCS     LAB_FCER            * if <=1 do function call error & exit
00B027C0                          7405  
00B027C0  122B 064A               7406      MOVE.b  TWidth(a3),d1       * set flags for width
00B027C4  6708                    7407      BEQ.s       LAB_SVTB            * skip check if infinite line
00B027C6                          7408  
00B027C6  B02B 064A               7409      CMP.b       TWidth(a3),d0       * compare TAB with width
00B027CA  6E00 D992               7410      BGT     LAB_FCER            * branch if too big
00B027CE                          7411  
00B027CE                          7412  LAB_SVTB
00B027CE  1740 0646               7413      MOVE.b  d0,TabSiz(a3)       * save TAB size
00B027D2                          7414  
00B027D2                          7415  * calculate tab column limit from TAB size. The Iclim is set to the last tab
00B027D2                          7416  * position on a line that still has at least one whole tab width between it
00B027D2                          7417  * and the end of the line.
00B027D2                          7418  
00B027D2                          7419  WExit
00B027D2  102B 064A               7420      MOVE.b  TWidth(a3),d0       * get width
00B027D6  670A                    7421      BEQ.s       LAB_WDLP            * branch if infinite line
00B027D8                          7422  
00B027D8  B02B 0646               7423      CMP.b       TabSiz(a3),d0       * compare with tab size
00B027DC  6404                    7424      BCC.s       LAB_WDLP            * branch if >= tab size
00B027DE                          7425  
00B027DE  1740 0646               7426      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00B027E2                          7427  LAB_WDLP
00B027E2  902B 0646               7428      SUB.b       TabSiz(a3),d0       * subtract tab size
00B027E6  64FA                    7429      BCC.s       LAB_WDLP            * loop while no borrow
00B027E8                          7430  
00B027E8  D02B 0646               7431      ADD.b       TabSiz(a3),d0       * add tab size back
00B027EC  D02B 0646               7432      ADD.b       TabSiz(a3),d0       * add tab size back again
00B027F0                          7433  
00B027F0  4400                    7434      NEG.b       d0              * make -ve
00B027F2  D02B 064A               7435      ADD.b       TWidth(a3),d0       * subtract remainder from width
00B027F6  1740 064B               7436      MOVE.b  d0,Iclim(a3)        * save tab column limit
00B027FA                          7437  RTS_023
00B027FA  4E75                    7438      RTS
00B027FC                          7439  
00B027FC                          7440  
00B027FC                          7441  *************************************************************************************
00B027FC                          7442  *
00B027FC                          7443  * perform SQR()
00B027FC                          7444  
00B027FC                          7445  * d0 is number to find the root of
00B027FC                          7446  * d1 is the root result
00B027FC                          7447  * d2 is the remainder
00B027FC                          7448  * d3 is a counter
00B027FC                          7449  * d4 is temp
00B027FC                          7450  
00B027FC                          7451  LAB_SQR
00B027FC  4A2B 05F9               7452      TST.b       FAC1_s(a3)          * test FAC1 sign
00B02800  6B00 D95C               7453      BMI     LAB_FCER            * if -ve do function call error
00B02804                          7454  
00B02804  4A2B 05F8               7455      TST.b       FAC1_e(a3)          * test exponent
00B02808  67F0                    7456      BEQ.s       RTS_023         * exit if zero
00B0280A                          7457  
00B0280A  48E7 7800               7458      MOVEM.l d1-d4,-(sp)         * save registers
00B0280E  202B 05F4               7459      MOVE.l  FAC1_m(a3),d0       * copy FAC1
00B02812  7400                    7460      MOVEQ       #0,d2               * clear remainder
00B02814  2202                    7461      MOVE.l  d2,d1               * clear root
00B02816                          7462  
00B02816  761F                    7463      MOVEQ       #$1F,d3         * $1F for DBF, 64 pairs of bits to
00B02818                          7464                              * do for a 32 bit result
00B02818  082B 0000 05F8          7465      BTST        #0,FAC1_e(a3)       * test exponent odd/even
00B0281E  6606                    7466      BNE.s       LAB_SQE2            * if odd only 1 shift first time
00B02820                          7467  
00B02820                          7468  LAB_SQE1
00B02820  D080                    7469      ADD.l       d0,d0               * shift highest bit of number ..
00B02822  D582                    7470      ADDX.l  d2,d2               * .. into remainder .. never overflows
00B02824  D281                    7471      ADD.l       d1,d1               * root = root * 2 .. never overflows
00B02826                          7472  LAB_SQE2
00B02826  D080                    7473      ADD.l       d0,d0               * shift highest bit of number ..
00B02828  D582                    7474      ADDX.l  d2,d2               * .. into remainder .. never overflows
00B0282A                          7475  
00B0282A  2801                    7476      MOVE.l  d1,d4               * copy root
00B0282C  D884                    7477      ADD.l       d4,d4               * 2n
00B0282E  5284                    7478      ADDQ.l  #1,d4               * 2n+1
00B02830                          7479  
00B02830  B484                    7480      CMP.l       d4,d2               * compare 2n+1 to remainder
00B02832  6504                    7481      BCS.s       LAB_SQNS            * skip sub if remainder smaller
00B02834                          7482  
00B02834  9484                    7483      SUB.l       d4,d2               * subtract temp from remainder
00B02836  5281                    7484      ADDQ.l  #1,d1               * increment root
00B02838                          7485  LAB_SQNS
00B02838  51CB FFE6               7486      DBF     d3,LAB_SQE1         * loop if not all done
00B0283C                          7487  
00B0283C  2741 05F4               7488      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00B02840  102B 05F8               7489      MOVE.b  FAC1_e(a3),d0       * get exponent (d0 is clear here)
00B02844  0440 0080               7490      SUB.w       #$80,d0         * normalise
00B02848  E248                    7491      LSR.w       #1,d0               * /2
00B0284A  6402                    7492      BCC.s       LAB_SQNA            * skip increment if carry clear
00B0284C                          7493  
00B0284C  5240                    7494      ADDQ.w  #1,d0               * add bit zero back in (allow for half shift)
00B0284E                          7495  LAB_SQNA
00B0284E  0640 0080               7496      ADD.w       #$80,d0         * re-bias to $80
00B02852  1740 05F8               7497      MOVE.b  d0,FAC1_e(a3)       * save it
00B02856  4CDF 001E               7498      MOVEM.l (sp)+,d1-d4         * restore registers
00B0285A  6000 F0A8               7499      BRA     LAB_24D5            * normalise FAC1 & return
00B0285E                          7500  
00B0285E                          7501  
00B0285E                          7502  *************************************************************************************
00B0285E                          7503  *
00B0285E                          7504  * perform VARPTR()
00B0285E                          7505  
00B0285E                          7506  LAB_VARPTR
00B0285E  101D                    7507      MOVE.b  (a5)+,d0            * increment pointer
00B02860                          7508  LAB_VARCALL
00B02860  6100 E756               7509      BSR     LAB_GVAR            * get variable address in a0
00B02864  6100 E530               7510      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00B02868  2008                    7511      MOVE.l  a0,d0               * copy the variable address
00B0286A  6000 EA3C               7512      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B0286E                          7513  
00B0286E                          7514  
00B0286E                          7515  *************************************************************************************
00B0286E                          7516  *
00B0286E                          7517  * perform RAMBASE
00B0286E                          7518  
00B0286E                          7519  LAB_RAM
00B0286E  41EB 0464               7520      LEA     ram_base(a3),a0     * get start of EhBASIC RAM
00B02872  2008                    7521      MOVE.l  a0,d0               * copy it
00B02874  6000 EA32               7522      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00B02878                          7523  
00B02878                          7524  
00B02878                          7525  *************************************************************************************
00B02878                          7526  *
00B02878                          7527  * perform PI
00B02878                          7528  
00B02878                          7529  LAB_PI
00B02878  277C C90FDAA2 05F4      7530      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * pi mantissa (32 bit)
00B02880  377C 8200 05F8          7531      MOVE.w  #$8200,FAC1_e(a3)       * pi exponent and sign
00B02886  4E75                    7532      RTS
00B02888                          7533  
00B02888                          7534  
00B02888                          7535  *************************************************************************************
00B02888                          7536  *
00B02888                          7537  * perform TWOPI
00B02888                          7538  
00B02888                          7539  LAB_TWOPI
00B02888  277C C90FDAA2 05F4      7540      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * 2pi mantissa (32 bit)
00B02890  377C 8300 05F8          7541      MOVE.w  #$8300,FAC1_e(a3)       * 2pi exponent and sign
00B02896  4E75                    7542      RTS
00B02898                          7543  
00B02898                          7544  
00B02898                          7545  *************************************************************************************
00B02898                          7546  *
00B02898                          7547  * get ASCII string equivalent into FAC1 as integer32 or float
00B02898                          7548  
00B02898                          7549  * entry is with a5 pointing to the first character of the string
00B02898                          7550  * exit with a5 pointing to the first character after the string
00B02898                          7551  
00B02898                          7552  * d0 is character
00B02898                          7553  * d1 is mantissa
00B02898                          7554  * d2 is partial and table mantissa
00B02898                          7555  * d3 is mantissa exponent (decimal & binary)
00B02898                          7556  * d4 is decimal exponent
00B02898                          7557  
00B02898                          7558  * get FAC1 from string
00B02898                          7559  * this routine now handles hex and binary values from strings
00B02898                          7560  * starting with "$" and "%" respectively
00B02898                          7561  
00B02898                          7562  LAB_2887
00B02898  48E7 7C00               7563      MOVEM.l d1-d5,-(sp)         * save registers
00B0289C  7200                    7564      MOVEQ       #$00,d1         * clear temp accumulator
00B0289E  2601                    7565      MOVE.l  d1,d3               * set mantissa decimal exponent count
00B028A0  2801                    7566      MOVE.l  d1,d4               * clear decimal exponent
00B028A2  1741 05F9               7567      MOVE.b  d1,FAC1_s(a3)       * clear sign byte
00B028A6  1741 0619               7568      MOVE.b  d1,Dtypef(a3)       * set float data type
00B028AA  1741 0613               7569      MOVE.b  d1,expneg(a3)       * clear exponent sign
00B028AE  6100 E4FA               7570      BSR     LAB_GBYT            * get first byte back
00B028B2  653C                    7571      BCS.s       LAB_28FE            * go get floating if 1st character numeric
00B028B4                          7572  
00B028B4  B03C 002D               7573      CMP.b       #'-',d0         * or is it -ve number
00B028B8  6608                    7574      BNE.s       LAB_289A            * branch if not
00B028BA                          7575  
00B028BA  177C 00FF 05F9          7576      MOVE.b  #$FF,FAC1_s(a3)     * set sign byte
00B028C0  6006                    7577      BRA.s       LAB_289C            * now go scan & check for hex/bin/int
00B028C2                          7578  
00B028C2                          7579  LAB_289A
00B028C2                          7580                              * first character wasn't numeric or -
00B028C2  B03C 002B               7581      CMP.b       #'+',d0         * compare with '+'
00B028C6  6606                    7582      BNE.s       LAB_289D            * branch if not '+' (go check for '.'/hex/binary
00B028C8                          7583                              * /integer)
00B028C8                          7584      
00B028C8                          7585  LAB_289C
00B028C8                          7586                              * was "+" or "-" to start, so get next character
00B028C8  6100 E4DE               7587      BSR     LAB_IGBY            * increment & scan memory
00B028CC  6522                    7588      BCS.s       LAB_28FE            * branch if numeric character
00B028CE                          7589  
00B028CE                          7590  LAB_289D
00B028CE  B03C 002E               7591      CMP.b       #'.',d0         * else compare with '.'
00B028D2  6700 0092               7592      BEQ     LAB_2904            * branch if '.'
00B028D6                          7593  
00B028D6                          7594                              * code here for hex/binary/integer numbers
00B028D6  B03C 0024               7595      CMP.b       #'$',d0         * compare with '$'
00B028DA  6700 010A               7596      BEQ     LAB_CHEX            * branch if '$'
00B028DE                          7597  
00B028DE  B03C 0025               7598      CMP.b       #'%',d0         * else compare with '%'
00B028E2  6700 0164               7599      BEQ     LAB_CBIN            * branch if '%'
00B028E6                          7600  
00B028E6  6000 008C               7601      BRA     LAB_2Y01            * not #.$%& so return 0
00B028EA                          7602  
00B028EA                          7603  LAB_28FD
00B028EA  6100 E4BC               7604      BSR     LAB_IGBY            * get next character
00B028EE  646C                    7605      BCC.s       LAB_2902            * exit loop if not a digit
00B028F0                          7606  
00B028F0                          7607  LAB_28FE
00B028F0  6100 01A8               7608      BSR     d1x10               * multiply d1 by 10 and add character
00B028F4  64F4                    7609      BCC.s       LAB_28FD            * loop for more if no overflow
00B028F6                          7610  
00B028F6                          7611  LAB_28FF
00B028F6                          7612                              * overflowed mantissa, count 10s exponent
00B028F6  5283                    7613      ADDQ.l  #1,d3               * increment mantissa decimal exponent count
00B028F8  6100 E4AE               7614      BSR     LAB_IGBY            * get next character
00B028FC  65F8                    7615      BCS.s       LAB_28FF            * loop while numeric character
00B028FE                          7616  
00B028FE                          7617                              * done overflow, now flush fraction or do E
00B028FE  B03C 002E               7618      CMP.b       #'.',d0         * else compare with '.'
00B02902  6606                    7619      BNE.s       LAB_2901            * branch if not '.'
00B02904                          7620  
00B02904                          7621  LAB_2900
00B02904                          7622                              * flush remaining fraction digits
00B02904  6100 E4A2               7623      BSR     LAB_IGBY            * get next character
00B02908  65FA                    7624      BCS     LAB_2900            * loop while numeric character
00B0290A                          7625  
00B0290A                          7626  LAB_2901
00B0290A                          7627                              * done number, only (possible) exponent remains
00B0290A  B03C 0045               7628      CMP.b       #'E',d0         * else compare with 'E'
00B0290E  6664                    7629      BNE.s       LAB_2Y01            * if not 'E' all done, go evaluate
00B02910                          7630  
00B02910                          7631                              * process exponent
00B02910  6100 E496               7632      BSR     LAB_IGBY            * get next character
00B02914  6528                    7633      BCS.s       LAB_2X04            * branch if digit
00B02916                          7634  
00B02916  B03C 002D               7635      CMP.b       #'-',d0         * or is it -ve number
00B0291A  6706                    7636      BEQ.s       LAB_2X01            * branch if so
00B0291C                          7637  
00B0291C  B03C 00B3               7638      CMP.b       #TK_MINUS,d0        * or is it -ve number
00B02920  6608                    7639      BNE.s       LAB_2X02            * branch if not
00B02922                          7640  
00B02922                          7641  LAB_2X01
00B02922  177C 00FF 0613          7642      MOVE.b  #$FF,expneg(a3)     * set exponent sign
00B02928  600E                    7643      BRA.s       LAB_2X03            * now go scan & check exponent
00B0292A                          7644  
00B0292A                          7645  LAB_2X02
00B0292A  B03C 002B               7646      CMP.b       #'+',d0         * or is it +ve number
00B0292E  6708                    7647      BEQ.s       LAB_2X03            * branch if so
00B02930                          7648  
00B02930  B03C 00B2               7649      CMP.b       #TK_PLUS,d0         * or is it +ve number
00B02934  6600 D834               7650      BNE     LAB_SNER            * wasn't - + TK_MINUS TK_PLUS or # so do error
00B02938                          7651  
00B02938                          7652  LAB_2X03
00B02938  6100 E46E               7653      BSR     LAB_IGBY            * get next character
00B0293C  6436                    7654      BCC.s       LAB_2Y01            * if not digit all done, go evaluate
00B0293E                          7655  LAB_2X04
00B0293E  C8FC 000A               7656      MULU        #10,d4          * multiply decimal exponent by 10
00B02942  C0BC 000000FF           7657      AND.l       #$FF,d0         * mask character
00B02948  0400 0030               7658      SUB.b       #'0',d0         * convert to value
00B0294C  D880                    7659      ADD.l       d0,d4               * add to decimal exponent
00B0294E  B83C 0030               7660      CMP.b       #48,d4          * compare with decimal exponent limit+10
00B02952  6FE4                    7661      BLE.s       LAB_2X03            * loop if no overflow/underflow
00B02954                          7662  
00B02954                          7663  LAB_2X05
00B02954                          7664                              * exponent value has overflowed
00B02954  6100 E452               7665      BSR     LAB_IGBY            * get next character
00B02958  65FA                    7666      BCS.s       LAB_2X05            * loop while numeric digit
00B0295A                          7667  
00B0295A  6018                    7668      BRA.s       LAB_2Y01            * all done, go evaluate
00B0295C                          7669  
00B0295C                          7670  LAB_2902
00B0295C  B03C 002E               7671      CMP.b       #'.',d0         * else compare with '.'
00B02960  6704                    7672      BEQ.s       LAB_2904            * branch if was '.'
00B02962                          7673  
00B02962  60A6                    7674      BRA.s       LAB_2901            * branch if not '.' (go check/do 'E')
00B02964                          7675  
00B02964                          7676  LAB_2903
00B02964  5383                    7677      SUBQ.l  #1,d3               * decrement mantissa decimal exponent
00B02966                          7678  LAB_2904
00B02966                          7679                              * was dp so get fraction part
00B02966  6100 E440               7680      BSR     LAB_IGBY            * get next character
00B0296A  649E                    7681      BCC.s       LAB_2901            * exit loop if not a digit (go check/do 'E')
00B0296C                          7682  
00B0296C  6100 012C               7683      BSR     d1x10               * multiply d1 by 10 and add character
00B02970  64F2                    7684      BCC.s       LAB_2903            * loop for more if no overflow
00B02972                          7685  
00B02972  6090                    7686      BRA.s       LAB_2900            * else go flush remaining fraction part
00B02974                          7687  
00B02974                          7688  LAB_2Y01
00B02974                          7689                              * now evaluate result
00B02974  4A2B 0613               7690      TST.b       expneg(a3)          * test exponent sign
00B02978  6A02                    7691      BPL.s       LAB_2Y02            * branch if sign positive
00B0297A                          7692  
00B0297A  4484                    7693      NEG.l       d4              * negate decimal exponent
00B0297C                          7694  LAB_2Y02
00B0297C  D883                    7695      ADD.l       d3,d4               * add mantissa decimal exponent
00B0297E  7620                    7696      MOVEQ       #32,d3          * set up max binary exponent
00B02980  4A81                    7697      TST.l       d1              * test mantissa
00B02982  6752                    7698      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00B02984                          7699  
00B02984  6B08                    7700      BMI.s       LAB_2Y04            * branch if already mormalised
00B02986                          7701  
00B02986  5383                    7702      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00B02988                          7703  LAB_2Y03
00B02988  D281                    7704      ADD.l       d1,d1               * shift mantissa
00B0298A  5BCB FFFC               7705      DBMI        d3,LAB_2Y03         * decrement & loop if not normalised
00B0298E                          7706  
00B0298E                          7707                              * ensure not too big or small
00B0298E                          7708  LAB_2Y04
00B0298E  B8BC 00000026           7709      CMP.l       #38,d4          * compare decimal exponent with max exponent
00B02994  6E00 D7C4               7710      BGT     LAB_OFER            * if greater do overflow error and warm start
00B02998                          7711  
00B02998  B8BC FFFFFFDA           7712      CMP.l       #-38,d4         * compare decimal exponent with min exponent
00B0299E  6D34                    7713      BLT.s       LAB_ret0            * if less just return zero
00B029A0                          7714  
00B029A0  4484                    7715      NEG.l       d4              * negate decimal exponent to go right way
00B029A2  C9FC 0006               7716      MULS        #6,d4               * 6 bytes per entry
00B029A6  2F08                    7717      MOVE.l  a0,-(sp)            * save register
00B029A8  41FA 0210               7718      LEA     LAB_P_10(pc),a0     * point to table
00B029AC  1770 4000 0600          7719      MOVE.b  (a0,d4.w),FAC2_e(a3)    * copy exponent for multiply
00B029B2  2770 4002 05FC          7720      MOVE.l  2(a0,d4.w),FAC2_m(a3)   * copy table mantissa
00B029B8  205F                    7721      MOVE.l  (sp)+,a0            * restore register
00B029BA                          7722  
00B029BA  0A03 0080               7723      EORI.b  #$80,d3         * normalise input exponent
00B029BE  2741 05F4               7724      MOVE.l  d1,FAC1_m(a3)       * save input mantissa
00B029C2  1743 05F8               7725      MOVE.b  d3,FAC1_e(a3)       * save input exponent
00B029C6  176B 05F9 0602          7726      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * set sign as sign compare
00B029CC                          7727  
00B029CC  4CDF 003E               7728      MOVEM.l (sp)+,d1-d5         * restore registers
00B029D0  6000 F05A               7729      BRA     LAB_MULTIPLY        * go multiply input by table
00B029D4                          7730  
00B029D4                          7731  LAB_ret0
00B029D4  7200                    7732      MOVEQ       #0,d1               * clear mantissa
00B029D6                          7733  LAB_rtn0
00B029D6  2601                    7734      MOVE.l  d1,d3               * clear exponent
00B029D8  1743 05F8               7735      MOVE.b  d3,FAC1_e(a3)       * save exponent
00B029DC  2741 05F4               7736      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00B029E0  4CDF 003E               7737      MOVEM.l (sp)+,d1-d5         * restore registers
00B029E4  4E75                    7738      RTS
00B029E6                          7739  
00B029E6                          7740  
00B029E6                          7741  *************************************************************************************
00B029E6                          7742  *
00B029E6                          7743  * $ for hex add-on
00B029E6                          7744  
00B029E6                          7745  * gets here if the first character was "$" for hex
00B029E6                          7746  * get hex number
00B029E6                          7747  
00B029E6                          7748  LAB_CHEX
00B029E6  177C 0040 0619          7749      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00B029EC  7620                    7750      MOVEQ       #32,d3          * set up max binary exponent
00B029EE                          7751  LAB_CHXX
00B029EE  6100 E3B8               7752      BSR     LAB_IGBY            * increment & scan memory
00B029F2  6514                    7753      BCS.s       LAB_ISHN            * branch if numeric character
00B029F4                          7754  
00B029F4  803C 0020               7755      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00B029F8  0400 0061               7756      SUB.b       #'a',d0         * subtract "a"
00B029FC  652A                    7757      BCS.s       LAB_CHX3            * exit if <"a"
00B029FE                          7758  
00B029FE  B03C 0006               7759      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00B02A02  6424                    7760      BCC.s       LAB_CHX3            * exit if >"f"
00B02A04                          7761  
00B02A04  0600 003A               7762      ADD.b       #$3A,d0         * convert to nibble+"0"
00B02A08                          7763  LAB_ISHN
00B02A08  616C                    7764      BSR.s       d1x16               * multiply d1 by 16 and add the character
00B02A0A  64E2                    7765      BCC.s       LAB_CHXX            * loop for more if no overflow
00B02A0C                          7766  
00B02A0C                          7767                              * overflowed mantissa, count 16s exponent
00B02A0C                          7768  LAB_CHX1
00B02A0C  5883                    7769      ADDQ.l  #4,d3               * increment mantissa exponent count
00B02A0E  6900 D74A               7770      BVS     LAB_OFER            * do overflow error if overflowed
00B02A12                          7771  
00B02A12  6100 E394               7772      BSR     LAB_IGBY            * get next character
00B02A16  65F4                    7773      BCS.s       LAB_CHX1            * loop while numeric character
00B02A18                          7774  
00B02A18  803C 0020               7775      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00B02A1C  0400 0061               7776      SUB.b       #'a',d0         * subtract "a"
00B02A20  6506                    7777      BCS.s       LAB_CHX3            * exit if <"a"
00B02A22                          7778  
00B02A22  B03C 0006               7779      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00B02A26  65E4                    7780      BCS.s       LAB_CHX1            * loop if <="f"
00B02A28                          7781  
00B02A28                          7782                              * now return value
00B02A28                          7783  LAB_CHX3
00B02A28  4A81                    7784      TST.l       d1              * test mantissa
00B02A2A  67AA                    7785      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00B02A2C                          7786  
00B02A2C  6B08                    7787      BMI.s       LAB_exxf            * branch if already mormalised
00B02A2E                          7788  
00B02A2E  5383                    7789      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00B02A30                          7790  LAB_CHX2
00B02A30  D281                    7791      ADD.l       d1,d1               * shift mantissa
00B02A32  5BCB FFFC               7792      DBMI        d3,LAB_CHX2         * decrement & loop if not normalised
00B02A36                          7793  
00B02A36                          7794  LAB_exxf
00B02A36  0A03 0080               7795      EORI.b  #$80,d3         * normalise exponent
00B02A3A  1743 05F8               7796      MOVE.b  d3,FAC1_e(a3)       * save exponent
00B02A3E  2741 05F4               7797      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00B02A42  4CDF 003E               7798      MOVEM.l (sp)+,d1-d5         * restore registers
00B02A46                          7799  RTS_024
00B02A46  4E75                    7800      RTS
00B02A48                          7801  
00B02A48                          7802  
00B02A48                          7803  *************************************************************************************
00B02A48                          7804  *
00B02A48                          7805  * % for binary add-on
00B02A48                          7806  
00B02A48                          7807  * gets here if the first character was "%" for binary
00B02A48                          7808  * get binary number
00B02A48                          7809  
00B02A48                          7810  LAB_CBIN
00B02A48  177C 0040 0619          7811      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00B02A4E  7620                    7812      MOVEQ       #32,d3          * set up max binary exponent
00B02A50                          7813  LAB_CBXN
00B02A50  6100 E356               7814      BSR     LAB_IGBY            * increment & scan memory
00B02A54  64D2                    7815      BCC.s       LAB_CHX3            * if not numeric character go return value
00B02A56                          7816  
00B02A56  B03C 0032               7817      CMP.b       #'2',d0         * compare with "2" (max+1)
00B02A5A  64CC                    7818      BCC.s       LAB_CHX3            * if >="2" go return value
00B02A5C                          7819  
00B02A5C  2401                    7820      MOVE.l  d1,d2               * copy value
00B02A5E  6124                    7821      BSR.s       d1x02               * multiply d1 by 2 and add character
00B02A60  64EE                    7822      BCC.s       LAB_CBXN            * loop for more if no overflow
00B02A62                          7823  
00B02A62                          7824                              * overflowed mantissa, count 2s exponent
00B02A62                          7825  LAB_CBX1
00B02A62  5283                    7826      ADDQ.l  #1,d3               * increment mantissa exponent count
00B02A64  6900 D6F4               7827      BVS     LAB_OFER            * do overflow error if overflowed
00B02A68                          7828  
00B02A68  6100 E33E               7829      BSR     LAB_IGBY            * get next character
00B02A6C  64BA                    7830      BCC.s       LAB_CHX3            * if not numeric character go return value
00B02A6E                          7831  
00B02A6E  B03C 0032               7832      CMP.b       #'2',d0         * compare with "2" (max+1)
00B02A72  65EE                    7833      BCS.s       LAB_CBX1            * loop if <"2"
00B02A74                          7834  
00B02A74  60B2                    7835      BRA.s       LAB_CHX3            * if not numeric character go return value
00B02A76                          7836  
00B02A76                          7837  * half way decent times 16 and times 2 with overflow checks
00B02A76                          7838  
00B02A76                          7839  d1x16
00B02A76  2401                    7840      MOVE.l  d1,d2               * copy value
00B02A78  D482                    7841      ADD.l       d2,d2               * times two
00B02A7A  65CA                    7842      BCS.s       RTS_024         * return if overflow
00B02A7C                          7843  
00B02A7C  D482                    7844      ADD.l       d2,d2               * times four
00B02A7E  65C6                    7845      BCS.s       RTS_024         * return if overflow
00B02A80                          7846  
00B02A80  D482                    7847      ADD.l       d2,d2               * times eight
00B02A82  65C2                    7848      BCS.s       RTS_024         * return if overflow
00B02A84                          7849  
00B02A84                          7850  d1x02
00B02A84  D482                    7851      ADD.l       d2,d2               * times sixteen (ten/two)
00B02A86  65BE                    7852      BCS.s       RTS_024         * return if overflow
00B02A88                          7853  
00B02A88                          7854  * now add in new digit
00B02A88                          7855  
00B02A88  C0BC 000000FF           7856      AND.l       #$FF,d0         * mask character
00B02A8E  0400 0030               7857      SUB.b       #'0',d0         * convert to value
00B02A92  D480                    7858      ADD.l       d0,d2               * add to result
00B02A94  65B0                    7859      BCS.s       RTS_024         * return if overflow, it should never ever do
00B02A96                          7860                              * this
00B02A96                          7861  
00B02A96  2202                    7862      MOVE.l  d2,d1               * copy result
00B02A98  4E75                    7863      RTS
00B02A9A                          7864  
00B02A9A                          7865  * half way decent times 10 with overflow checks
00B02A9A                          7866  
00B02A9A                          7867  d1x10
00B02A9A  2401                    7868      MOVE.l  d1,d2               * copy value
00B02A9C  D482                    7869      ADD.l       d2,d2               * times two
00B02A9E  6508                    7870      BCS.s       RTS_025         * return if overflow
00B02AA0                          7871  
00B02AA0  D482                    7872      ADD.l       d2,d2               * times four
00B02AA2  6504                    7873      BCS.s       RTS_025         * return if overflow
00B02AA4                          7874  
00B02AA4  D481                    7875      ADD.l       d1,d2               * times five
00B02AA6  64DC                    7876      BCC.s       d1x02               * do times two and add in new digit if ok
00B02AA8                          7877  
00B02AA8                          7878  RTS_025
00B02AA8  4E75                    7879      RTS
00B02AAA                          7880  
00B02AAA                          7881  
00B02AAA                          7882  *************************************************************************************
00B02AAA                          7883  *
00B02AAA                          7884  * token values needed for BASIC
00B02AAA                          7885  
00B02AAA  =00000080               7886  TK_END      EQU $80         * $80
00B02AAA  =00000081               7887  TK_FOR      EQU TK_END+1        * $81
00B02AAA  =00000082               7888  TK_NEXT     EQU TK_FOR+1        * $82
00B02AAA  =00000083               7889  TK_DATA     EQU TK_NEXT+1       * $83
00B02AAA  =00000084               7890  TK_INPUT        EQU TK_DATA+1       * $84
00B02AAA  =00000085               7891  TK_DIM      EQU TK_INPUT+1      * $85
00B02AAA  =00000086               7892  TK_READ     EQU TK_DIM+1        * $86
00B02AAA  =00000087               7893  TK_LET      EQU TK_READ+1       * $87
00B02AAA  =00000088               7894  TK_DEC      EQU TK_LET+1        * $88
00B02AAA  =00000089               7895  TK_GOTO     EQU TK_DEC+1        * $89
00B02AAA  =0000008A               7896  TK_RUN      EQU TK_GOTO+1       * $8A
00B02AAA  =0000008B               7897  TK_IF           EQU TK_RUN+1        * $8B
00B02AAA  =0000008C               7898  TK_RESTORE      EQU TK_IF+1         * $8C
00B02AAA  =0000008D               7899  TK_GOSUB        EQU TK_RESTORE+1        * $8D
00B02AAA  =0000008E               7900  TK_RETURN       EQU TK_GOSUB+1      * $8E
00B02AAA  =0000008F               7901  TK_REM      EQU TK_RETURN+1     * $8F
00B02AAA  =00000090               7902  TK_STOP     EQU TK_REM+1        * $90
00B02AAA  =00000091               7903  TK_ON           EQU TK_STOP+1       * $91
00B02AAA  =00000092               7904  TK_NULL     EQU TK_ON+1         * $92
00B02AAA  =00000093               7905  TK_INC      EQU TK_NULL+1       * $93
00B02AAA  =00000094               7906  TK_WAIT     EQU TK_INC+1        * $94
00B02AAA  =00000095               7907  TK_LOAD     EQU TK_WAIT+1       * $95
00B02AAA  =00000096               7908  TK_SAVE     EQU TK_LOAD+1       * $96
00B02AAA  =00000097               7909  TK_DEF      EQU TK_SAVE+1       * $97
00B02AAA  =00000098               7910  TK_POKE     EQU TK_DEF+1        * $98
00B02AAA  =00000099               7911  TK_DOKE     EQU TK_POKE+1       * $99
00B02AAA  =0000009A               7912  TK_LOKE     EQU TK_DOKE+1       * $9A
00B02AAA  =0000009B               7913  TK_CALL     EQU TK_LOKE+1       * $9B
00B02AAA  =0000009C               7914  TK_DO           EQU TK_CALL+1       * $9C
00B02AAA  =0000009D               7915  TK_LOOP     EQU TK_DO+1         * $9D
00B02AAA  =0000009E               7916  TK_PRINT        EQU TK_LOOP+1       * $9E
00B02AAA  =0000009F               7917  TK_CONT     EQU TK_PRINT+1      * $9F
00B02AAA  =000000A0               7918  TK_LIST     EQU TK_CONT+1       * $A0
00B02AAA  =000000A1               7919  TK_CLEAR        EQU TK_LIST+1       * $A1
00B02AAA  =000000A2               7920  TK_NEW      EQU TK_CLEAR+1      * $A2
00B02AAA  =000000A3               7921  TK_WIDTH        EQU TK_NEW+1        * $A3
00B02AAA  =000000A4               7922  TK_GET      EQU TK_WIDTH+1      * $A4
00B02AAA  =000000A5               7923  TK_SWAP     EQU TK_GET+1        * $A5
00B02AAA  =000000A6               7924  TK_BITSET       EQU TK_SWAP+1       * $A6
00B02AAA  =000000A7               7925  TK_BITCLR       EQU TK_BITSET+1     * $A7
00B02AAA  =000000A8               7926  TK_TAB      EQU TK_BITCLR+1     * $A8
00B02AAA  =000000A9               7927  TK_ELSE     EQU TK_TAB+1        * $A9
00B02AAA  =000000AA               7928  TK_TO           EQU TK_ELSE+1       * $AA
00B02AAA  =000000AB               7929  TK_FN           EQU TK_TO+1         * $AB
00B02AAA  =000000AC               7930  TK_SPC      EQU TK_FN+1         * $AC
00B02AAA  =000000AD               7931  TK_THEN     EQU TK_SPC+1        * $AD
00B02AAA  =000000AE               7932  TK_NOT      EQU TK_THEN+1       * $AE
00B02AAA  =000000AF               7933  TK_STEP     EQU TK_NOT+1        * $AF
00B02AAA  =000000B0               7934  TK_UNTIL        EQU TK_STEP+1       * $B0
00B02AAA  =000000B1               7935  TK_WHILE        EQU TK_UNTIL+1      * $B1
00B02AAA  =000000B2               7936  TK_PLUS     EQU TK_WHILE+1      * $B2
00B02AAA  =000000B3               7937  TK_MINUS        EQU TK_PLUS+1       * $B3
00B02AAA  =000000B4               7938  TK_MULT     EQU TK_MINUS+1      * $B4
00B02AAA  =000000B5               7939  TK_DIV      EQU TK_MULT+1       * $B5
00B02AAA  =000000B6               7940  TK_POWER        EQU TK_DIV+1        * $B6
00B02AAA  =000000B7               7941  TK_AND      EQU TK_POWER+1      * $B7
00B02AAA  =000000B8               7942  TK_EOR      EQU TK_AND+1        * $B8
00B02AAA  =000000B9               7943  TK_OR           EQU TK_EOR+1        * $B9
00B02AAA  =000000BA               7944  TK_RSHIFT       EQU TK_OR+1         * $BA
00B02AAA  =000000BB               7945  TK_LSHIFT       EQU TK_RSHIFT+1     * $BB
00B02AAA  =000000BC               7946  TK_GT           EQU TK_LSHIFT+1     * $BC
00B02AAA  =000000BD               7947  TK_EQUAL        EQU TK_GT+1         * $BD
00B02AAA  =000000BE               7948  TK_LT           EQU TK_EQUAL+1      * $BE
00B02AAA  =000000BF               7949  TK_SGN      EQU TK_LT+1         * $BF
00B02AAA  =000000C0               7950  TK_INT      EQU TK_SGN+1        * $C0
00B02AAA  =000000C1               7951  TK_ABS      EQU TK_INT+1        * $C1
00B02AAA  =000000C2               7952  TK_USR      EQU TK_ABS+1        * $C2
00B02AAA  =000000C3               7953  TK_FRE      EQU TK_USR+1        * $C3
00B02AAA  =000000C4               7954  TK_POS      EQU TK_FRE+1        * $C4
00B02AAA  =000000C5               7955  TK_SQR      EQU TK_POS+1        * $C5
00B02AAA  =000000C6               7956  TK_RND      EQU TK_SQR+1        * $C6
00B02AAA  =000000C7               7957  TK_LOG      EQU TK_RND+1        * $C7
00B02AAA  =000000C8               7958  TK_EXP      EQU TK_LOG+1        * $C8
00B02AAA  =000000C9               7959  TK_COS      EQU TK_EXP+1        * $C9
00B02AAA  =000000CA               7960  TK_SIN      EQU TK_COS+1        * $CA
00B02AAA  =000000CB               7961  TK_TAN      EQU TK_SIN+1        * $CB
00B02AAA  =000000CC               7962  TK_ATN      EQU TK_TAN+1        * $CC
00B02AAA  =000000CD               7963  TK_PEEK     EQU TK_ATN+1        * $CD
00B02AAA  =000000CE               7964  TK_DEEK     EQU TK_PEEK+1       * $CE
00B02AAA  =000000CF               7965  TK_LEEK     EQU TK_DEEK+1       * $CF
00B02AAA  =000000D0               7966  TK_LEN      EQU TK_LEEK+1       * $D0
00B02AAA  =000000D1               7967  TK_STRS     EQU TK_LEN+1        * $D1
00B02AAA  =000000D2               7968  TK_VAL      EQU TK_STRS+1       * $D2
00B02AAA  =000000D3               7969  TK_ASC      EQU TK_VAL+1        * $D3
00B02AAA  =000000D4               7970  TK_UCASES       EQU TK_ASC+1        * $D4
00B02AAA  =000000D5               7971  TK_LCASES       EQU TK_UCASES+1     * $D5
00B02AAA  =000000D6               7972  TK_CHRS     EQU TK_LCASES+1     * $D6
00B02AAA  =000000D7               7973  TK_HEXS     EQU TK_CHRS+1       * $D7
00B02AAA  =000000D8               7974  TK_BINS     EQU TK_HEXS+1       * $D8
00B02AAA  =000000D9               7975  TK_BITTST       EQU TK_BINS+1       * $D9
00B02AAA  =000000DA               7976  TK_MAX      EQU TK_BITTST+1     * $DA
00B02AAA  =000000DB               7977  TK_MIN      EQU TK_MAX+1        * $DB
00B02AAA  =000000DC               7978  TK_RAM      EQU TK_MIN+1        * $DC
00B02AAA  =000000DD               7979  TK_PI           EQU TK_RAM+1        * $DD
00B02AAA  =000000DE               7980  TK_TWOPI        EQU TK_PI+1         * $DE
00B02AAA  =000000DF               7981  TK_VPTR     EQU TK_TWOPI+1      * $DF
00B02AAA  =000000E0               7982  TK_SADD     EQU TK_VPTR+1       * $E0
00B02AAA  =000000E1               7983  TK_LEFTS        EQU TK_SADD+1       * $E1
00B02AAA  =000000E2               7984  TK_RIGHTS       EQU TK_LEFTS+1      * $E2
00B02AAA  =000000E3               7985  TK_MIDS     EQU TK_RIGHTS+1     * $E3
00B02AAA  =000000E4               7986  TK_USINGS       EQU TK_MIDS+1       * $E4
00B02AAA                          7987  
00B02AAA                          7988  
00B02AAA                          7989  *************************************************************************************
00B02AAA                          7990  *
00B02AAA                          7991  * binary to unsigned decimal table
00B02AAA                          7992  
00B02AAA                          7993  Bin2dec
00B02AAA= 3B9ACA00                7994      dc.l    $3B9ACA00               * 1000000000
00B02AAE= 05F5E100                7995      dc.l    $05F5E100               * 100000000
00B02AB2= 00989680                7996      dc.l    $00989680               * 10000000
00B02AB6= 000F4240                7997      dc.l    $000F4240               * 1000000
00B02ABA= 000186A0                7998      dc.l    $000186A0               * 100000
00B02ABE= 00002710                7999      dc.l    $00002710               * 10000
00B02AC2= 000003E8                8000      dc.l    $000003E8               * 1000
00B02AC6= 00000064                8001      dc.l    $00000064               * 100
00B02ACA= 0000000A                8002      dc.l    $0000000A               * 10
00B02ACE= 00000000                8003      dc.l    $00000000               * 0 end marker
00B02AD2                          8004  
00B02AD2                          8005  LAB_RSED
00B02AD2= 332E3232                8006      dc.l    $332E3232               * 858665522
00B02AD6                          8007  
00B02AD6                          8008  * string to value exponent table
00B02AD6                          8009  
00B02AD6= FF00                    8010      dc.w    255<<8              * 10**38
00B02AD8= 96769951                8011      dc.l    $96769951
00B02ADC= FB00                    8012      dc.w    251<<8              * 10**37
00B02ADE= F0BDC21B                8013      dc.l    $F0BDC21B
00B02AE2= F800                    8014      dc.w    248<<8              * 10**36
00B02AE4= C097CE7C                8015      dc.l    $C097CE7C
00B02AE8= F500                    8016      dc.w    245<<8              * 10**35
00B02AEA= 9A130B96                8017      dc.l    $9A130B96
00B02AEE= F100                    8018      dc.w    241<<8              * 10**34
00B02AF0= F684DF57                8019      dc.l    $F684DF57
00B02AF4= EE00                    8020      dc.w    238<<8              * 10**33
00B02AF6= C5371912                8021      dc.l    $C5371912
00B02AFA= EB00                    8022      dc.w    235<<8              * 10**32
00B02AFC= 9DC5ADA8                8023      dc.l    $9DC5ADA8
00B02B00= E700                    8024      dc.w    231<<8              * 10**31
00B02B02= FC6F7C40                8025      dc.l    $FC6F7C40
00B02B06= E400                    8026      dc.w    228<<8              * 10**30
00B02B08= C9F2C9CD                8027      dc.l    $C9F2C9CD
00B02B0C= E100                    8028      dc.w    225<<8              * 10**29
00B02B0E= A18F07D7                8029      dc.l    $A18F07D7
00B02B12= DE00                    8030      dc.w    222<<8              * 10**28
00B02B14= 813F3979                8031      dc.l    $813F3979
00B02B18= DA00                    8032      dc.w    218<<8              * 10**27
00B02B1A= CECB8F28                8033      dc.l    $CECB8F28
00B02B1E= D700                    8034      dc.w    215<<8              * 10**26
00B02B20= A56FA5BA                8035      dc.l    $A56FA5BA
00B02B24= D400                    8036      dc.w    212<<8              * 10**25
00B02B26= 84595161                8037      dc.l    $84595161
00B02B2A= D000                    8038      dc.w    208<<8              * 10**24
00B02B2C= D3C21BCF                8039      dc.l    $D3C21BCF
00B02B30= CD00                    8040      dc.w    205<<8              * 10**23
00B02B32= A968163F                8041      dc.l    $A968163F
00B02B36= CA00                    8042      dc.w    202<<8              * 10**22
00B02B38= 87867832                8043      dc.l    $87867832
00B02B3C= C600                    8044      dc.w    198<<8              * 10**21
00B02B3E= D8D726B7                8045      dc.l    $D8D726B7
00B02B42= C300                    8046      dc.w    195<<8              * 10**20
00B02B44= AD78EBC6                8047      dc.l    $AD78EBC6
00B02B48= C000                    8048      dc.w    192<<8              * 10**19
00B02B4A= 8AC72305                8049      dc.l    $8AC72305
00B02B4E= BC00                    8050      dc.w    188<<8              * 10**18
00B02B50= DE0B6B3A                8051      dc.l    $DE0B6B3A
00B02B54= B900                    8052      dc.w    185<<8              * 10**17
00B02B56= B1A2BC2F                8053      dc.l    $B1A2BC2F
00B02B5A= B600                    8054      dc.w    182<<8              * 10**16
00B02B5C= 8E1BC9BF                8055      dc.l    $8E1BC9BF
00B02B60= B200                    8056      dc.w    178<<8              * 10**15
00B02B62= E35FA932                8057      dc.l    $E35FA932
00B02B66= AF00                    8058      dc.w    175<<8              * 10**14
00B02B68= B5E620F5                8059      dc.l    $B5E620F5
00B02B6C= AC00                    8060      dc.w    172<<8              * 10**13
00B02B6E= 9184E72A                8061      dc.l    $9184E72A
00B02B72= A800                    8062      dc.w    168<<8              * 10**12
00B02B74= E8D4A510                8063      dc.l    $E8D4A510
00B02B78= A500                    8064      dc.w    165<<8              * 10**11
00B02B7A= BA43B740                8065      dc.l    $BA43B740
00B02B7E= A200                    8066      dc.w    162<<8              * 10**10
00B02B80= 9502F900                8067      dc.l    $9502F900
00B02B84= 9E00                    8068      dc.w    158<<8              * 10**9
00B02B86= EE6B2800                8069      dc.l    $EE6B2800
00B02B8A= 9B00                    8070      dc.w    155<<8              * 10**8
00B02B8C= BEBC2000                8071      dc.l    $BEBC2000
00B02B90= 9800                    8072      dc.w    152<<8              * 10**7
00B02B92= 98968000                8073      dc.l    $98968000
00B02B96= 9400                    8074      dc.w    148<<8              * 10**6
00B02B98= F4240000                8075      dc.l    $F4240000
00B02B9C= 9100                    8076      dc.w    145<<8              * 10**5
00B02B9E= C3500000                8077      dc.l    $C3500000
00B02BA2= 8E00                    8078      dc.w    142<<8              * 10**4
00B02BA4= 9C400000                8079      dc.l    $9C400000
00B02BA8= 8A00                    8080      dc.w    138<<8              * 10**3
00B02BAA= FA000000                8081      dc.l    $FA000000
00B02BAE= 8700                    8082      dc.w    135<<8              * 10**2
00B02BB0= C8000000                8083      dc.l    $C8000000
00B02BB4= 8400                    8084      dc.w    132<<8              * 10**1
00B02BB6= A0000000                8085      dc.l    $A0000000
00B02BBA                          8086  LAB_P_10
00B02BBA= 8100                    8087      dc.w    129<<8              * 10**0
00B02BBC= 80000000                8088      dc.l    $80000000
00B02BC0= 7D00                    8089      dc.w    125<<8              * 10**-1
00B02BC2= CCCCCCCD                8090      dc.l    $CCCCCCCD
00B02BC6= 7A00                    8091      dc.w    122<<8              * 10**-2
00B02BC8= A3D70A3D                8092      dc.l    $A3D70A3D
00B02BCC= 7700                    8093      dc.w    119<<8              * 10**-3
00B02BCE= 83126E98                8094      dc.l    $83126E98
00B02BD2= 7300                    8095      dc.w    115<<8              * 10**-4
00B02BD4= D1B71759                8096      dc.l    $D1B71759
00B02BD8= 7000                    8097      dc.w    112<<8              * 10**-5
00B02BDA= A7C5AC47                8098      dc.l    $A7C5AC47
00B02BDE= 6D00                    8099      dc.w    109<<8              * 10**-6
00B02BE0= 8637BD06                8100      dc.l    $8637BD06
00B02BE4= 6900                    8101      dc.w    105<<8              * 10**-7
00B02BE6= D6BF94D6                8102      dc.l    $D6BF94D6
00B02BEA= 6600                    8103      dc.w    102<<8              * 10**-8
00B02BEC= ABCC7712                8104      dc.l    $ABCC7712
00B02BF0= 6300                    8105      dc.w    99<<8                   * 10**-9
00B02BF2= 89705F41                8106      dc.l    $89705F41
00B02BF6= 5F00                    8107      dc.w    95<<8                   * 10**-10
00B02BF8= DBE6FECF                8108      dc.l    $DBE6FECF
00B02BFC= 5C00                    8109      dc.w    92<<8                   * 10**-11
00B02BFE= AFEBFF0C                8110      dc.l    $AFEBFF0C
00B02C02= 5900                    8111      dc.w    89<<8                   * 10**-12
00B02C04= 8CBCCC09                8112      dc.l    $8CBCCC09
00B02C08= 5500                    8113      dc.w    85<<8                   * 10**-13
00B02C0A= E12E1342                8114      dc.l    $E12E1342
00B02C0E= 5200                    8115      dc.w    82<<8                   * 10**-14
00B02C10= B424DC35                8116      dc.l    $B424DC35
00B02C14= 4F00                    8117      dc.w    79<<8                   * 10**-15
00B02C16= 901D7CF7                8118      dc.l    $901D7CF7
00B02C1A= 4B00                    8119      dc.w    75<<8                   * 10**-16
00B02C1C= E69594BF                8120      dc.l    $E69594BF
00B02C20= 4800                    8121      dc.w    72<<8                   * 10**-17
00B02C22= B877AA32                8122      dc.l    $B877AA32
00B02C26= 4500                    8123      dc.w    69<<8                   * 10**-18
00B02C28= 9392EE8F                8124      dc.l    $9392EE8F
00B02C2C= 4100                    8125      dc.w    65<<8                   * 10**-19
00B02C2E= EC1E4A7E                8126      dc.l    $EC1E4A7E
00B02C32= 3E00                    8127      dc.w    62<<8                   * 10**-20
00B02C34= BCE50865                8128      dc.l    $BCE50865
00B02C38= 3B00                    8129      dc.w    59<<8                   * 10**-21
00B02C3A= 971DA050                8130      dc.l    $971DA050
00B02C3E= 3700                    8131      dc.w    55<<8                   * 10**-22
00B02C40= F1C90081                8132      dc.l    $F1C90081
00B02C44= 3400                    8133      dc.w    52<<8                   * 10**-23
00B02C46= C16D9A01                8134      dc.l    $C16D9A01
00B02C4A= 3100                    8135      dc.w    49<<8                   * 10**-24
00B02C4C= 9ABE14CD                8136      dc.l    $9ABE14CD
00B02C50= 2D00                    8137      dc.w    45<<8                   * 10**-25
00B02C52= F79687AE                8138      dc.l    $F79687AE
00B02C56= 2A00                    8139      dc.w    42<<8                   * 10**-26
00B02C58= C6120625                8140      dc.l    $C6120625
00B02C5C= 2700                    8141      dc.w    39<<8                   * 10**-27
00B02C5E= 9E74D1B8                8142      dc.l    $9E74D1B8
00B02C62= 2300                    8143      dc.w    35<<8                   * 10**-28
00B02C64= FD87B5F3                8144      dc.l    $FD87B5F3
00B02C68= 2000                    8145      dc.w    32<<8                   * 10**-29
00B02C6A= CAD2F7F5                8146      dc.l    $CAD2F7F5
00B02C6E= 1D00                    8147      dc.w    29<<8                   * 10**-30
00B02C70= A2425FF7                8148      dc.l    $A2425FF7
00B02C74= 1A00                    8149      dc.w    26<<8                   * 10**-31
00B02C76= 81CEB32C                8150      dc.l    $81CEB32C
00B02C7A= 1600                    8151      dc.w    22<<8                   * 10**-32
00B02C7C= CFB11EAD                8152      dc.l    $CFB11EAD
00B02C80= 1300                    8153      dc.w    19<<8                   * 10**-33
00B02C82= A6274BBE                8154      dc.l    $A6274BBE
00B02C86= 1000                    8155      dc.w    16<<8                   * 10**-34
00B02C88= 84EC3C98                8156      dc.l    $84EC3C98
00B02C8C= 0C00                    8157      dc.w    12<<8                   * 10**-35
00B02C8E= D4AD2DC0                8158      dc.l    $D4AD2DC0
00B02C92= 0900                    8159      dc.w    9<<8                    * 10**-36
00B02C94= AA242499                8160      dc.l    $AA242499
00B02C98= 0600                    8161      dc.w    6<<8                    * 10**-37
00B02C9A= 881CEA14                8162      dc.l    $881CEA14
00B02C9E= 0200                    8163      dc.w    2<<8                    * 10**-38
00B02CA0= D9C7DCED                8164      dc.l    $D9C7DCED
00B02CA4                          8165  
00B02CA4                          8166  
00B02CA4                          8167  *************************************************************************************
00B02CA4                          8168  *
00B02CA4                          8169  * table of constants for cordic SIN/COS/TAN calculations
00B02CA4                          8170  * constants are un normalised fractions and are atn(2^-i)/2pi
00B02CA4                          8171  
00B02CA4= 4DBA76D4                8172      dc.l    $4DBA76D4               * SIN/COS multiply constant
00B02CA8                          8173  TAB_SNCO
00B02CA8= 20000000                8174      dc.l    $20000000               * atn(2^0)/2pi
00B02CAC= 12E4051E                8175      dc.l    $12E4051E               * atn(2^1)/2pi
00B02CB0= 09FB385C                8176      dc.l    $09FB385C               * atn(2^2)/2pi
00B02CB4= 051111D5                8177      dc.l    $051111D5               * atn(2^3)/2pi
00B02CB8= 028B0D44                8178      dc.l    $028B0D44               * atn(2^4)/2pi
00B02CBC= 0145D7E2                8179      dc.l    $0145D7E2               * atn(2^5)/2pi
00B02CC0= 00A2F61F                8180      dc.l    $00A2F61F               * atn(2^6)/2pi
00B02CC4= 00517C56                8181      dc.l    $00517C56               * atn(2^7)/2pi
00B02CC8= 0028BE54                8182      dc.l    $0028BE54               * atn(2^8)/2pi
00B02CCC= 00145F2F                8183      dc.l    $00145F2F               * atn(2^9)/2pi
00B02CD0= 000A2F99                8184      dc.l    $000A2F99               * atn(2^10)/2pi
00B02CD4= 000517CD                8185      dc.l    $000517CD               * atn(2^11)/2pi
00B02CD8= 00028BE7                8186      dc.l    $00028BE7               * atn(2^12)/2pi
00B02CDC= 000145F4                8187      dc.l    $000145F4               * atn(2^13)/2pi
00B02CE0= 0000A2FA                8188      dc.l    $0000A2FA               * atn(2^14)/2pi
00B02CE4= 0000517D                8189      dc.l    $0000517D               * atn(2^15)/2pi
00B02CE8= 000028BF                8190      dc.l    $000028BF               * atn(2^16)/2pi
00B02CEC= 00001460                8191      dc.l    $00001460               * atn(2^17)/2pi
00B02CF0= 00000A30                8192      dc.l    $00000A30               * atn(2^18)/2pi
00B02CF4= 00000518                8193      dc.l    $00000518               * atn(2^19)/2pi
00B02CF8= 0000028C                8194      dc.l    $0000028C               * atn(2^20)/2pi
00B02CFC= 00000146                8195      dc.l    $00000146               * atn(2^21)/2pi
00B02D00= 000000A3                8196      dc.l    $000000A3               * atn(2^22)/2pi
00B02D04= 00000052                8197      dc.l    $00000052               * atn(2^23)/2pi
00B02D08= 00000029                8198      dc.l    $00000029               * atn(2^24)/2pi
00B02D0C= 00000015                8199      dc.l    $00000015               * atn(2^25)/2pi
00B02D10= 0000000B                8200      dc.l    $0000000B               * atn(2^26)/2pi
00B02D14= 00000006                8201      dc.l    $00000006               * atn(2^27)/2pi
00B02D18= 00000003                8202      dc.l    $00000003               * atn(2^28)/2pi
00B02D1C= 00000002                8203      dc.l    $00000002               * atn(2^29)/2pi
00B02D20= 00000001                8204      dc.l    $00000001               * atn(2^30)/2pi
00B02D24= 00000001                8205      dc.l    $00000001               * atn(2^31)/2pi
00B02D28                          8206  
00B02D28                          8207  
00B02D28                          8208  *************************************************************************************
00B02D28                          8209  *
00B02D28                          8210  * table of constants for cordic ATN calculation
00B02D28                          8211  * constants are normalised to two integer bits and are atn(2^-i)
00B02D28                          8212  
00B02D28                          8213  TAB_ATNC
00B02D28= 1DAC6705                8214      dc.l    $1DAC6705               * atn(2^-1)
00B02D2C= 0FADBAFD                8215      dc.l    $0FADBAFD               * atn(2^-2)
00B02D30= 07F56EA7                8216      dc.l    $07F56EA7               * atn(2^-3)
00B02D34= 03FEAB77                8217      dc.l    $03FEAB77               * atn(2^-4)
00B02D38= 01FFD55C                8218      dc.l    $01FFD55C               * atn(2^-5)
00B02D3C= 00FFFAAB                8219      dc.l    $00FFFAAB               * atn(2^-6)
00B02D40= 007FFF55                8220      dc.l    $007FFF55               * atn(2^-7)
00B02D44= 003FFFEB                8221      dc.l    $003FFFEB               * atn(2^-8)
00B02D48= 001FFFFD                8222      dc.l    $001FFFFD               * atn(2^-9)
00B02D4C= 00100000                8223      dc.l    $00100000               * atn(2^-10)
00B02D50= 00080000                8224      dc.l    $00080000               * atn(2^-11)
00B02D54= 00040000                8225      dc.l    $00040000               * atn(2^-12)
00B02D58= 00020000                8226      dc.l    $00020000               * atn(2^-13)
00B02D5C= 00010000                8227      dc.l    $00010000               * atn(2^-14)
00B02D60= 00008000                8228      dc.l    $00008000               * atn(2^-15)
00B02D64= 00004000                8229      dc.l    $00004000               * atn(2^-16)
00B02D68= 00002000                8230      dc.l    $00002000               * atn(2^-17)
00B02D6C= 00001000                8231      dc.l    $00001000               * atn(2^-18)
00B02D70= 00000800                8232      dc.l    $00000800               * atn(2^-19)
00B02D74= 00000400                8233      dc.l    $00000400               * atn(2^-20)
00B02D78= 00000200                8234      dc.l    $00000200               * atn(2^-21)
00B02D7C= 00000100                8235      dc.l    $00000100               * atn(2^-22)
00B02D80= 00000080                8236      dc.l    $00000080               * atn(2^-23)
00B02D84= 00000040                8237      dc.l    $00000040               * atn(2^-24)
00B02D88= 00000020                8238      dc.l    $00000020               * atn(2^-25)
00B02D8C= 00000010                8239      dc.l    $00000010               * atn(2^-26)
00B02D90= 00000008                8240      dc.l    $00000008               * atn(2^-27)
00B02D94= 00000004                8241      dc.l    $00000004               * atn(2^-28)
00B02D98= 00000002                8242      dc.l    $00000002               * atn(2^-29)
00B02D9C= 00000001                8243      dc.l    $00000001               * atn(2^-30)
00B02DA0                          8244  LAB_1D96
00B02DA0= 00000000                8245      dc.l    $00000000               * atn(2^-31)
00B02DA4= 00000000                8246      dc.l    $00000000               * atn(2^-32)
00B02DA8                          8247  
00B02DA8                          8248  * constants are normalised to n integer bits and are tanh(2^-i)
00B02DA8  =00000002               8249  n   equ 2
00B02DA8                          8250  TAB_HTHET
00B02DA8= 2327D4F4                8251      dc.l    $8C9F53D0>>n            * atnh(2^-1)    .549306144
00B02DAC= 1058AEFA                8252      dc.l    $4162BBE8>>n            * atnh(2^-2)    .255412812
00B02DB0= 080AC48E                8253      dc.l    $202B1238>>n            * atnh(2^-3)
00B02DB4= 04015622                8254      dc.l    $10055888>>n            * atnh(2^-4)
00B02DB8= 02002AB0                8255      dc.l    $0800AAC0>>n            * atnh(2^-5)
00B02DBC= 01000554                8256      dc.l    $04001550>>n            * atnh(2^-6)
00B02DC0= 008000AA                8257      dc.l    $020002A8>>n            * atnh(2^-7)
00B02DC4= 00400014                8258      dc.l    $01000050>>n            * atnh(2^-8)
00B02DC8= 00200002                8259      dc.l    $00800008>>n            * atnh(2^-9)
00B02DCC= 00100000                8260      dc.l    $00400000>>n            * atnh(2^-10)
00B02DD0= 00080000                8261      dc.l    $00200000>>n            * atnh(2^-11)
00B02DD4= 00040000                8262      dc.l    $00100000>>n            * atnh(2^-12)
00B02DD8= 00020000                8263      dc.l    $00080000>>n            * atnh(2^-13)
00B02DDC= 00010000                8264      dc.l    $00040000>>n            * atnh(2^-14)
00B02DE0= 00008000                8265      dc.l    $00020000>>n            * atnh(2^-15)
00B02DE4= 00004000                8266      dc.l    $00010000>>n            * atnh(2^-16)
00B02DE8= 00002000                8267      dc.l    $00008000>>n            * atnh(2^-17)
00B02DEC= 00001000                8268      dc.l    $00004000>>n            * atnh(2^-18)
00B02DF0= 00000800                8269      dc.l    $00002000>>n            * atnh(2^-19)
00B02DF4= 00000400                8270      dc.l    $00001000>>n            * atnh(2^-20)
00B02DF8= 00000200                8271      dc.l    $00000800>>n            * atnh(2^-21)
00B02DFC= 00000100                8272      dc.l    $00000400>>n            * atnh(2^-22)
00B02E00= 00000080                8273      dc.l    $00000200>>n            * atnh(2^-23)
00B02E04= 00000040                8274      dc.l    $00000100>>n            * atnh(2^-24)
00B02E08= 00000020                8275      dc.l    $00000080>>n            * atnh(2^-25)
00B02E0C= 00000010                8276      dc.l    $00000040>>n            * atnh(2^-26)
00B02E10= 00000008                8277      dc.l    $00000020>>n            * atnh(2^-27)
00B02E14= 00000004                8278      dc.l    $00000010>>n            * atnh(2^-28)
00B02E18= 00000002                8279      dc.l    $00000008>>n            * atnh(2^-29)
00B02E1C= 00000001                8280      dc.l    $00000004>>n            * atnh(2^-30)
00B02E20= 00000000                8281      dc.l    $00000002>>n            * atnh(2^-31)
00B02E24= 00000000                8282      dc.l    $00000001>>n            * atnh(2^-32)
00B02E28                          8283  
00B02E28  =26A3D110               8284  KFCTSEED    equ $9A8F4441>>n        * $26A3D110
00B02E28                          8285  
00B02E28                          8286  
00B02E28                          8287  *************************************************************************************
00B02E28                          8288  *
00B02E28                          8289  * command vector table
00B02E28                          8290  
00B02E28                          8291  LAB_CTBL
00B02E28= D7B2                    8292      dc.w    LAB_END-LAB_CTBL            * END
00B02E2A= D6E6                    8293      dc.w    LAB_FOR-LAB_CTBL            * FOR
00B02E2C= DD52                    8294      dc.w    LAB_NEXT-LAB_CTBL           * NEXT
00B02E2E= D906                    8295      dc.w    LAB_DATA-LAB_CTBL           * DATA
00B02E30= DC46                    8296      dc.w    LAB_INPUT-LAB_CTBL      * INPUT
00B02E32= E122                    8297      dc.w    LAB_DIM-LAB_CTBL            * DIM
00B02E34= DC6C                    8298      dc.w    LAB_READ-LAB_CTBL           * READ
00B02E36= DA78                    8299      dc.w    LAB_LET-LAB_CTBL            * LET
00B02E38= DA16                    8300      dc.w    LAB_DEC-LAB_CTBL            * DEC   
00B02E3A= D86E                    8301      dc.w    LAB_GOTO-LAB_CTBL           * GOTO
00B02E3C= D836                    8302      dc.w    LAB_RUN-LAB_CTBL            * RUN
00B02E3E= D92E                    8303      dc.w    LAB_IF-LAB_CTBL         * IF
00B02E40= D7E0                    8304      dc.w    LAB_RESTORE-LAB_CTBL        * RESTORE
00B02E42= D85C                    8305      dc.w    LAB_GOSUB-LAB_CTBL      * GOSUB
00B02E44= D8F2                    8306      dc.w    LAB_RETURN-LAB_CTBL     * RETURN
00B02E46= D99C                    8307      dc.w    LAB_REM-LAB_CTBL            * REM
00B02E48= D7BA                    8308      dc.w    LAB_STOP-LAB_CTBL           * STOP
00B02E4A= D9A4                    8309      dc.w    LAB_ON-LAB_CTBL         * ON
00B02E4C= D80E                    8310      dc.w    LAB_NULL-LAB_CTBL           * NULL
00B02E4E= DA1C                    8311      dc.w    LAB_INC-LAB_CTBL            * INC   
00B02E50= EA28                    8312      dc.w    LAB_WAIT-LAB_CTBL           * WAIT
00B02E52= EA16                    8313      dc.w    LAB_LOAD-LAB_CTBL           * LOAD
00B02E54= EA1A                    8314      dc.w    LAB_SAVE-LAB_CTBL           * SAVE
00B02E56= E4B2                    8315      dc.w    LAB_DEF-LAB_CTBL            * DEF
00B02E58= E996                    8316      dc.w    LAB_POKE-LAB_CTBL           * POKE
00B02E5A= E9C6                    8317      dc.w    LAB_DOKE-LAB_CTBL           * DOKE
00B02E5C= E9CC                    8318      dc.w    LAB_LOKE-LAB_CTBL           * LOKE
00B02E5E= EA1E                    8319      dc.w    LAB_CALL-LAB_CTBL           * CALL
00B02E60= D84A                    8320      dc.w    LAB_DO-LAB_CTBL         * DO    
00B02E62= D89C                    8321      dc.w    LAB_LOOP-LAB_CTBL           * LOOP
00B02E64= DB0C                    8322      dc.w    LAB_PRINT-LAB_CTBL      * PRINT
00B02E66= D818                    8323      dc.w    LAB_CONT-LAB_CTBL           * CONT
00B02E68= D630                    8324      dc.w    LAB_LIST-LAB_CTBL           * LIST
00B02E6A= D62C                    8325      dc.w    LAB_CLEAR-LAB_CTBL      * CLEAR
00B02E6C= D5DC                    8326      dc.w    LAB_NEW-LAB_CTBL            * NEW
00B02E6E= F954                    8327      dc.w    LAB_WDTH-LAB_CTBL           * WIDTH
00B02E70= DAD2                    8328      dc.w    LAB_GET-LAB_CTBL            * GET
00B02E72= E9E0                    8329      dc.w    LAB_SWAP-LAB_CTBL           * SWAP
00B02E74= F49E                    8330      dc.w    LAB_BITSET-LAB_CTBL     * BITSET
00B02E76= F4AE                    8331      dc.w    LAB_BITCLR-LAB_CTBL     * BITCLR
00B02E78                          8332  
00B02E78                          8333  
00B02E78                          8334  *************************************************************************************
00B02E78                          8335  *
00B02E78                          8336  * function pre process routine table
00B02E78                          8337  
00B02E78                          8338  LAB_FTPP
00B02E78= DFD0                    8339      dc.w    LAB_PPFN-LAB_FTPP           * SGN(n)    process numeric expression in ()
00B02E7A= DFD0                    8340      dc.w    LAB_PPFN-LAB_FTPP           * INT(n)        "
00B02E7C= DFD0                    8341      dc.w    LAB_PPFN-LAB_FTPP           * ABS(n)        "
00B02E7E= DDD2                    8342      dc.w    LAB_EVEZ-LAB_FTPP           * USR(x)    process any expression
00B02E80= DF1A                    8343      dc.w    LAB_1BF7-LAB_FTPP           * FRE(x)    process any expression in ()
00B02E82= DF1A                    8344      dc.w    LAB_1BF7-LAB_FTPP           * POS(x)        "
00B02E84= DFD0                    8345      dc.w    LAB_PPFN-LAB_FTPP           * SQR(n)    process numeric expression in ()
00B02E86= DFD0                    8346      dc.w    LAB_PPFN-LAB_FTPP           * RND(n)        "
00B02E88= DFD0                    8347      dc.w    LAB_PPFN-LAB_FTPP           * LOG(n)        "
00B02E8A= DFD0                    8348      dc.w    LAB_PPFN-LAB_FTPP           * EXP(n)        "
00B02E8C= DFD0                    8349      dc.w    LAB_PPFN-LAB_FTPP           * COS(n)        "
00B02E8E= DFD0                    8350      dc.w    LAB_PPFN-LAB_FTPP           * SIN(n)        "
00B02E90= DFD0                    8351      dc.w    LAB_PPFN-LAB_FTPP           * TAN(n)        "
00B02E92= DFD0                    8352      dc.w    LAB_PPFN-LAB_FTPP           * ATN(n)        "
00B02E94= DFD0                    8353      dc.w    LAB_PPFN-LAB_FTPP           * PEEK(n)       "
00B02E96= DFD0                    8354      dc.w    LAB_PPFN-LAB_FTPP           * DEEK(n)       "
00B02E98= DFD0                    8355      dc.w    LAB_PPFN-LAB_FTPP           * LEEK(n)       "
00B02E9A= DFC2                    8356      dc.w    LAB_PPFS-LAB_FTPP           * LEN($)    process string expression in ()
00B02E9C= DFD0                    8357      dc.w    LAB_PPFN-LAB_FTPP           * STR$(n)   process numeric expression in ()
00B02E9E= DFC2                    8358      dc.w    LAB_PPFS-LAB_FTPP           * VAL($)    process string expression in ()
00B02EA0= DFC2                    8359      dc.w    LAB_PPFS-LAB_FTPP           * ASC($)        "
00B02EA2= DFC2                    8360      dc.w    LAB_PPFS-LAB_FTPP           * UCASE$($)     "
00B02EA4= DFC2                    8361      dc.w    LAB_PPFS-LAB_FTPP           * LCASE$($)     "
00B02EA6= DFD0                    8362      dc.w    LAB_PPFN-LAB_FTPP           * CHR$(n)   process numeric expression in ()
00B02EA8= E00A                    8363      dc.w    LAB_BHSS-LAB_FTPP           * HEX$()    bin/hex pre process
00B02EAA= E00A                    8364      dc.w    LAB_BHSS-LAB_FTPP           * BIN$()        "
00B02EAC= 0000                    8365      dc.w    $0000                   * BITTST()  none
00B02EAE= 0000                    8366      dc.w    $0000                   * MAX()     "
00B02EB0= 0000                    8367      dc.w    $0000                   * MIN()     "
00B02EB2= DFDE                    8368      dc.w    LAB_PPBI-LAB_FTPP           * RAMBASE   advance pointer
00B02EB4= DFDE                    8369      dc.w    LAB_PPBI-LAB_FTPP           * PI            "
00B02EB6= DFDE                    8370      dc.w    LAB_PPBI-LAB_FTPP           * TWOPI     "
00B02EB8= 0000                    8371      dc.w    $0000                   * VARPTR()  none
00B02EBA= 0000                    8372      dc.w    $0000                   * SADD()        "
00B02EBC= DFE8                    8373      dc.w    LAB_LRMS-LAB_FTPP           * LEFT$()   process string expression
00B02EBE= DFE8                    8374      dc.w    LAB_LRMS-LAB_FTPP           * RIGHT$()      "
00B02EC0= DFE8                    8375      dc.w    LAB_LRMS-LAB_FTPP           * MID$()        "
00B02EC2= DDD2                    8376      dc.w    LAB_EVEZ-LAB_FTPP           * USING$(x) process any expression
00B02EC4                          8377  
00B02EC4                          8378  
00B02EC4                          8379  *************************************************************************************
00B02EC4                          8380  *
00B02EC4                          8381  * action addresses for functions
00B02EC4                          8382  
00B02EC4                          8383  LAB_FTBL
00B02EC4= ED54                    8384      dc.w    LAB_SGN-LAB_FTBL            * SGN()
00B02EC6= EDD6                    8385      dc.w    LAB_INT-LAB_FTBL            * INT()
00B02EC8= ED66                    8386      dc.w    LAB_ABS-LAB_FTBL            * ABS()
00B02ECA= E972                    8387      dc.w    LAB_USR-LAB_FTBL            * USR()
00B02ECC= E3CE                    8388      dc.w    LAB_FRE-LAB_FTBL            * FRE()
00B02ECE= E400                    8389      dc.w    LAB_POS-LAB_FTBL            * POS()
00B02ED0= F938                    8390      dc.w    LAB_SQR-LAB_FTBL            * SQR()
00B02ED2= F21E                    8391      dc.w    LAB_RND-LAB_FTBL            * RND()
00B02ED4= EA76                    8392      dc.w    LAB_LOG-LAB_FTBL            * LOG()
00B02ED6= F104                    8393      dc.w    LAB_EXP-LAB_FTBL            * EXP()
00B02ED8= F272                    8394      dc.w    LAB_COS-LAB_FTBL            * COS()
00B02EDA= F28A                    8395      dc.w    LAB_SIN-LAB_FTBL            * SIN()
00B02EDC= F250                    8396      dc.w    LAB_TAN-LAB_FTBL            * TAN()
00B02EDE= F350                    8397      dc.w    LAB_ATN-LAB_FTBL            * ATN()
00B02EE0= E8EE                    8398      dc.w    LAB_PEEK-LAB_FTBL           * PEEK()
00B02EE2= E900                    8399      dc.w    LAB_DEEK-LAB_FTBL           * DEEK()
00B02EE4= E916                    8400      dc.w    LAB_LEEK-LAB_FTBL           * LEEK()
00B02EE6= E832                    8401      dc.w    LAB_LENS-LAB_FTBL           * LEN()
00B02EE8= E4F6                    8402      dc.w    LAB_STRS-LAB_FTBL           * STR$()
00B02EEA= E876                    8403      dc.w    LAB_VAL-LAB_FTBL            * VAL()
00B02EEC= E83A                    8404      dc.w    LAB_ASC-LAB_FTBL            * ASC()
00B02EEE= E7E8                    8405      dc.w    LAB_UCASE-LAB_FTBL      * UCASE$()
00B02EF0= E7B8                    8406      dc.w    LAB_LCASE-LAB_FTBL      * LCASE$()
00B02EF2= E720                    8407      dc.w    LAB_CHRS-LAB_FTBL           * CHR$()
00B02EF4= F7DA                    8408      dc.w    LAB_HEXS-LAB_FTBL           * HEX$()
00B02EF6= F788                    8409      dc.w    LAB_BINS-LAB_FTBL           * BIN$()
00B02EF8= F422                    8410      dc.w    LAB_BTST-LAB_FTBL           * BITTST()
00B02EFA= F846                    8411      dc.w    LAB_MAX-LAB_FTBL            * MAX()
00B02EFC= F85C                    8412      dc.w    LAB_MIN-LAB_FTBL            * MIN()
00B02EFE= F9AA                    8413      dc.w    LAB_RAM-LAB_FTBL            * RAMBASE
00B02F00= F9B4                    8414      dc.w    LAB_PI-LAB_FTBL         * PI
00B02F02= F9C4                    8415      dc.w    LAB_TWOPI-LAB_FTBL      * TWOPI
00B02F04= F99A                    8416      dc.w    LAB_VARPTR-LAB_FTBL     * VARPTR()
00B02F06= E81A                    8417      dc.w    LAB_SADD-LAB_FTBL           * SADD()
00B02F08= E730                    8418      dc.w    LAB_LEFT-LAB_FTBL           * LEFT$()
00B02F0A= E744                    8419      dc.w    LAB_RIGHT-LAB_FTBL      * RIGHT$()
00B02F0C= E774                    8420      dc.w    LAB_MIDS-LAB_FTBL           * MID$()
00B02F0E= F450                    8421      dc.w    LAB_USINGS-LAB_FTBL     * USING$()
00B02F10                          8422  
00B02F10                          8423  
00B02F10                          8424  *************************************************************************************
00B02F10                          8425  *
00B02F10                          8426  * hierarchy and action addresses for operator
00B02F10                          8427  
00B02F10                          8428  LAB_OPPT
00B02F10= 0079                    8429      dc.w    $0079                   * +
00B02F12= E978                    8430      dc.w    LAB_ADD-LAB_OPPT
00B02F14= 0079                    8431      dc.w    $0079                   * -
00B02F16= E964                    8432      dc.w    LAB_SUBTRACT-LAB_OPPT
00B02F18= 007B                    8433      dc.w    $007B                   * *
00B02F1A= EB1C                    8434      dc.w    LAB_MULTIPLY-LAB_OPPT
00B02F1C= 007B                    8435      dc.w    $007B                   * /
00B02F1E= EBA8                    8436      dc.w    LAB_DIVIDE-LAB_OPPT
00B02F20= 007F                    8437      dc.w    $007F                   * ^
00B02F22= F002                    8438      dc.w    LAB_POWER-LAB_OPPT
00B02F24= 0050                    8439      dc.w    $0050                   * AND
00B02F26= DFB2                    8440      dc.w    LAB_AND-LAB_OPPT
00B02F28= 0046                    8441      dc.w    $0046                   * EOR
00B02F2A= DFA2                    8442      dc.w    LAB_EOR-LAB_OPPT
00B02F2C= 0046                    8443      dc.w    $0046                   * OR
00B02F2E= DFAA                    8444      dc.w    LAB_OR-LAB_OPPT
00B02F30= 0056                    8445      dc.w    $0056                   * >>
00B02F32= E056                    8446      dc.w    LAB_RSHIFT-LAB_OPPT
00B02F34= 0056                    8447      dc.w    $0056                   * <<
00B02F36= E046                    8448      dc.w    LAB_LSHIFT-LAB_OPPT
00B02F38= 007D                    8449      dc.w    $007D                   * >
00B02F3A= F066                    8450      dc.w    LAB_GTHAN-LAB_OPPT      * used to evaluate -n
00B02F3C= 005A                    8451      dc.w    $005A                   * =
00B02F3E= DFC8                    8452      dc.w    LAB_EQUAL-LAB_OPPT      * used to evaluate NOT
00B02F40= 0064                    8453      dc.w    $0064                   * <
00B02F42= DFD2                    8454      dc.w    LAB_LTHAN-LAB_OPPT
00B02F44                          8455  
00B02F44                          8456  
00B02F44                          8457  *************************************************************************************
00B02F44                          8458  *
00B02F44                          8459  * misc constants
00B02F44                          8460  
00B02F44                          8461  * This table is used in converting numbers to ASCII.
00B02F44                          8462  * first four entries for expansion to 9.25 digits
00B02F44                          8463  
00B02F44                          8464  LAB_2A9A
00B02F44= FFF0BDC0                8465      dc.l    $FFF0BDC0               * -1000000
00B02F48= 000186A0                8466      dc.l    $000186A0               * 100000
00B02F4C= FFFFD8F0                8467      dc.l    $FFFFD8F0               * -10000
00B02F50= 000003E8                8468      dc.l    $000003E8               * 1000
00B02F54= FFFFFF9C                8469      dc.l    $FFFFFF9C               * -100
00B02F58= 0000000A                8470      dc.l    $0000000A               * 10
00B02F5C= FFFFFFFF                8471      dc.l    $FFFFFFFF               * -1
00B02F60                          8472  LAB_2A9B
00B02F60                          8473  
00B02F60                          8474  
00B02F60                          8475  *************************************************************************************
00B02F60                          8476  *
00B02F60                          8477  * new keyword tables
00B02F60                          8478  
00B02F60                          8479  * offsets to keyword tables
00B02F60                          8480  
00B02F60                          8481  TAB_CHRT
00B02F60= 0000                    8482      dc.w    TAB_STAR-TAB_STAR           * "*"   $2A
00B02F62= 0002                    8483      dc.w    TAB_PLUS-TAB_STAR           * "+"   $2B
00B02F64= FFFF                    8484      dc.w    -1                  * "," $2C no keywords
00B02F66= 0004                    8485      dc.w    TAB_MNUS-TAB_STAR           * "-"   $2D
00B02F68= FFFF                    8486      dc.w    -1                  * "." $2E no keywords
00B02F6A= 0006                    8487      dc.w    TAB_SLAS-TAB_STAR           * "/"   $2F
00B02F6C= FFFF                    8488      dc.w    -1                  * "0" $30 no keywords
00B02F6E= FFFF                    8489      dc.w    -1                  * "1" $31 no keywords
00B02F70= FFFF                    8490      dc.w    -1                  * "2" $32 no keywords
00B02F72= FFFF                    8491      dc.w    -1                  * "3" $33 no keywords
00B02F74= FFFF                    8492      dc.w    -1                  * "4" $34 no keywords
00B02F76= FFFF                    8493      dc.w    -1                  * "5" $35 no keywords
00B02F78= FFFF                    8494      dc.w    -1                  * "6" $36 no keywords
00B02F7A= FFFF                    8495      dc.w    -1                  * "7" $37 no keywords
00B02F7C= FFFF                    8496      dc.w    -1                  * "8" $38 no keywords
00B02F7E= FFFF                    8497      dc.w    -1                  * "9" $39 no keywords
00B02F80= FFFF                    8498      dc.w    -1                  * ";" $3A no keywords
00B02F82= FFFF                    8499      dc.w    -1                  * ":" $3B no keywords
00B02F84= 0008                    8500      dc.w    TAB_LESS-TAB_STAR           * "<"   $3C
00B02F86= 000C                    8501      dc.w    TAB_EQUL-TAB_STAR           * "="   $3D
00B02F88= 000E                    8502      dc.w    TAB_MORE-TAB_STAR           * ">"   $3E
00B02F8A= 0012                    8503      dc.w    TAB_QEST-TAB_STAR           * "?"   $3F
00B02F8C= FFFF                    8504      dc.w    -1                  * "@" $40 no keywords
00B02F8E= 0014                    8505      dc.w    TAB_ASCA-TAB_STAR           * "A"   $41
00B02F90= 0024                    8506      dc.w    TAB_ASCB-TAB_STAR           * "B"   $42
00B02F92= 003D                    8507      dc.w    TAB_ASCC-TAB_STAR           * "C"   $43
00B02F94= 0054                    8508      dc.w    TAB_ASCD-TAB_STAR           * "D"   $44
00B02F96= 006D                    8509      dc.w    TAB_ASCE-TAB_STAR           * "E"   $45
00B02F98= 007C                    8510      dc.w    TAB_ASCF-TAB_STAR           * "F"   $46
00B02F9A= 0086                    8511      dc.w    TAB_ASCG-TAB_STAR           * "G"   $47
00B02F9C= 0093                    8512      dc.w    TAB_ASCH-TAB_STAR           * "H"   $48
00B02F9E= 0099                    8513      dc.w    TAB_ASCI-TAB_STAR           * "I"   $49
00B02FA0= FFFF                    8514      dc.w    -1                  * "J" $4A no keywords
00B02FA2= FFFF                    8515      dc.w    -1                  * "K" $4B no keywords
00B02FA4= 00A8                    8516      dc.w    TAB_ASCL-TAB_STAR           * "L"   $4C
00B02FA6= 00D6                    8517      dc.w    TAB_ASCM-TAB_STAR           * "M"   $4D
00B02FA8= 00E4                    8518      dc.w    TAB_ASCN-TAB_STAR           * "N"   $4E
00B02FAA= 00F3                    8519      dc.w    TAB_ASCO-TAB_STAR           * "O"   $4F
00B02FAC= 00F8                    8520      dc.w    TAB_ASCP-TAB_STAR           * "P"   $50
00B02FAE= FFFF                    8521      dc.w    -1                  * "Q" $51 no keywords
00B02FB0= 010D                    8522      dc.w    TAB_ASCR-TAB_STAR           * "R"   $52
00B02FB2= 0137                    8523      dc.w    TAB_ASCS-TAB_STAR           * "S"   $53
00B02FB4= 0162                    8524      dc.w    TAB_ASCT-TAB_STAR           * "T"   $54
00B02FB6= 0176                    8525      dc.w    TAB_ASCU-TAB_STAR           * "U"   $55
00B02FB8= 018E                    8526      dc.w    TAB_ASCV-TAB_STAR           * "V"   $56
00B02FBA= 019A                    8527      dc.w    TAB_ASCW-TAB_STAR           * "W"   $57
00B02FBC= FFFF                    8528      dc.w    -1                  * "X" $58 no keywords
00B02FBE= FFFF                    8529      dc.w    -1                  * "Y" $59 no keywords
00B02FC0= FFFF                    8530      dc.w    -1                  * "Z" $5A no keywords
00B02FC2= FFFF                    8531      dc.w    -1                  * "[" $5B no keywords
00B02FC4= FFFF                    8532      dc.w    -1                  * "\" $5C no keywords
00B02FC6= FFFF                    8533      dc.w    -1                  * "]" $5D no keywords
00B02FC8= 01A9                    8534      dc.w    TAB_POWR-TAB_STAR           * "^"   $5E
00B02FCA                          8535  
00B02FCA                          8536  
00B02FCA                          8537  *************************************************************************************
00B02FCA                          8538  *
00B02FCA                          8539  * Table of Basic keywords for LIST command
00B02FCA                          8540  * [byte]first character,[byte]remaining length -1
00B02FCA                          8541  * [word]offset from table start
00B02FCA                          8542  
00B02FCA                          8543  LAB_KEYT
00B02FCA= 45 01                   8544      dc.b    'E',1
00B02FCC= 0071                    8545      dc.w    KEY_END-TAB_STAR            * END
00B02FCE= 46 01                   8546      dc.b    'F',1
00B02FD0= 007C                    8547      dc.w    KEY_FOR-TAB_STAR            * FOR
00B02FD2= 4E 02                   8548      dc.b    'N',2
00B02FD4= 00E7                    8549      dc.w    KEY_NEXT-TAB_STAR           * NEXT
00B02FD6= 44 02                   8550      dc.b    'D',2
00B02FD8= 0054                    8551      dc.w    KEY_DATA-TAB_STAR           * DATA
00B02FDA= 49 03                   8552      dc.b    'I',3
00B02FDC= 009E                    8553      dc.w    KEY_INPUT-TAB_STAR      * INPUT
00B02FDE= 44 01                   8554      dc.b    'D',1
00B02FE0= 0063                    8555      dc.w    KEY_DIM-TAB_STAR            * DIM
00B02FE2= 52 02                   8556      dc.b    'R',2
00B02FE4= 0114                    8557      dc.w    KEY_READ-TAB_STAR           * READ
00B02FE6= 4C 01                   8558      dc.b    'L',1
00B02FE8= 00BE                    8559      dc.w    KEY_LET-TAB_STAR            * LET
00B02FEA= 44 01                   8560      dc.b    'D',1
00B02FEC= 0058                    8561      dc.w    KEY_DEC-TAB_STAR            * DEC
00B02FEE= 47 02                   8562      dc.b    'G',2
00B02FF0= 0089                    8563      dc.w    KEY_GOTO-TAB_STAR           * GOTO
00B02FF2= 52 01                   8564      dc.b    'R',1
00B02FF4= 0133                    8565      dc.w    KEY_RUN-TAB_STAR            * RUN
00B02FF6= 49 00                   8566      dc.b    'I',0
00B02FF8= 0099                    8567      dc.w    KEY_IF-TAB_STAR         * IF
00B02FFA= 52 05                   8568      dc.b    'R',5
00B02FFC= 011B                    8569      dc.w    KEY_RESTORE-TAB_STAR        * RESTORE
00B02FFE= 47 03                   8570      dc.b    'G',3
00B03000= 008D                    8571      dc.w    KEY_GOSUB-TAB_STAR      * GOSUB
00B03002= 52 04                   8572      dc.b    'R',4
00B03004= 0122                    8573      dc.w    KEY_RETURN-TAB_STAR     * RETURN
00B03006= 52 01                   8574      dc.b    'R',1
00B03008= 0118                    8575      dc.w    KEY_REM-TAB_STAR            * REM
00B0300A= 53 02                   8576      dc.b    'S',2
00B0300C= 0154                    8577      dc.w    KEY_STOP-TAB_STAR           * STOP
00B0300E= 4F 00                   8578      dc.b    'O',0
00B03010= 00F3                    8579      dc.w    KEY_ON-TAB_STAR         * ON
00B03012= 4E 02                   8580      dc.b    'N',2
00B03014= 00EE                    8581      dc.w    KEY_NULL-TAB_STAR           * NULL
00B03016= 49 01                   8582      dc.b    'I',1
00B03018= 009B                    8583      dc.w    KEY_INC-TAB_STAR            * INC
00B0301A= 57 02                   8584      dc.b    'W',2
00B0301C= 019A                    8585      dc.w    KEY_WAIT-TAB_STAR           * WAIT
00B0301E= 4C 02                   8586      dc.b    'L',2
00B03020= 00C5                    8587      dc.w    KEY_LOAD-TAB_STAR           * LOAD
00B03022= 53 02                   8588      dc.b    'S',2
00B03024= 013C                    8589      dc.w    KEY_SAVE-TAB_STAR           * SAVE
00B03026= 44 01                   8590      dc.b    'D',1
00B03028= 0060                    8591      dc.w    KEY_DEF-TAB_STAR            * DEF
00B0302A= 50 02                   8592      dc.b    'P',2
00B0302C= 00FF                    8593      dc.w    KEY_POKE-TAB_STAR           * POKE
00B0302E= 44 02                   8594      dc.b    'D',2
00B03030= 0066                    8595      dc.w    KEY_DOKE-TAB_STAR           * DOKE
00B03032= 4C 02                   8596      dc.b    'L',2
00B03034= 00CD                    8597      dc.w    KEY_LOKE-TAB_STAR           * LOKE
00B03036= 43 02                   8598      dc.b    'C',2
00B03038= 003D                    8599      dc.w    KEY_CALL-TAB_STAR           * CALL
00B0303A= 44 00                   8600      dc.b    'D',0
00B0303C= 006A                    8601      dc.w    KEY_DO-TAB_STAR         * DO
00B0303E= 4C 02                   8602      dc.b    'L',2
00B03040= 00D1                    8603      dc.w    KEY_LOOP-TAB_STAR           * LOOP
00B03042= 50 03                   8604      dc.b    'P',3
00B03044= 0107                    8605      dc.w    KEY_PRINT-TAB_STAR      * PRINT
00B03046= 43 02                   8606      dc.b    'C',2
00B03048= 004B                    8607      dc.w    KEY_CONT-TAB_STAR           * CONT
00B0304A= 4C 02                   8608      dc.b    'L',2
00B0304C= 00C1                    8609      dc.w    KEY_LIST-TAB_STAR           * LIST
00B0304E= 43 03                   8610      dc.b    'C',3
00B03050= 0046                    8611      dc.w    KEY_CLEAR-TAB_STAR      * CLEAR
00B03052= 4E 01                   8612      dc.b    'N',1
00B03054= 00E4                    8613      dc.w    KEY_NEW-TAB_STAR            * NEW
00B03056= 57 03                   8614      dc.b    'W',3
00B03058= 01A3                    8615      dc.w    KEY_WIDTH-TAB_STAR      * WIDTH
00B0305A= 47 01                   8616      dc.b    'G',1
00B0305C= 0086                    8617      dc.w    KEY_GET-TAB_STAR            * GET
00B0305E= 53 02                   8618      dc.b    'S',2
00B03060= 015D                    8619      dc.w    KEY_SWAP-TAB_STAR           * SWAP
00B03062= 42 04                   8620      dc.b    'B',4
00B03064= 002F                    8621      dc.w    KEY_BITSET-TAB_STAR     * BITSET
00B03066= 42 04                   8622      dc.b    'B',4
00B03068= 0029                    8623      dc.w    KEY_BITCLR-TAB_STAR     * BITCLR
00B0306A= 54 02                   8624      dc.b    'T',2
00B0306C= 0162                    8625      dc.w    KEY_TAB-TAB_STAR            * TAB(
00B0306E= 45 02                   8626      dc.b    'E',2
00B03070= 006D                    8627      dc.w    KEY_ELSE-TAB_STAR           * ELSE
00B03072= 54 00                   8628      dc.b    'T',0
00B03074= 016E                    8629      dc.w    KEY_TO-TAB_STAR         * TO
00B03076= 46 00                   8630      dc.b    'F',0
00B03078= 007F                    8631      dc.w    KEY_FN-TAB_STAR         * FN
00B0307A= 53 02                   8632      dc.b    'S',2
00B0307C= 0148                    8633      dc.w    KEY_SPC-TAB_STAR            * SPC(
00B0307E= 54 02                   8634      dc.b    'T',2
00B03080= 016A                    8635      dc.w    KEY_THEN-TAB_STAR           * THEN
00B03082= 4E 01                   8636      dc.b    'N',1
00B03084= 00EB                    8637      dc.w    KEY_NOT-TAB_STAR            * NOT
00B03086= 53 02                   8638      dc.b    'S',2
00B03088= 0150                    8639      dc.w    KEY_STEP-TAB_STAR           * STEP
00B0308A= 55 03                   8640      dc.b    'U',3
00B0308C= 017D                    8641      dc.w    KEY_UNTIL-TAB_STAR      * UNTIL
00B0308E= 57 03                   8642      dc.b    'W',3
00B03090= 019E                    8643      dc.w    KEY_WHILE-TAB_STAR      * WHILE
00B03092                          8644  
00B03092= 2B FF                   8645      dc.b    '+',-1
00B03094= 0002                    8646      dc.w    KEY_PLUS-TAB_STAR           * +
00B03096= 2D FF                   8647      dc.b    '-',-1
00B03098= 0004                    8648      dc.w    KEY_MINUS-TAB_STAR      * -
00B0309A= 2A FF                   8649      dc.b    '*',-1
00B0309C= 0000                    8650      dc.w    KEY_MULT-TAB_STAR           * *
00B0309E= 2F FF                   8651      dc.b    '/',-1
00B030A0= 0006                    8652      dc.w    KEY_DIV-TAB_STAR            * /
00B030A2= 5E FF                   8653      dc.b    '^',-1
00B030A4= 01A9                    8654      dc.w    KEY_POWER-TAB_STAR      * ^
00B030A6= 41 01                   8655      dc.b    'A',1
00B030A8= 0018                    8656      dc.w    KEY_AND-TAB_STAR            * AND
00B030AA= 45 01                   8657      dc.b    'E',1
00B030AC= 0074                    8658      dc.w    KEY_EOR-TAB_STAR            * EOR
00B030AE= 4F 00                   8659      dc.b    'O',0
00B030B0= 00F5                    8660      dc.w    KEY_OR-TAB_STAR         * OR
00B030B2= 3E 00                   8661      dc.b    '>',0
00B030B4= 000E                    8662      dc.w    KEY_RSHIFT-TAB_STAR     * >>
00B030B6= 3C 00                   8663      dc.b    '<',0
00B030B8= 0008                    8664      dc.w    KEY_LSHIFT-TAB_STAR     * <<
00B030BA= 3E FF                   8665      dc.b    '>',-1
00B030BC= 0010                    8666      dc.w    KEY_GT-TAB_STAR         * >
00B030BE= 3D FF                   8667      dc.b    '=',-1
00B030C0= 000C                    8668      dc.w    KEY_EQUAL-TAB_STAR      * =
00B030C2= 3C FF                   8669      dc.b    '<',-1
00B030C4= 000A                    8670      dc.w    KEY_LT-TAB_STAR         * <
00B030C6                          8671  
00B030C6= 53 02                   8672      dc.b    'S',2
00B030C8= 0140                    8673      dc.w    KEY_SGN-TAB_STAR            * SGN(
00B030CA= 49 02                   8674      dc.b    'I',2
00B030CC= 00A3                    8675      dc.w    KEY_INT-TAB_STAR            * INT(
00B030CE= 41 02                   8676      dc.b    'A',2
00B030D0= 0014                    8677      dc.w    KEY_ABS-TAB_STAR            * ABS(
00B030D2= 55 02                   8678      dc.b    'U',2
00B030D4= 0189                    8679      dc.w    KEY_USR-TAB_STAR            * USR(
00B030D6= 46 02                   8680      dc.b    'F',2
00B030D8= 0081                    8681      dc.w    KEY_FRE-TAB_STAR            * FRE(
00B030DA= 50 02                   8682      dc.b    'P',2
00B030DC= 0103                    8683      dc.w    KEY_POS-TAB_STAR            * POS(
00B030DE= 53 02                   8684      dc.b    'S',2
00B030E0= 014C                    8685      dc.w    KEY_SQR-TAB_STAR            * SQR(
00B030E2= 52 02                   8686      dc.b    'R',2
00B030E4= 012F                    8687      dc.w    KEY_RND-TAB_STAR            * RND(
00B030E6= 4C 02                   8688      dc.b    'L',2
00B030E8= 00C9                    8689      dc.w    KEY_LOG-TAB_STAR            * LOG(
00B030EA= 45 02                   8690      dc.b    'E',2
00B030EC= 0077                    8691      dc.w    KEY_EXP-TAB_STAR            * EXP(
00B030EE= 43 02                   8692      dc.b    'C',2
00B030F0= 004F                    8693      dc.w    KEY_COS-TAB_STAR            * COS(
00B030F2= 53 02                   8694      dc.b    'S',2
00B030F4= 0144                    8695      dc.w    KEY_SIN-TAB_STAR            * SIN(
00B030F6= 54 02                   8696      dc.b    'T',2
00B030F8= 0166                    8697      dc.w    KEY_TAN-TAB_STAR            * TAN(
00B030FA= 41 02                   8698      dc.b    'A',2
00B030FC= 001F                    8699      dc.w    KEY_ATN-TAB_STAR            * ATN(
00B030FE= 50 03                   8700      dc.b    'P',3
00B03100= 00F8                    8701      dc.w    KEY_PEEK-TAB_STAR           * PEEK(
00B03102= 44 03                   8702      dc.b    'D',3
00B03104= 005B                    8703      dc.w    KEY_DEEK-TAB_STAR           * DEEK(
00B03106= 4C 03                   8704      dc.b    'L',3
00B03108= 00AF                    8705      dc.w    KEY_LEEK-TAB_STAR           * LEEK(
00B0310A= 4C 02                   8706      dc.b    'L',2
00B0310C= 00BA                    8707      dc.w    KEY_LEN-TAB_STAR            * LEN(
00B0310E= 53 03                   8708      dc.b    'S',3
00B03110= 0158                    8709      dc.w    KEY_STRS-TAB_STAR           * STR$(
00B03112= 56 02                   8710      dc.b    'V',2
00B03114= 018E                    8711      dc.w    KEY_VAL-TAB_STAR            * VAL(
00B03116= 41 02                   8712      dc.b    'A',2
00B03118= 001B                    8713      dc.w    KEY_ASC-TAB_STAR            * ASC(
00B0311A= 55 05                   8714      dc.b    'U',5
00B0311C= 0176                    8715      dc.w    KEY_UCASES-TAB_STAR     * UCASE$(
00B0311E= 4C 05                   8716      dc.b    'L',5
00B03120= 00A8                    8717      dc.w    KEY_LCASES-TAB_STAR     * LCASE$(
00B03122= 43 03                   8718      dc.b    'C',3
00B03124= 0041                    8719      dc.w    KEY_CHRS-TAB_STAR           * CHR$(
00B03126= 48 03                   8720      dc.b    'H',3
00B03128= 0093                    8721      dc.w    KEY_HEXS-TAB_STAR           * HEX$(
00B0312A= 42 03                   8722      dc.b    'B',3
00B0312C= 0024                    8723      dc.w    KEY_BINS-TAB_STAR           * BIN$(
00B0312E= 42 05                   8724      dc.b    'B',5
00B03130= 0035                    8725      dc.w    KEY_BITTST-TAB_STAR     * BITTST(
00B03132= 4D 02                   8726      dc.b    'M',2
00B03134= 00D6                    8727      dc.w    KEY_MAX-TAB_STAR            * MAX(
00B03136= 4D 02                   8728      dc.b    'M',2
00B03138= 00DF                    8729      dc.w    KEY_MIN-TAB_STAR            * MIN(
00B0313A= 52 05                   8730      dc.b    'R',5
00B0313C= 010D                    8731      dc.w    KEY_RAM-TAB_STAR            * RAMBASE
00B0313E= 50 00                   8732      dc.b    'P',0
00B03140= 00FD                    8733      dc.w    KEY_PI-TAB_STAR         * PI
00B03142= 54 03                   8734      dc.b    'T',3
00B03144= 0170                    8735      dc.w    KEY_TWOPI-TAB_STAR      * TWOPI
00B03146= 56 05                   8736      dc.b    'V',5
00B03148= 0192                    8737      dc.w    KEY_VPTR-TAB_STAR           * VARPTR(
00B0314A= 53 03                   8738      dc.b    'S',3
00B0314C= 0137                    8739      dc.w    KEY_SADD-TAB_STAR           * SADD(
00B0314E= 4C 04                   8740      dc.b    'L',4
00B03150= 00B4                    8741      dc.w    KEY_LEFTS-TAB_STAR      * LEFT$(
00B03152= 52 05                   8742      dc.b    'R',5
00B03154= 0128                    8743      dc.w    KEY_RIGHTS-TAB_STAR     * RIGHT$(
00B03156= 4D 03                   8744      dc.b    'M',3
00B03158= 00DA                    8745      dc.w    KEY_MIDS-TAB_STAR           * MID$(
00B0315A= 55 05                   8746      dc.b    'U',5
00B0315C= 0182                    8747      dc.w    KEY_USINGS-TAB_STAR     * USING$(
00B0315E                          8748  
00B0315E                          8749  
00B0315E                          8750  *************************************************************************************
00B0315E                          8751  *
00B0315E                          8752  * BASIC error messages
00B0315E                          8753  
00B0315E                          8754  LAB_BAER
00B0315E= 0030                    8755      dc.w    LAB_NF-LAB_BAER         * $00 NEXT without FOR
00B03160= 0041                    8756      dc.w    LAB_SN-LAB_BAER         * $02 syntax
00B03162= 0048                    8757      dc.w    LAB_RG-LAB_BAER         * $04 RETURN without GOSUB
00B03164= 005D                    8758      dc.w    LAB_OD-LAB_BAER         * $06 out of data
00B03166= 0069                    8759      dc.w    LAB_FC-LAB_BAER         * $08 function call
00B03168= 0077                    8760      dc.w    LAB_OV-LAB_BAER         * $0A overflow
00B0316A= 0080                    8761      dc.w    LAB_OM-LAB_BAER         * $0C out of memory
00B0316C= 008E                    8762      dc.w    LAB_US-LAB_BAER         * $0E undefined statement
00B0316E= 00A2                    8763      dc.w    LAB_BS-LAB_BAER         * $10 array bounds
00B03170= 00AF                    8764      dc.w    LAB_DD-LAB_BAER         * $12 double dimension array
00B03172= 00C0                    8765      dc.w    LAB_D0-LAB_BAER         * $14 divide by 0
00B03174= 00CF                    8766      dc.w    LAB_ID-LAB_BAER         * $16 illegal direct
00B03176= 00DE                    8767      dc.w    LAB_TM-LAB_BAER         * $18 type mismatch
00B03178= 00EC                    8768      dc.w    LAB_LS-LAB_BAER         * $1A long string
00B0317A= 00FC                    8769      dc.w    LAB_ST-LAB_BAER         * $1C string too complex
00B0317C= 010F                    8770      dc.w    LAB_CN-LAB_BAER         * $1E continue error
00B0317E= 011E                    8771      dc.w    LAB_UF-LAB_BAER         * $20 undefined function
00B03180= 0131                    8772      dc.w    LAB_LD-LAB_BAER         * $22 LOOP without DO
00B03182= 0141                    8773      dc.w    LAB_UV-LAB_BAER         * $24 undefined variable
00B03184= 0154                    8774      dc.w    LAB_UA-LAB_BAER         * $26 undimensioned array
00B03186= 0168                    8775      dc.w    LAB_WD-LAB_BAER         * $28 wrong dimensions
00B03188= 0179                    8776      dc.w    LAB_AD-LAB_BAER         * $2A address
00B0318A= 0181                    8777      dc.w    LAB_FO-LAB_BAER         * $2C format
00B0318C= 0188                    8778      dc.w    LAB_NI-LAB_BAER         * $2E not implemented
00B0318E                          8779  
00B0318E= 4E 45 58 54 20 77 ...   8780  LAB_NF  dc.b    'NEXT without FOR',$00
00B0319F= 53 79 6E 74 61 78 00    8781  LAB_SN  dc.b    'Syntax',$00
00B031A6= 52 45 54 55 52 4E ...   8782  LAB_RG  dc.b    'RETURN without GOSUB',$00
00B031BB= 4F 75 74 20 6F 66 ...   8783  LAB_OD  dc.b    'Out of DATA',$00
00B031C7= 46 75 6E 63 74 69 ...   8784  LAB_FC  dc.b    'Function call',$00
00B031D5= 4F 76 65 72 66 6C ...   8785  LAB_OV  dc.b    'Overflow',$00
00B031DE= 4F 75 74 20 6F 66 ...   8786  LAB_OM  dc.b    'Out of memory',$00
00B031EC= 55 6E 64 65 66 69 ...   8787  LAB_US  dc.b    'Undefined statement',$00
00B03200= 41 72 72 61 79 20 ...   8788  LAB_BS  dc.b    'Array bounds',$00
00B0320D= 44 6F 75 62 6C 65 ...   8789  LAB_DD  dc.b    'Double dimension',$00
00B0321E= 44 69 76 69 64 65 ...   8790  LAB_D0  dc.b    'Divide by zero',$00
00B0322D= 49 6C 6C 65 67 61 ...   8791  LAB_ID  dc.b    'Illegal direct',$00
00B0323C= 54 79 70 65 20 6D ...   8792  LAB_TM  dc.b    'Type mismatch',$00
00B0324A= 53 74 72 69 6E 67 ...   8793  LAB_LS  dc.b    'String too long',$00
00B0325A= 53 74 72 69 6E 67 ...   8794  LAB_ST  dc.b    'String too complex',$00
00B0326D= 43 61 6E 27 74 20 ...   8795  LAB_CN  dc.b    'Can''t continue',$00
00B0327C= 55 6E 64 65 66 69 ...   8796  LAB_UF  dc.b    'Undefined function',$00
00B0328F= 4C 4F 4F 50 20 77 ...   8797  LAB_LD  dc.b    'LOOP without DO',$00
00B0329F= 55 6E 64 65 66 69 ...   8798  LAB_UV  dc.b    'Undefined variable',$00
00B032B2= 55 6E 64 69 6D 65 ...   8799  LAB_UA  dc.b    'Undimensioned array',$00
00B032C6= 57 72 6F 6E 67 20 ...   8800  LAB_WD  dc.b    'Wrong dimensions',$00
00B032D7= 41 64 64 72 65 73 ...   8801  LAB_AD  dc.b    'Address',$00
00B032DF= 46 6F 72 6D 61 74 00    8802  LAB_FO  dc.b    'Format',$00
00B032E6= 4E 6F 74 20 69 6D ...   8803  LAB_NI  dc.b    'Not implemented',$00
00B032F6                          8804  
00B032F6                          8805  
00B032F6                          8806  *************************************************************************************
00B032F6                          8807  *
00B032F6                          8808  * keyword table for line (un)crunching
00B032F6                          8809  
00B032F6                          8810  * [keyword,token
00B032F6                          8811  * [keyword,token]]
00B032F6                          8812  * end marker (#$00)
00B032F6                          8813  
00B032F6                          8814  TAB_STAR
00B032F6                          8815  KEY_MULT
00B032F6= B4 00                   8816      dc.b TK_MULT,$00                * *
00B032F8                          8817  TAB_PLUS
00B032F8                          8818  KEY_PLUS
00B032F8= B2 00                   8819      dc.b TK_PLUS,$00                * +
00B032FA                          8820  TAB_MNUS
00B032FA                          8821  KEY_MINUS
00B032FA= B3 00                   8822      dc.b TK_MINUS,$00               * -
00B032FC                          8823  TAB_SLAS
00B032FC                          8824  KEY_DIV
00B032FC= B5 00                   8825      dc.b TK_DIV,$00             * /
00B032FE                          8826  TAB_LESS
00B032FE                          8827  KEY_LSHIFT
00B032FE= 3C BB                   8828      dc.b    '<',TK_LSHIFT           * <<
00B03300                          8829  KEY_LT
00B03300= BE                      8830      dc.b TK_LT                  * <
00B03301= 00                      8831      dc.b    $00
00B03302                          8832  TAB_EQUL
00B03302                          8833  KEY_EQUAL
00B03302= BD 00                   8834      dc.b TK_EQUAL,$00               * =
00B03304                          8835  TAB_MORE
00B03304                          8836  KEY_RSHIFT
00B03304= 3E BA                   8837      dc.b    '>',TK_RSHIFT           * >>
00B03306                          8838  KEY_GT
00B03306= BC                      8839      dc.b TK_GT                  * >
00B03307= 00                      8840      dc.b    $00
00B03308                          8841  TAB_QEST
00B03308= 9E 00                   8842      dc.b TK_PRINT,$00               * ?
00B0330A                          8843  TAB_ASCA
00B0330A                          8844  KEY_ABS
00B0330A= 42 53 28 C1             8845      dc.b    'BS(',TK_ABS            * ABS(
00B0330E                          8846  KEY_AND
00B0330E= 4E 44 B7                8847      dc.b    'ND',TK_AND             * AND
00B03311                          8848  KEY_ASC
00B03311= 53 43 28 D3             8849      dc.b    'SC(',TK_ASC            * ASC(
00B03315                          8850  KEY_ATN
00B03315= 54 4E 28 CC             8851      dc.b    'TN(',TK_ATN            * ATN(
00B03319= 00                      8852      dc.b    $00
00B0331A                          8853  TAB_ASCB
00B0331A                          8854  KEY_BINS
00B0331A= 49 4E 24 28 D8          8855      dc.b    'IN$(',TK_BINS          * BIN$(
00B0331F                          8856  KEY_BITCLR
00B0331F= 49 54 43 4C 52 A7       8857      dc.b    'ITCLR',TK_BITCLR           * BITCLR
00B03325                          8858  KEY_BITSET
00B03325= 49 54 53 45 54 A6       8859      dc.b    'ITSET',TK_BITSET           * BITSET
00B0332B                          8860  KEY_BITTST
00B0332B= 49 54 54 53 54 28 D9    8861      dc.b    'ITTST(',TK_BITTST      * BITTST(
00B03332= 00                      8862      dc.b    $00
00B03333                          8863  TAB_ASCC
00B03333                          8864  KEY_CALL
00B03333= 41 4C 4C 9B             8865      dc.b    'ALL',TK_CALL           * CALL
00B03337                          8866  KEY_CHRS
00B03337= 48 52 24 28 D6          8867      dc.b    'HR$(',TK_CHRS          * CHR$(
00B0333C                          8868  KEY_CLEAR
00B0333C= 4C 45 41 52 A1          8869      dc.b    'LEAR',TK_CLEAR         * CLEAR
00B03341                          8870  KEY_CONT
00B03341= 4F 4E 54 9F             8871      dc.b    'ONT',TK_CONT           * CONT
00B03345                          8872  KEY_COS
00B03345= 4F 53 28 C9             8873      dc.b    'OS(',TK_COS            * COS(
00B03349= 00                      8874      dc.b    $00
00B0334A                          8875  TAB_ASCD
00B0334A                          8876  KEY_DATA
00B0334A= 41 54 41 83             8877      dc.b    'ATA',TK_DATA           * DATA
00B0334E                          8878  KEY_DEC
00B0334E= 45 43 88                8879      dc.b    'EC',TK_DEC             * DEC
00B03351                          8880  KEY_DEEK
00B03351= 45 45 4B 28 CE          8881      dc.b    'EEK(',TK_DEEK          * DEEK(
00B03356                          8882  KEY_DEF
00B03356= 45 46 97                8883      dc.b    'EF',TK_DEF             * DEF
00B03359                          8884  KEY_DIM
00B03359= 49 4D 85                8885      dc.b    'IM',TK_DIM             * DIM
00B0335C                          8886  KEY_DOKE
00B0335C= 4F 4B 45 99             8887      dc.b    'OKE',TK_DOKE           * DOKE
00B03360                          8888  KEY_DO
00B03360= 4F 9C                   8889      dc.b    'O',TK_DO               * DO
00B03362= 00                      8890      dc.b    $00
00B03363                          8891  TAB_ASCE
00B03363                          8892  KEY_ELSE
00B03363= 4C 53 45 A9             8893      dc.b    'LSE',TK_ELSE           * ELSE
00B03367                          8894  KEY_END
00B03367= 4E 44 80                8895      dc.b    'ND',TK_END             * END
00B0336A                          8896  KEY_EOR
00B0336A= 4F 52 B8                8897      dc.b    'OR',TK_EOR             * EOR
00B0336D                          8898  KEY_EXP
00B0336D= 58 50 28 C8             8899      dc.b    'XP(',TK_EXP            * EXP(
00B03371= 00                      8900      dc.b    $00
00B03372                          8901  TAB_ASCF
00B03372                          8902  KEY_FOR
00B03372= 4F 52 81                8903      dc.b    'OR',TK_FOR             * FOR
00B03375                          8904  KEY_FN
00B03375= 4E AB                   8905      dc.b    'N',TK_FN               * FN
00B03377                          8906  KEY_FRE
00B03377= 52 45 28 C3             8907      dc.b    'RE(',TK_FRE            * FRE(
00B0337B= 00                      8908      dc.b    $00
00B0337C                          8909  TAB_ASCG
00B0337C                          8910  KEY_GET
00B0337C= 45 54 A4                8911      dc.b    'ET',TK_GET             * GET
00B0337F                          8912  KEY_GOTO
00B0337F= 4F 54 4F 89             8913      dc.b    'OTO',TK_GOTO           * GOTO
00B03383                          8914  KEY_GOSUB
00B03383= 4F 53 55 42 8D          8915      dc.b    'OSUB',TK_GOSUB         * GOSUB
00B03388= 00                      8916      dc.b    $00
00B03389                          8917  TAB_ASCH
00B03389                          8918  KEY_HEXS
00B03389= 45 58 24 28 D7 00       8919      dc.b    'EX$(',TK_HEXS,$00      * HEX$(
00B0338F                          8920  TAB_ASCI
00B0338F                          8921  KEY_IF
00B0338F= 46 8B                   8922      dc.b    'F',TK_IF               * IF
00B03391                          8923  KEY_INC
00B03391= 4E 43 93                8924      dc.b    'NC',TK_INC             * INC
00B03394                          8925  KEY_INPUT
00B03394= 4E 50 55 54 84          8926      dc.b    'NPUT',TK_INPUT         * INPUT
00B03399                          8927  KEY_INT
00B03399= 4E 54 28 C0             8928      dc.b    'NT(',TK_INT            * INT(
00B0339D= 00                      8929      dc.b    $00
00B0339E                          8930  TAB_ASCL
00B0339E                          8931  KEY_LCASES
00B0339E= 43 41 53 45 24 28 D5    8932      dc.b    'CASE$(',TK_LCASES      * LCASE$(
00B033A5                          8933  KEY_LEEK
00B033A5= 45 45 4B 28 CF          8934      dc.b    'EEK(',TK_LEEK          * LEEK(
00B033AA                          8935  KEY_LEFTS
00B033AA= 45 46 54 24 28 E1       8936      dc.b    'EFT$(',TK_LEFTS            * LEFT$(
00B033B0                          8937  KEY_LEN
00B033B0= 45 4E 28 D0             8938      dc.b    'EN(',TK_LEN            * LEN(
00B033B4                          8939  KEY_LET
00B033B4= 45 54 87                8940      dc.b    'ET',TK_LET             * LET
00B033B7                          8941  KEY_LIST
00B033B7= 49 53 54 A0             8942      dc.b    'IST',TK_LIST           * LIST
00B033BB                          8943  KEY_LOAD
00B033BB= 4F 41 44 95             8944      dc.b    'OAD',TK_LOAD           * LOAD
00B033BF                          8945  KEY_LOG
00B033BF= 4F 47 28 C7             8946      dc.b    'OG(',TK_LOG            * LOG(
00B033C3                          8947  KEY_LOKE
00B033C3= 4F 4B 45 9A             8948      dc.b    'OKE',TK_LOKE           * LOKE
00B033C7                          8949  KEY_LOOP
00B033C7= 4F 4F 50 9D             8950      dc.b    'OOP',TK_LOOP           * LOOP
00B033CB= 00                      8951      dc.b    $00
00B033CC                          8952  TAB_ASCM
00B033CC                          8953  KEY_MAX
00B033CC= 41 58 28 DA             8954      dc.b    'AX(',TK_MAX            * MAX(
00B033D0                          8955  KEY_MIDS
00B033D0= 49 44 24 28 E3          8956      dc.b    'ID$(',TK_MIDS          * MID$(
00B033D5                          8957  KEY_MIN
00B033D5= 49 4E 28 DB             8958      dc.b    'IN(',TK_MIN            * MIN(
00B033D9= 00                      8959      dc.b    $00
00B033DA                          8960  TAB_ASCN
00B033DA                          8961  KEY_NEW
00B033DA= 45 57 A2                8962      dc.b    'EW',TK_NEW             * NEW
00B033DD                          8963  KEY_NEXT
00B033DD= 45 58 54 82             8964      dc.b    'EXT',TK_NEXT           * NEXT
00B033E1                          8965  KEY_NOT
00B033E1= 4F 54 AE                8966      dc.b    'OT',TK_NOT             * NOT
00B033E4                          8967  KEY_NULL
00B033E4= 55 4C 4C 92             8968      dc.b    'ULL',TK_NULL           * NULL
00B033E8= 00                      8969      dc.b    $00
00B033E9                          8970  TAB_ASCO
00B033E9                          8971  KEY_ON
00B033E9= 4E 91                   8972      dc.b    'N',TK_ON               * ON
00B033EB                          8973  KEY_OR
00B033EB= 52 B9                   8974      dc.b    'R',TK_OR               * OR
00B033ED= 00                      8975      dc.b    $00
00B033EE                          8976  TAB_ASCP
00B033EE                          8977  KEY_PEEK
00B033EE= 45 45 4B 28 CD          8978      dc.b    'EEK(',TK_PEEK          * PEEK(
00B033F3                          8979  KEY_PI
00B033F3= 49 DD                   8980      dc.b    'I',TK_PI               * PI
00B033F5                          8981  KEY_POKE
00B033F5= 4F 4B 45 98             8982      dc.b    'OKE',TK_POKE           * POKE
00B033F9                          8983  KEY_POS
00B033F9= 4F 53 28 C4             8984      dc.b    'OS(',TK_POS            * POS(
00B033FD                          8985  KEY_PRINT
00B033FD= 52 49 4E 54 9E          8986      dc.b    'RINT',TK_PRINT         * PRINT
00B03402= 00                      8987      dc.b    $00
00B03403                          8988  TAB_ASCR
00B03403                          8989  KEY_RAM
00B03403= 41 4D 42 41 53 45 DC    8990      dc.b    'AMBASE',TK_RAM         * RAMBASE
00B0340A                          8991  KEY_READ
00B0340A= 45 41 44 86             8992      dc.b    'EAD',TK_READ           * READ
00B0340E                          8993  KEY_REM
00B0340E= 45 4D 8F                8994      dc.b    'EM',TK_REM             * REM
00B03411                          8995  KEY_RESTORE
00B03411= 45 53 54 4F 52 45 8C    8996      dc.b    'ESTORE',TK_RESTORE     * RESTORE
00B03418                          8997  KEY_RETURN
00B03418= 45 54 55 52 4E 8E       8998      dc.b    'ETURN',TK_RETURN           * RETURN
00B0341E                          8999  KEY_RIGHTS
00B0341E= 49 47 48 54 24 28 E2    9000      dc.b    'IGHT$(',TK_RIGHTS      * RIGHT$(
00B03425                          9001  KEY_RND
00B03425= 4E 44 28 C6             9002      dc.b    'ND(',TK_RND            * RND(
00B03429                          9003  KEY_RUN
00B03429= 55 4E 8A                9004      dc.b    'UN',TK_RUN             * RUN
00B0342C= 00                      9005      dc.b    $00
00B0342D                          9006  TAB_ASCS
00B0342D                          9007  KEY_SADD
00B0342D= 41 44 44 28 E0          9008      dc.b    'ADD(',TK_SADD          * SADD(
00B03432                          9009  KEY_SAVE
00B03432= 41 56 45 96             9010      dc.b    'AVE',TK_SAVE           * SAVE
00B03436                          9011  KEY_SGN
00B03436= 47 4E 28 BF             9012      dc.b    'GN(',TK_SGN            * SGN(
00B0343A                          9013  KEY_SIN
00B0343A= 49 4E 28 CA             9014      dc.b    'IN(',TK_SIN            * SIN(
00B0343E                          9015  KEY_SPC
00B0343E= 50 43 28 AC             9016      dc.b    'PC(',TK_SPC            * SPC(
00B03442                          9017  KEY_SQR
00B03442= 51 52 28 C5             9018      dc.b    'QR(',TK_SQR            * SQR(
00B03446                          9019  KEY_STEP
00B03446= 54 45 50 AF             9020      dc.b    'TEP',TK_STEP           * STEP
00B0344A                          9021  KEY_STOP
00B0344A= 54 4F 50 90             9022      dc.b    'TOP',TK_STOP           * STOP
00B0344E                          9023  KEY_STRS
00B0344E= 54 52 24 28 D1          9024      dc.b    'TR$(',TK_STRS          * STR$(
00B03453                          9025  KEY_SWAP
00B03453= 57 41 50 A5             9026      dc.b    'WAP',TK_SWAP           * SWAP
00B03457= 00                      9027      dc.b    $00
00B03458                          9028  TAB_ASCT
00B03458                          9029  KEY_TAB
00B03458= 41 42 28 A8             9030      dc.b    'AB(',TK_TAB            * TAB(
00B0345C                          9031  KEY_TAN
00B0345C= 41 4E 28 CB             9032      dc.b    'AN(',TK_TAN            * TAN
00B03460                          9033  KEY_THEN
00B03460= 48 45 4E AD             9034      dc.b    'HEN',TK_THEN           * THEN
00B03464                          9035  KEY_TO
00B03464= 4F AA                   9036      dc.b    'O',TK_TO               * TO
00B03466                          9037  KEY_TWOPI
00B03466= 57 4F 50 49 DE          9038      dc.b    'WOPI',TK_TWOPI         * TWOPI
00B0346B= 00                      9039      dc.b    $00
00B0346C                          9040  TAB_ASCU
00B0346C                          9041  KEY_UCASES
00B0346C= 43 41 53 45 24 28 D4    9042      dc.b    'CASE$(',TK_UCASES      * UCASE$(
00B03473                          9043  KEY_UNTIL
00B03473= 4E 54 49 4C B0          9044      dc.b    'NTIL',TK_UNTIL         * UNTIL
00B03478                          9045  KEY_USINGS
00B03478= 53 49 4E 47 24 28 E4    9046      dc.b    'SING$(',TK_USINGS      * USING$(
00B0347F                          9047  KEY_USR
00B0347F= 53 52 28 C2             9048      dc.b    'SR(',TK_USR            * USR(
00B03483= 00                      9049      dc.b    $00
00B03484                          9050  TAB_ASCV
00B03484                          9051  KEY_VAL
00B03484= 41 4C 28 D2             9052      dc.b    'AL(',TK_VAL            * VAL(
00B03488                          9053  KEY_VPTR
00B03488= 41 52 50 54 52 28 DF    9054      dc.b    'ARPTR(',TK_VPTR            * VARPTR(
00B0348F= 00                      9055      dc.b    $00
00B03490                          9056  TAB_ASCW
00B03490                          9057  KEY_WAIT
00B03490= 41 49 54 94             9058      dc.b    'AIT',TK_WAIT           * WAIT
00B03494                          9059  KEY_WHILE
00B03494= 48 49 4C 45 B1          9060      dc.b    'HILE',TK_WHILE         * WHILE
00B03499                          9061  KEY_WIDTH
00B03499= 49 44 54 48 A3          9062      dc.b    'IDTH',TK_WIDTH         * WIDTH
00B0349E= 00                      9063      dc.b    $00
00B0349F                          9064  TAB_POWR
00B0349F                          9065  KEY_POWER
00B0349F= B6 00                   9066      dc.b    TK_POWER,$00            * ^
00B034A1                          9067  
00B034A1                          9068  
00B034A1                          9069  *************************************************************************************
00B034A1                          9070  *
00B034A1                          9071  * just messages
00B034A1                          9072  
00B034A1                          9073  LAB_BMSG
00B034A1= 0D 0A 42 72 65 61 ...   9074      dc.b    $0D,$0A,'Break',$00
00B034A9                          9075  LAB_EMSG
00B034A9= 20 45 72 72 6F 72 00    9076      dc.b    ' Error',$00
00B034B0                          9077  LAB_LMSG
00B034B0= 20 69 6E 20 6C 69 ...   9078      dc.b    ' in line ',$00
00B034BA                          9079  LAB_IMSG
00B034BA= 45 78 74 72 61 20 ...   9080      dc.b    'Extra ignored',$0D,$0A,$00
00B034CA                          9081  LAB_REDO
00B034CA= 52 65 64 6F 20 66 ...   9082      dc.b    'Redo from start',$0D,$0A,$00
00B034DC                          9083  LAB_RMSG
00B034DC= 0D 0A 52 65 61 64 ...   9084      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
00B034E6                          9085  LAB_SMSG
00B034E6= 20 42 79 74 65 73 ...   9086      dc.b    ' Bytes free',$0D,$0A,$0A
00B034F4= 45 6E 68 61 6E 63 ...   9087      dc.b    'Enhanced 68k BASIC Version 3.52',$0D,$0A,$00
00B03516                          9088  
00B03516                          9089  
00B03516                          9090  *************************************************************************************
00B03516                          9091  * EhBASIC keywords quick reference list                             *
00B03516                          9092  *************************************************************************************
00B03516                          9093  
00B03516                          9094  * glossary
00B03516                          9095  
00B03516                          9096  *       <.>       required
00B03516                          9097  *       {.|.}         one of required
00B03516                          9098  *       [.]       optional
00B03516                          9099  *       ...       may repeat as last
00B03516                          9100  
00B03516                          9101  *       any     = anything
00B03516                          9102  *       num     = number
00B03516                          9103  *       state       = statement
00B03516                          9104  *       n       = positive integer
00B03516                          9105  *       str     = string
00B03516                          9106  *       var     = variable
00B03516                          9107  *       nvar        = numeric variable
00B03516                          9108  *       svar        = string variable
00B03516                          9109  *       expr        = expression
00B03516                          9110  *       nexpr       = numeric expression
00B03516                          9111  *       sexpr       = string expression
00B03516                          9112  
00B03516                          9113  * statement separator
00B03516                          9114  
00B03516                          9115  * :     . [<state>] : [<state>]                     * done
00B03516                          9116  
00B03516                          9117  * number bases
00B03516                          9118  
00B03516                          9119  * %     . %<binary num>                         * done
00B03516                          9120  * $     . $<hex num>                            * done
00B03516                          9121  
00B03516                          9122  * commands
00B03516                          9123  
00B03516                          9124  * END       . END                                   * done
00B03516                          9125  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00B03516                          9126  * NEXT  . NEXT [<nvar>[,<nvar>]...]                 * done
00B03516                          9127  * DATA  . DATA [{num|["]str["]}[,{num|["]str["]}]...]       * done
00B03516                          9128  * INPUT . INPUT [<">str<">;] <var>[,<var>[,<var>]...]       * done
00B03516                          9129  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])            * done
00B03516                          9130  * READ  . READ <var>[,<var>[,<var>]...]             * done
00B03516                          9131  * LET       . [LET] <var>=<expr>                        * done
00B03516                          9132  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]               * done
00B03516                          9133  * GOTO  . GOTO <n>                              * done
00B03516                          9134  * RUN       . RUN [<n>]                             * done
00B03516                          9135  * IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00B03516                          9136  * RESTORE   . RESTORE [<n>]                         * done
00B03516                          9137  * GOSUB . GOSUB <n>                             * done
00B03516                          9138  * RETURN    . RETURN                                * done
00B03516                          9139  * REM       . REM [<any>]                           * done
00B03516                          9140  * STOP  . STOP                              * done
00B03516                          9141  * ON        . ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]      * done
00B03516                          9142  * NULL  . NULL <nexpr>                          * done
00B03516                          9143  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]               * done
00B03516                          9144  * WAIT  . WAIT <nexpr>,<nexpr>[,<nexpr>]                * done
00B03516                          9145  * LOAD  . LOAD [<sexpr>]                            * done for sim
00B03516                          9146  * SAVE  . SAVE [<sexpr>][,[<n>][-<n>]]              * done for sim
00B03516                          9147  * DEF       . DEF FN<var>(<var>)=<expr>                 * done
00B03516                          9148  * POKE  . POKE <nexpr>,<nexpr>                      * done
00B03516                          9149  * DOKE  . DOKE <nexpr>,<nexpr>                      * done
00B03516                          9150  * LOKE  . LOKE <nexpr>,<nexpr>                      * done
00B03516                          9151  * CALL  . CALL <nexpr>                          * done
00B03516                          9152  * DO        . DO                                    * done
00B03516                          9153  * LOOP  . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00B03516                          9154  * PRINT . PRINT [{;|,}][<expr>][{;|,}[<expr>]...]           * done
00B03516                          9155  * CONT  . CONT                              * done
00B03516                          9156  * LIST  . LIST [<n>][-<n>]                      * done
00B03516                          9157  * CLEAR . CLEAR                             * done
00B03516                          9158  * NEW       . NEW                                   * done
00B03516                          9159  * WIDTH . WIDTH [<n>][,<n>]                     * done
00B03516                          9160  * GET       . GET <var>                             * done
00B03516                          9161  * SWAP  . SWAP <var>,<var>                      * done
00B03516                          9162  * BITSET    . BITSET <nexpr>,<nexpr>                    * done
00B03516                          9163  * BITCLR    . BITCLR <nexpr>,<nexpr>                    * done
00B03516                          9164  
00B03516                          9165  * sub commands (may not start a statement)
00B03516                          9166  
00B03516                          9167  * TAB       . TAB(<nexpr>)                          * done
00B03516                          9168  * ELSE  . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00B03516                          9169  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00B03516                          9170  * FN        . FN <var>(<expr>)                      * done
00B03516                          9171  * SPC       . SPC(<nexpr>)                          * done
00B03516                          9172  * THEN  . IF <nexpr> {THEN <{n|comm}>|GOTO <n>}         * done
00B03516                          9173  * NOT       . NOT <nexpr>                           * done
00B03516                          9174  * STEP  . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00B03516                          9175  * UNTIL . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00B03516                          9176  * WHILE . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00B03516                          9177  
00B03516                          9178  * operators
00B03516                          9179  
00B03516                          9180  * +     . [expr] + <expr>                           * done
00B03516                          9181  * -     . [nexpr] - <nexpr>                     * done
00B03516                          9182  * *     . <nexpr> * <nexpr>                     * done fast hardware
00B03516                          9183  * /     . <nexpr> / <nexpr>                     * done fast hardware
00B03516                          9184  * ^     . <nexpr> ^ <nexpr>                     * done
00B03516                          9185  * AND       . <nexpr> AND <nexpr>                       * done
00B03516                          9186  * EOR       . <nexpr> EOR <nexpr>                       * done
00B03516                          9187  * OR        . <nexpr> OR <nexpr>                        * done
00B03516                          9188  * >>        . <nexpr> >> <nexpr>                        * done
00B03516                          9189  * <<        . <nexpr> << <nexpr>                        * done
00B03516                          9190  
00B03516                          9191  * compare functions
00B03516                          9192  
00B03516                          9193  * <     . <expr> < <expr>                           * done
00B03516                          9194  * =     . <expr> = <expr>                           * done
00B03516                          9195  * >     . <expr> > <expr>                           * done
00B03516                          9196  
00B03516                          9197  * functions
00B03516                          9198  
00B03516                          9199  * SGN       . SGN(<nexpr>)                          * done
00B03516                          9200  * INT       . INT(<nexpr>)                          * done
00B03516                          9201  * ABS       . ABS(<nexpr>)                          * done
00B03516                          9202  * USR       . USR(<expr>)                           * done
00B03516                          9203  * FRE       . FRE(<expr>)                           * done
00B03516                          9204  * POS       . POS(<expr>)                           * done
00B03516                          9205  * SQR       . SQR(<nexpr>)                          * done fast shift/sub
00B03516                          9206  * RND       . RND(<nexpr>)                          * done 32 bit PRNG
00B03516                          9207  * LOG       . LOG(<nexpr>)                          * done fast cordic
00B03516                          9208  * EXP       . EXP(<nexpr>)                          * done fast cordic
00B03516                          9209  * COS       . COS(<nexpr>)                          * done fast cordic
00B03516                          9210  * SIN       . SIN(<nexpr>)                          * done fast cordic
00B03516                          9211  * TAN       . TAN(<nexpr>)                          * done fast cordic
00B03516                          9212  * ATN       . ATN(<nexpr>)                          * done fast cordic
00B03516                          9213  * PEEK  . PEEK(<nexpr>)                         * done
00B03516                          9214  * DEEK  . DEEK(<nexpr>)                         * done
00B03516                          9215  * LEEK  . LEEK(<nexpr>)                         * done
00B03516                          9216  * LEN       . LEN(<sexpr>)                          * done
00B03516                          9217  * STR$  . STR$(<nexpr>)                         * done
00B03516                          9218  * VAL       . VAL(<sexpr>)                          * done
00B03516                          9219  * ASC       . ASC(<sexpr>)                          * done
00B03516                          9220  * UCASE$    . UCASE$(<sexpr>)                           * done
00B03516                          9221  * LCASE$    . LCASE$(<sexpr>)                           * done
00B03516                          9222  * CHR$  . CHR$(<nexpr>)                         * done
00B03516                          9223  * HEX$  . HEX$(<nexpr>)                         * done
00B03516                          9224  * BIN$  . BIN$(<nexpr>)                         * done
00B03516                          9225  * BTST  . BTST(<nexpr>,<nexpr>)                     * done
00B03516                          9226  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00B03516                          9227  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00B03516                          9228  * PI        . PI                                    * done
00B03516                          9229  * TWOPI . TWOPI                             * done
00B03516                          9230  * VARPTR    . VARPTR(<var>)                         * done
00B03516                          9231  * SADD  . SADD(<svar>)                          * done
00B03516                          9232  * LEFT$ . LEFT$(<sexpr>,<nexpr>)                    * done
00B03516                          9233  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   * done
00B03516                          9234  * MID$  . MID$(<sexpr>,<nexpr>[,<nexpr>])               * done
00B03516                          9235  * USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])         * done
00B03516                          9236  
00B03516                          9237  
00B03516                          9238  *************************************************************************************
00B03516                          9239  
00B03516                          9240      END code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            B01AF0
ACIAC               F00009
ACIAD               F0000B
ASPTL               60C
ASRCH               63E
ASTRTL              610
BHSEND              63A
BIN2DEC             B02AAA
BINPR               B02690
BINSS               61A
BLINEL              4BA
BREAKF              640
CCBYTE              64D
CCFLAG              64C
CCNULL              64E
CFLAG               645
CLINEL              4B6
CODE_START          B0003E
COMP_F              647
COSOUT              618
CPNTRL              4BE
CVARAL              4D2
D1X02               B02A84
D1X10               B02A9A
D1X16               B02A76
DECSS               62A
DEFDIM              618
DES_SK              4F2
DES_SK_E            4DA
DIMCNT              63F
DLINEL              4C2
DOCMP               B006FA
DOREST              B006E6
DPTRL               4C6
DTYPEF              619
EARRYL              4A6
EMEML               4AE
ENDBHS              B0266A
EVEN                654
EXPCNT              611
EXPNEG              613
FAC1_E              5F8
FAC1_M              5F4
FAC1_S              5F9
FAC2_E              600
FAC2_M              5FC
FAC2_S              601
FAC_SC              602
FEND                8
FILE_BYTE           64F
FILE_ID             650
FLAG                603
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              614
GCLCTD              642
GETFIRST            B00ECA
GETPAIR             B00F86
GOPR                B0269A
HEXSS               632
IBUFFE              5F4
IBUFFS              4F4
ICLIM               64B
IMODE               644
INGET               B026EE
ITEMP               48E
KEY_ABS             B0330A
KEY_AND             B0330E
KEY_ASC             B03311
KEY_ATN             B03315
KEY_BINS            B0331A
KEY_BITCLR          B0331F
KEY_BITSET          B03325
KEY_BITTST          B0332B
KEY_CALL            B03333
KEY_CHRS            B03337
KEY_CLEAR           B0333C
KEY_CONT            B03341
KEY_COS             B03345
KEY_DATA            B0334A
KEY_DEC             B0334E
KEY_DEEK            B03351
KEY_DEF             B03356
KEY_DIM             B03359
KEY_DIV             B032FC
KEY_DO              B03360
KEY_DOKE            B0335C
KEY_ELSE            B03363
KEY_END             B03367
KEY_EOR             B0336A
KEY_EQUAL           B03302
KEY_EXP             B0336D
KEY_FN              B03375
KEY_FOR             B03372
KEY_FRE             B03377
KEY_GET             B0337C
KEY_GOSUB           B03383
KEY_GOTO            B0337F
KEY_GT              B03306
KEY_HEXS            B03389
KEY_IF              B0338F
KEY_INC             B03391
KEY_INPUT           B03394
KEY_INT             B03399
KEY_LCASES          B0339E
KEY_LEEK            B033A5
KEY_LEFTS           B033AA
KEY_LEN             B033B0
KEY_LET             B033B4
KEY_LIST            B033B7
KEY_LOAD            B033BB
KEY_LOG             B033BF
KEY_LOKE            B033C3
KEY_LOOP            B033C7
KEY_LSHIFT          B032FE
KEY_LT              B03300
KEY_MAX             B033CC
KEY_MIDS            B033D0
KEY_MIN             B033D5
KEY_MINUS           B032FA
KEY_MULT            B032F6
KEY_NEW             B033DA
KEY_NEXT            B033DD
KEY_NOT             B033E1
KEY_NULL            B033E4
KEY_ON              B033E9
KEY_OR              B033EB
KEY_PEEK            B033EE
KEY_PI              B033F3
KEY_PLUS            B032F8
KEY_POKE            B033F5
KEY_POS             B033F9
KEY_POWER           B0349F
KEY_PRINT           B033FD
KEY_RAM             B03403
KEY_READ            B0340A
KEY_REM             B0340E
KEY_RESTORE         B03411
KEY_RETURN          B03418
KEY_RIGHTS          B0341E
KEY_RND             B03425
KEY_RSHIFT          B03304
KEY_RUN             B03429
KEY_SADD            B0342D
KEY_SAVE            B03432
KEY_SGN             B03436
KEY_SIN             B0343A
KEY_SPC             B0343E
KEY_SQR             B03442
KEY_STEP            B03446
KEY_STOP            B0344A
KEY_STRS            B0344E
KEY_SWAP            B03453
KEY_TAB             B03458
KEY_TAN             B0345C
KEY_THEN            B03460
KEY_TO              B03464
KEY_TWOPI           B03466
KEY_UCASES          B0346C
KEY_UNTIL           B03473
KEY_USINGS          B03478
KEY_USR             B0347F
KEY_VAL             B03484
KEY_VPTR            B03488
KEY_WAIT            B03490
KEY_WHILE           B03494
KEY_WIDTH           B03499
KFCTSEED            26A3D110
LAB_11A5            B00B9A
LAB_11A6            B00B9C
LAB_11BD            B00BA8
LAB_1269            B0018C
LAB_1274            B0019A
LAB_127D            B001A2
LAB_127E            B001B0
LAB_1295            B001C4
LAB_12AE            B001E6
LAB_12B0            B001E8
LAB_12E6            B00208
LAB_12FF            B0023A
LAB_1301            B0023C
LAB_1303            B0025A
LAB_1325            B00272
LAB_132E            B00262
LAB_1330            B00264
LAB_134B            B00280
LAB_1357            B0029E
LAB_1359            B002A4
LAB_1374            B002C4
LAB_1378            B002CA
LAB_137F            B002D6
LAB_138E            B002DC
LAB_1392            B002E0
LAB_13A6            B00314
LAB_13AC            B0031C
LAB_13C6            B00346
LAB_13CC            B0034C
LAB_13D6            B0036E
LAB_13D8            B00374
LAB_13EA            B00380
LAB_13EC            B00382
LAB_13FF            B0039A
LAB_1401            B0039E
LAB_1408            B003AA
LAB_1410            B003B6
LAB_1417            B003C0
LAB_141B            B003C2
LAB_141F            B003D2
LAB_142A            B003D8
LAB_142C            B003E4
LAB_145E            B003FE
LAB_145F            B003F0
LAB_1463            B00406
LAB_1477            B00412
LAB_147A            B00418
LAB_1480            B00432
LAB_1491            B0043C
LAB_14BD            B0046C
LAB_14C0            B00470
LAB_14D4            B00490
LAB_14E2            B004AC
LAB_150C            B004BA
LAB_1519            B004CA
LAB_152E            B004D6
LAB_1540            B00502
LAB_15B3            B00562
LAB_15C2            B0058C
LAB_15D1            B00598
LAB_15DC            B00574
LAB_15F6            B00586
LAB_15FF            B005A6
LAB_1602            B005AA
LAB_1624            B0062E
LAB_1629            B005CE
LAB_1636            B005D2
LAB_1639            B005D8
LAB_163B            B005E4
LAB_1647            B005F0
LAB_164F            B005F6
LAB_16B0            B0068E
LAB_16D0            B006B2
LAB_1723            B0074C
LAB_1725            B00750
LAB_172C            B0073C
LAB_172D            B00744
LAB_174B            B00778
LAB_174E            B0079C
LAB_1750            B007A4
LAB_1752            B007B0
LAB_1754            B007C8
LAB_1756            B007B4
LAB_176C            B007E6
LAB_1773            B007F0
LAB_1785            B0080C
LAB_1786            B00838
LAB_17B7            B0084E
LAB_17B8            B0084A
LAB_17D5            B008C8
LAB_17D6            B008CC
LAB_1810            B008DE
LAB_1811            B008EE
LAB_1813            B008F4
LAB_1829            B0092C
LAB_182C            B00930
LAB_1831            B00936
LAB_185E            B00976
LAB_1866            B0097A
LAB_1880            B00A3C
LAB_1886            B00A46
LAB_188A            B00A4A
LAB_188B            B00988
LAB_1898            B00996
LAB_18A2            B009A0
LAB_18B7            B009C2
LAB_18B8            B009CE
LAB_18BD            B009D4
LAB_18C3            B009DE
LAB_18C6            B009E2
LAB_18CD            B009EC
LAB_18E3            B009F6
LAB_18F0            B00A16
LAB_18F7            B00A24
LAB_18F9            B00A28
LAB_1904            B00A4E
LAB_1913            B00A60
LAB_1934            B00A86
LAB_1953            B00A9A
LAB_195B            B00AA2
LAB_1961            B00AAC
LAB_1984            B00ACC
LAB_1985            B00AD0
LAB_1986            B00AD4
LAB_1999            B00AE8
LAB_19B0            B00AFA
LAB_19B6            B00B0A
LAB_19C2            B00B1A
LAB_19DD            B00B2E
LAB_19F6            B00B4E
LAB_1A03            B00B5C
LAB_1A0E            B00B6C
LAB_1A1B            B00B72
LAB_1A46            B00B8C
LAB_1A90            B00C0A
LAB_1A9B            B00C18
LAB_1ABA            B00C42
LAB_1ACD            B00C6E
LAB_1ADB            B00C7A
LAB_1ADE            B00C7E
LAB_1AE0            B00C94
LAB_1AFA            B00CAE
LAB_1B0B            B00CC4
LAB_1B13            B00CCC
LAB_1B1C            B00CDC
LAB_1B1D            B00CDE
LAB_1B2A            B00CF0
LAB_1B3C            B00D0C
LAB_1B43            B00C52
LAB_1B78            B00D18
LAB_1B7B            B00D1C
LAB_1B7D            B00D1E
LAB_1B84            B00D28
LAB_1B86            B00D2C
LAB_1B9D            B00D50
LAB_1BC1            B00D80
LAB_1BD0            B00DEE
LAB_1BE7            B00E08
LAB_1BF3            B00D8C
LAB_1BF7            B00D92
LAB_1BFB            B00D96
LAB_1C01            B00D9E
LAB_1C11            B00DC6
LAB_1C13            B00DCC
LAB_1C18            B00DD4
LAB_1C19            B00DD8
LAB_1C1A            B00DE8
LAB_1C2A            B00E46
LAB_1CAE            B00EEE
LAB_1CB5            B00F0C
LAB_1CD4            B00F16
LAB_1CD5            B00F1C
LAB_1CD6            B00F1E
LAB_1CDB            B00F2E
LAB_1CE6            B00F20
LAB_1CF2            B00F30
LAB_1CFE            B00F46
LAB_1D10            B00FBE
LAB_1D12            B00FC2
LAB_1D2D            B00FD4
LAB_1D2E            B00FE0
LAB_1D44            B00FFC
LAB_1D45            B0100C
LAB_1D48            B01020
LAB_1D49            B01028
LAB_1D4A            B0102C
LAB_1D4B            B0103C
LAB_1D5D            B01044
LAB_1D5E            B0104A
LAB_1D83            B00FAE
LAB_1D8A            B00FA8
LAB_1D94            B0105E
LAB_1D96            B02DA0
LAB_1D98            B01068
LAB_1DAC            B01082
LAB_1DAE            B01084
LAB_1DAF            B01090
LAB_1DB0            B0109E
LAB_1DB1            B010A2
LAB_1DB2            B010A6
LAB_1DD7            B010BE
LAB_1DE6            B010D8
LAB_1E17            B0111A
LAB_1E1F            B01120
LAB_1E5C            B0115A
LAB_1E8D            B01176
LAB_1EA1            B01192
LAB_1EC0            B011BA
LAB_1ED6            B011E6
LAB_1ED8            B011F4
LAB_1EDF            B011AE
LAB_1F07            B01206
LAB_1F28            B01220
LAB_1F2C            B01226
LAB_1F5A            B01234
LAB_1F6A            B0125C
LAB_1F6B            B01268
LAB_1F7C            B0126E
LAB_1FB4            B0129C
LAB_1FD0            B012C8
LAB_201E            B01322
LAB_2043            B01370
LAB_2044            B013A2
LAB_2045            B013AC
LAB_204S            B01372
LAB_204T            B013A0
LAB_20AE            B013BE
LAB_20B4            B013C2
LAB_20BE            B013C8
LAB_20C9            B013EC
LAB_20CB            B013D8
LAB_20D0            B013E0
LAB_20D8            B013F6
LAB_20E0            B013FE
LAB_2115            B0141E
LAB_2117            B01436
LAB_2128            B01450
LAB_2137            B01454
LAB_214B            B01474
LAB_2161            B0148A
LAB_2176            B01492
LAB_217E            B014A0
LAB_2183            B014BA
LAB_218B            B014C2
LAB_218F            B014C4
LAB_21C2            B014D0
LAB_21C4            B014D6
LAB_21D1            B0150A
LAB_2206            B01510
LAB_2212            B01538
LAB_2216            B014FA
LAB_2240            B01502
LAB_224D            B0153E
LAB_224E            B01554
LAB_229E            B01598
LAB_22A0            B015A4
LAB_22B6            B015B2
LAB_22BA            B015B6
LAB_22BD            B015C0
LAB_22E6            B015DA
LAB_2316            B0161A
LAB_2317            B0161C
LAB_231C            B01620
LAB_2358            B01654
LAB_2368            B01674
LAB_2441            B01866
LAB_2445            B0186A
LAB_2467            B018BA
LAB_2468            B018BE
LAB_249C            B018AC
LAB_24A8            B018C2
LAB_24B4            B018EC
LAB_24D0            B018F8
LAB_24D5            B01904
LAB_24D6            B0191E
LAB_24D7            B0192C
LAB_24D8            B01932
LAB_24D9            B01912
LAB_24DA            B01938
LAB_24F7            B018DC
LAB_24F8            B018E2
LAB_2778            B01BA0
LAB_277C            B01BA2
LAB_279B            B01BC6
LAB_27BA            B01BD4
LAB_27C3            B01BF0
LAB_27C4            B01BFA
LAB_27CA            B01C00
LAB_27CE            B01C08
LAB_27D0            B01C0C
LAB_27DB            B01C1A
LAB_27F0            B01ED6
LAB_27F1            B01EEC
LAB_27F2            B01EF2
LAB_27F3            B01EF4
LAB_27FA            B01C32
LAB_2828            B01C52
LAB_282E            B01C58
LAB_282F            B01C5A
LAB_2831            B01C5E
LAB_284G            B01C80
LAB_284H            B01C92
LAB_284J            B01C94
LAB_284L            B01C88
LAB_2887            B02898
LAB_289A            B028C2
LAB_289C            B028C8
LAB_289D            B028CE
LAB_28FD            B028EA
LAB_28FE            B028F0
LAB_28FF            B028F6
LAB_2900            B02904
LAB_2901            B0290A
LAB_2902            B0295C
LAB_2903            B02964
LAB_2904            B02966
LAB_2953            B01CB4
LAB_295E            B01CC0
LAB_2967            B01CCC
LAB_2968            B01CD4
LAB_2969            B01CE6
LAB_296A            B01CF0
LAB_2970            B01D06
LAB_2978            B01D16
LAB_2989            B01D26
LAB_299C            B01D7A
LAB_29A7            B01DA2
LAB_29B7            B01DBA
LAB_29B9            B01D52
LAB_29C0            B01DC8
LAB_29C3            B01DE0
LAB_29D9            B01DFA
LAB_29E4            B01E0C
LAB_29F7            B01E20
LAB_29FB            B01E24
LAB_29FD            B01E2C
LAB_2A18            B01E3C
LAB_2A1A            B01E3E
LAB_2A21            B01E46
LAB_2A3B            B01E66
LAB_2A4B            B01E74
LAB_2A58            B01E88
LAB_2A68            B01EA0
LAB_2A74            B01EAC
LAB_2A89            B01EC8
LAB_2A8C            B01ECC
LAB_2A91            B01ED2
LAB_2A9A            B02F44
LAB_2A9B            B02F60
LAB_2X01            B02922
LAB_2X02            B0292A
LAB_2X03            B02938
LAB_2X04            B0293E
LAB_2X05            B02954
LAB_2Y01            B02974
LAB_2Y02            B0297C
LAB_2Y03            B02988
LAB_2Y04            B0298E
LAB_3216            B01B3A
LAB_32_16           B01B38
LAB_ABER            B0014E
LAB_ABS             B01C2A
LAB_AD              B032D7
LAB_ADD             B01888
LAB_ADER            B0011A
LAB_AND             B00EC2
LAB_ASC             B016FE
LAB_ATCD            B02274
LAB_ATGO            B02232
LAB_ATLE            B02250
LAB_ATN             B02214
LAB_ATNP            B0226E
LAB_AYFC            B012A8
LAB_BAER            B0315E
LAB_BHCB            B00EA8
LAB_BHSS            B00E82
LAB_BINS            B0264C
LAB_BITCLR          B022D6
LAB_BITSET          B022C6
LAB_BMSG            B034A1
LAB_BS              B03200
LAB_BTST            B022E6
LAB_CALL            B01846
LAB_CASC            B00F98
LAB_CATN            B0227A
LAB_CAUC            B00F9E
LAB_CBIN            B02A48
LAB_CBX1            B02A62
LAB_CBXN            B02A50
LAB_CCER            B00132
LAB_CHEX            B029E6
LAB_CHRS            B015E4
LAB_CHX1            B02A0C
LAB_CHX2            B02A30
LAB_CHX3            B02A28
LAB_CHXX            B029EE
LAB_CKRN            B012D0
LAB_CKTM            B00C34
LAB_CLEAR           B00454
LAB_CN              B0326D
LAB_COLD            B00054
LAB_CONT            B00640
LAB_CORD            B021A6
LAB_COS             B02136
LAB_CRLF            B00980
LAB_CTBL            B02E28
LAB_CTNM            B00C32
LAB_D0              B0321E
LAB_D002            B025B0
LAB_D00A            B025C0
LAB_D00E            B025D0
LAB_DATA            B0072E
LAB_DD              B0320D
LAB_DDER            B0014A
LAB_DEC             B0083E
LAB_DECI            B0089C
LAB_DEEK            B017C4
LAB_DEF             B012DA
LAB_DIM             B00F4A
LAB_DIV0            B01B32
LAB_DIVIDE          B01AB8
LAB_DIVX            B01B08
LAB_DO              B00672
LAB_DOKE            B017EE
LAB_DUPFMT          B02598
LAB_DZER            B00146
LAB_EMSG            B034A9
LAB_END             B005DA
LAB_EOR             B00EB2
LAB_EQUAL           B00ED8
LAB_ESML            B0204C
LAB_EVBY            B01716
LAB_EVEX            B00C48
LAB_EVEZ            B00C4A
LAB_EVIN            B010E4
LAB_EVIR            B010F4
LAB_EVNM            B00C30
LAB_EVPI            B010EC
LAB_EX1             B01F84
LAB_EXAD            B020D6
LAB_EXCC            B020BC
LAB_EXCM            B01FEE
LAB_EXNN            B020A8
LAB_EXOF            B01FA8
LAB_EXOL            B01FBE
LAB_EXOU            B01F94
LAB_EXP             B01FC8
LAB_EXPL            B020A2
LAB_EXPS            B02000
LAB_EXRN            B020AE
LAB_EXXF            B02A36
LAB_FB95            B026FE
LAB_FBA0            B026E2
LAB_FC              B031C7
LAB_FCER            B0015E
LAB_FO              B032DF
LAB_FOER            B00116
LAB_FOR             B0050E
LAB_FRE             B01292
LAB_FTBL            B02EC4
LAB_FTPP            B02E78
LAB_FVAR            B00FB6
LAB_GADB            B01768
LAB_GADW            B0177C
LAB_GARB            B0146A
LAB_GBYT            B00DAA
LAB_GEAD            B0179C
LAB_GET             B008FA
LAB_GETS            B00914
LAB_GFPN            B00800
LAB_GOSUB           B00684
LAB_GOTO            B00696
LAB_GOTS            B006A6
LAB_GSCH            B00626
LAB_GTBY            B01712
LAB_GTHAN           B01F76
LAB_GTWO            B01726
LAB_GVAL            B00D56
LAB_GVAR            B00FB8
LAB_HEXS            B0269E
LAB_ID              B0322D
LAB_IDER            B00142
LAB_IF              B00756
LAB_IGBY            B00DA8
LAB_IMSG            B034BA
LAB_INC             B00844
LAB_INCI            B00892
LAB_INCT            B00884
LAB_INLN            B00294
LAB_INPUT           B00A6E
LAB_INT             B01C9A
LAB_IRTS            B01CB2
LAB_ISHN            B02A08
LAB_KEYT            B02FCA
LAB_LAAD            B019B2
LAB_LCASE           B0167C
LAB_LD              B0328F
LAB_LDER            B0012A
LAB_LEEK            B017DA
LAB_LEFT            B015F4
LAB_LENS            B016F6
LAB_LET             B008A0
LAB_LIST            B00458
LAB_LMSG            B034B0
LAB_LOAD            B0183E
LAB_LOCC            B019B8
LAB_LOCX            B019D4
LAB_LOG             B0193A
LAB_LOKE            B017F4
LAB_LOLP            B019C2
LAB_LONE            B019F0
LAB_LONN            B019D8
LAB_LOOP            B006C4
LAB_LOWZ            B01A2A
LAB_LOXO            B019F6
LAB_LOXP            B019E6
LAB_LRMS            B00E60
LAB_LS              B0324A
LAB_LSHIFT          B00F56
LAB_LTHAN           B00EE2
LAB_LTPF            B021B6
LAB_LTPT            B021C6
LAB_LT_1            B01B46
LAB_MADD            B01A58
LAB_MAN1            B01B2C
LAB_MAX             B0270A
LAB_MAXN            B02716
LAB_MIDS            B01638
LAB_MIN             B02720
LAB_MINN            B0272C
LAB_MKCHR           B015E8
LAB_MMEC            B02736
LAB_MNOC            B01A52
LAB_MUEX            B01AA6
LAB_MUF1            B01A82
LAB_MUF2            B01A8C
LAB_MUF3            B01AA2
LAB_MULTIPLY        B01A2C
LAB_MUUF            B01AAC
LAB_NB1T            B01B7E
LAB_NEW             B00404
LAB_NEXT            B00B7A
LAB_NF              B0318E
LAB_NFER            B0016E
LAB_NI              B032E6
LAB_NOST            B00926
LAB_NSTT            B0279C
LAB_NULL            B00636
LAB_OD              B031BB
LAB_ODER            B00162
LAB_OFER            B0015A
LAB_OM              B031DE
LAB_OMER            B00156
LAB_ON              B007CC
LAB_OPPT            B02F10
LAB_OR              B00EBA
LAB_OV              B031D5
LAB_P004            B025EE
LAB_P008            B02604
LAB_P00C            B0260C
LAB_P00E            B02618
LAB_P010            B0261C
LAB_P018            B02636
LAB_P01A            B0263A
LAB_P01E            B02642
LAB_PEEK            B017B2
LAB_PFAC            B01B88
LAB_PHFA            B02746
LAB_PI              B02878
LAB_POKE            B017BE
LAB_POON            B01EF6
LAB_POS             B012C4
LAB_POWER           B01F12
LAB_POWP            B01F44
LAB_POZE            B01F06
LAB_PPBI            B00E56
LAB_PPFN            B00E48
LAB_PPFS            B00E3A
LAB_PRINT           B00934
LAB_PRNA            B009F8
LAB_PROCFO          B025D6
LAB_P_10            B02BBA
LAB_RAM             B0286E
LAB_READ            B00A94
LAB_REDO            B034CA
LAB_REM             B007C4
LAB_REMM            B01B5E
LAB_RESS            B0061A
LAB_RESTORE         B00608
LAB_RET0            B029D4
LAB_RETURN          B0071A
LAB_RG              B031A6
LAB_RGER            B00166
LAB_RIGHT           B01608
LAB_RMSG            B034DC
LAB_RND             B020E2
LAB_RSED            B02AD2
LAB_RSHIFT          B00F66
LAB_RTN0            B029D6
LAB_RTST            B01404
LAB_RUN             B0065E
LAB_RUNN            B0066C
LAB_SADD            B016DE
LAB_SAVE            B01842
LAB_SCCA            B00DA0
LAB_SCER            B00136
LAB_SCGB            B00D9A
LAB_SCL0            B0219C
LAB_SCLN            B003F2
LAB_SCZE            B0218E
LAB_SET1            B01B10
LAB_SGBY            B0170E
LAB_SGN             B01C18
LAB_SIN             B0214E
LAB_SIZOK           B00064
LAB_SLER            B0013A
LAB_SMSG            B034E6
LAB_SN              B0319F
LAB_SNBS            B00734
LAB_SNER            B0016A
LAB_SQE1            B02820
LAB_SQE2            B02826
LAB_SQNA            B0284E
LAB_SQNS            B02838
LAB_SQR             B027FC
LAB_SSLN            B003EA
LAB_ST              B0325A
LAB_STOP            B005E2
LAB_STRS            B013BA
LAB_SUBTRACT        B01874
LAB_SVAR            B00FB4
LAB_SVTB            B027CE
LAB_SWAP            B01808
LAB_TAN             B02114
LAB_TBSZ            B027AE
LAB_TM              B0323C
LAB_TMER            B0013E
LAB_TWOPI           B02888
LAB_U002            B0233E
LAB_U004            B02394
LAB_U005            B023A4
LAB_U006            B023A6
LAB_U008            B023BA
LAB_U009            B023DC
LAB_U00A            B023E4
LAB_U00B            B023EE
LAB_U00C            B02402
LAB_U00D            B02406
LAB_U00E            B02418
LAB_U00F            B02424
LAB_U010            B02428
LAB_U014            B0242E
LAB_U018            B02436
LAB_U01C            B0244C
LAB_U020            B02458
LAB_U022            B0245E
LAB_U026            B0246E
LAB_U02A            B02478
LAB_U02B            B02490
LAB_U02C            B02496
LAB_U02E            B024A8
LAB_U030            B024AC
LAB_U034            B024C2
LAB_U036            B024C8
LAB_U038            B024D0
LAB_U03C            B024D8
LAB_U03E            B024DE
LAB_U040            B024F6
LAB_U044            B02506
LAB_U046            B0252E
LAB_U048            B02530
LAB_U04A            B0253A
LAB_U04C            B0256C
LAB_UA              B032B2
LAB_UCASE           B016AC
LAB_UDER            B00122
LAB_UF              B0327C
LAB_UFAC            B01B6C
LAB_UFER            B0012E
LAB_US              B031EC
LAB_USER            B00152
LAB_USINGS          B02314
LAB_USR             B01836
LAB_UV              B0329F
LAB_UVER            B00126
LAB_VAL             B0173A
LAB_VALZ            B01762
LAB_VARCALL         B02860
LAB_VARPTR          B0285E
LAB_WAIT            B01850
LAB_WARM            464
LAB_WD              B032C6
LAB_WDER            B0011E
LAB_WDLP            B027E2
LAB_WDTH            B0277C
LAB_XDIV            B01B20
LAB_XERR            B00170
LAB_XGADW           B01796
LC_LOOP             B01692
LOOPALWAYS          B00700
LOOPDONE            B00714
LVARPL              4D6
L_DDIV              B01B66
L_DIVRND            B01B14
MAINLOOP            B021DE
N                   2
NEXTA               B021F0
NEXTB1              B0265C
NEXTB2              B02682
NEXTH1              B026AE
NEXTPRN             B020F0
NINC0               B020F8
NINC1               B020FE
NOBRK               0
NOLCASE             B016D4
NOSHIFT             B00F62
NOSTRING            B016DA
NOT2BIG             B00F7A
NOUCASE             B016A4
NOVAR               0
NULLCT              648
NUMEXP              610
OFCHR               23
OQUOTE              641
OUTLOOP             B021FE
PRG_STRT            654
PRNLWORD            604
PRSTK               63C
RAM_ADDR            2000
RAM_BASE            464
RAM_SIZE            8000
RAM_STRT            64
RDPTRL              4CA
RDRF                0
RTS_001             B00DC4
RTS_005             B00452
RTS_006             B00634
RTS_007             B00732
RTS_007A            B00748
RTS_008             B008F8
RTS_009             B009F4
RTS_011             B0126C
RTS_012             B0153C
RTS_013             B015B0
RTS_015             B01806
RTS_016             B018E0
RTS_017             B01BFE
RTS_020             B01F82
RTS_021             B022C4
RTS_022             B026EC
RTS_023             B027FA
RTS_024             B02A46
RTS_025             B02AA8
RXNOTREADY          B0002C
SARRYL              4A2
SFNCL               496
SMEML               492
SSTORL              4AA
SSTRL               49E
SUBEXIT             B02208
SUBLOOP             B021D6
SUFNXF              643
SUTILL              4B2
SVARL               49A
TABSIZ              646
TAB_ASCA            B0330A
TAB_ASCB            B0331A
TAB_ASCC            B03333
TAB_ASCD            B0334A
TAB_ASCE            B03363
TAB_ASCF            B03372
TAB_ASCG            B0337C
TAB_ASCH            B03389
TAB_ASCI            B0338F
TAB_ASCL            B0339E
TAB_ASCM            B033CC
TAB_ASCN            B033DA
TAB_ASCO            B033E9
TAB_ASCP            B033EE
TAB_ASCR            B03403
TAB_ASCS            B0342D
TAB_ASCT            B03458
TAB_ASCU            B0346C
TAB_ASCV            B03484
TAB_ASCW            B03490
TAB_ATNC            B02D28
TAB_CHRT            B02F60
TAB_EQUL            B03302
TAB_HTHET           B02DA8
TAB_LESS            B032FE
TAB_MNUS            B032FA
TAB_MORE            B03304
TAB_PLUS            B032F8
TAB_POWR            B0349F
TAB_QEST            B03308
TAB_SLAS            B032FC
TAB_SNCO            B02CA8
TAB_STAR            B032F6
TDRE                1
TK_ABS              C1
TK_AND              B7
TK_ASC              D3
TK_ATN              CC
TK_BINS             D8
TK_BITCLR           A7
TK_BITSET           A6
TK_BITTST           D9
TK_CALL             9B
TK_CHRS             D6
TK_CLEAR            A1
TK_CONT             9F
TK_COS              C9
TK_DATA             83
TK_DEC              88
TK_DEEK             CE
TK_DEF              97
TK_DIM              85
TK_DIV              B5
TK_DO               9C
TK_DOKE             99
TK_ELSE             A9
TK_END              80
TK_EOR              B8
TK_EQUAL            BD
TK_EXP              C8
TK_FN               AB
TK_FOR              81
TK_FRE              C3
TK_GET              A4
TK_GOSUB            8D
TK_GOTO             89
TK_GT               BC
TK_HEXS             D7
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              C0
TK_LCASES           D5
TK_LEEK             CF
TK_LEFTS            E1
TK_LEN              D0
TK_LET              87
TK_LIST             A0
TK_LOAD             95
TK_LOG              C7
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           BB
TK_LT               BE
TK_MAX              DA
TK_MIDS             E3
TK_MIN              DB
TK_MINUS            B3
TK_MULT             B4
TK_NEW              A2
TK_NEXT             82
TK_NOT              AE
TK_NULL             92
TK_ON               91
TK_OR               B9
TK_PEEK             CD
TK_PI               DD
TK_PLUS             B2
TK_POKE             98
TK_POS              C4
TK_POWER            B6
TK_PRINT            9E
TK_RAM              DC
TK_READ             86
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           E2
TK_RND              C6
TK_RSHIFT           BA
TK_RUN              8A
TK_SADD             E0
TK_SAVE             96
TK_SGN              BF
TK_SIN              CA
TK_SPC              AC
TK_SQR              C5
TK_STEP             AF
TK_STOP             90
TK_STRS             D1
TK_SWAP             A5
TK_TAB              A8
TK_TAN              CB
TK_THEN             AD
TK_TO               AA
TK_TWOPI            DE
TK_UCASES           D4
TK_UNTIL            B0
TK_USINGS           E4
TK_USR              C2
TK_VAL              D2
TK_VPTR             DF
TK_WAIT             94
TK_WHILE            B1
TK_WIDTH            A3
TOOBIG              B00F80
TPOS                649
TPOWER              63D
TWIDTH              64A
UC_LOOP             B016C2
USDSS               630
USRJMP              46A
USRJPV              46C
UT1_PL              608
VARNAME             4CE
VEC_CC              B026C8
VEC_IN              B00016
VEC_LD              B00032
VEC_OUT             B00004
VEC_SV              B00038
V_CTLC              488
V_CTLCV             48A
V_INPT              470
V_INPTV             472
V_LOAD              47C
V_LOADV             47E
V_OUTP              476
V_OUTPV             478
V_SAVE              482
V_SAVEV             484
WEXIT               B027D2
WRMJPV              466
