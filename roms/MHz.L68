00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 19-Jun-20 5:27:39 PM

00000000                             1  *************************************************************************************
00000000                             2  *                                                       *
00000000                             3  *   MHz benchmark for the EASy68k simulator 2004/4/4                    *
00000000                             4  *                                                       *
00000000                             5  *   This code attempts to guage the effective 68000 clock speed in MHz. This    *
00000000                             6  *   is not a serious benchmark test as there are too many factors to take into  *
00000000                             7  *   account when running in a multitasking environment. This is demonstrated    *
00000000                             8  *   by the, sometimes wildly, varying results.                      *
00000000                             9  *                                                       *
00000000                            10  *   A 1.8GHz PIII system gives results that vary around 16MHz               *
00000000                            11  *                                                       *
00000000                            12  *   More 68000 and other projects can be found on my website at ..          *
00000000                            13  *                                                       *
00000000                            14  *    http://mycorner.no-ip.org/index.html                           *
00000000                            15  *                                                       *
00000000                            16  *   mail : leeedavison@googlemail.com                               *
00000000                            17  *                                                       *
00000000                            18  *************************************************************************************
00000000                            19  
00000000                            20  *************************************************************************************
00000000                            21  * code start.
00000000                            22  
00001000                            23      ORG     $1000           * set origin
00001000                            24  
00001000                            25  start
00001000  41FA 011F                 26      LEA     (LAB_MMHz,PC),a0    * get pointer to "Too fast!",[CR][LF]
00001004  7E80                      27      MOVEQ       #-$80,d7        * set initial mask for 128 100ths, this is the
00001006                            28                          * q value used later in the speed calculations
00001006                            29  
00001006                            30  * this is the code that is used to gauge the speed of the CPU. the longer this
00001006                            31  * code runs the more accurate the result will be but the user will eventually
00001006                            32  * get bored and walk away, so the code can't run for too long. in this case it
00001006                            33  * runs for up to about four seconds depending on when it starts and how fast
00001006                            34  * the simulated processor runs. If you know that the count loop will overflow
00001006                            35  * the initial value of d7 can be set to take this into account. This will produce
00001006                            36  * results more frequently. e.g. if you know the loop count will overflow the first
00001006                            37  * time then use ..
00001006                            38  
00001006                            39  *   MOVEQ       #-$C0,d7        * set initial mask for 64 100ths...
00001006                            40  
00001006                            41  * first setup the timing variables
00001006                            42  
00001006                            43  LAB_time
00001006  2407                      44      MOVE.l  d7,d2           * copy mask
00001008  7600                      45      MOVEQ       #0,d3           * clear n counter
0000100A  7800                      46      MOVEQ       #0,d4           * clear m counter
0000100C                            47  
0000100C                            48  * now wait for the start of the next q time period
0000100C                            49  
0000100C  7008                      50      MOVEQ       #8,d0           * get 100ths of a second since midnight
0000100E  4E4F                      51      TRAP        #15
00001010  C481                      52      AND.l       d1,d2           * mask and copy q 100ths
00001012                            53  LAB_1_wait
00001012  7008                      54      MOVEQ       #8,d0           * get 100ths of a second since midnight
00001014  4E4F                      55      TRAP        #15         *
00001016  C287                      56      AND.l       d7,d1           * mask q 100ths
00001018  B481                      57      CMP.l       d1,d2           * compare with last q 100ths
0000101A  67F6                      58      BEQ.s       LAB_1_wait      * wait more if not yet changed
0000101C                            59  
0000101C                            60  * now loop and count until the next q time period
0000101C                            61  
0000101C  2401                      62      MOVE.l  d1,d2           * [4] copy q 100ths
0000101E                            63  LAB_1_count
0000101E  5243                      64      ADDQ.w  #1,d3           * [8] increment counter
00001020  6408                      65      BCC.s       LAB_1_ccc       * [10/.] branch if no overflow
00001022                            66  
00001022                            67  * if there is an overflow here then the period over which the count is done needs to
00001022                            68  * be reduced. this is done by shifting the mask in d7 and re-running the code from the
00001022                            69  * start. for this reason the /.] part of the branch timing, and that for this section,
00001022                            70  * never needs to be taken into account
00001022                            71  
00001022  E207                      72      ASR.b       #1,d7           * effectively divide the measure time (q) by 2
00001024  6500 00AE                 73      BCS     LAB_speederror  * branch if simulator is too fast to time
00001028                            74                          * this will happen at approximately 380MHz simulated
00001028                            75  
00001028  60DC                      76      BRA.s       LAB_time        * go re-run the code
0000102A                            77  
0000102A                            78  LAB_1_ccc
0000102A  7008                      79      MOVEQ       #8,d0           * [4] get 100ths of a second since midnight
0000102C  4E4F                      80      TRAP        #15         * [x]
0000102E  C287                      81      AND.l       d7,d1           * [8] mask q 100ths
00001030  B481                      82      CMP.l       d1,d2           * [6] compare with last q 100ths
00001032  67EA                      83      BEQ.s       LAB_1_count     * [10/8] loop if not yet changed
00001034                            84  
00001034                            85  * speed of the 68000 is 100*n*(46+x)/128 cycles/s where x is the time the TRAP #15
00001034                            86  * call takes. from this it's not easy to get the effective speed because we don't
00001034                            87  * know x so we go measure a slightly different loop ......
00001034                            88  
00001034                            89  LAB_2_wait
00001034  7008                      90      MOVEQ       #8,d0           * get 100ths of a second since midnight
00001036  4E4F                      91      TRAP        #15
00001038  C287                      92      AND.l       d7,d1           * mask q 100ths
0000103A  B481                      93      CMP.l       d1,d2           * compare with last q 100ths
0000103C  67F6                      94      BEQ.s       LAB_2_wait      * wait more if not yet changed
0000103E                            95  
0000103E  2401                      96      MOVE.l  d1,d2           * copy q 100ths
00001040                            97  LAB_2_count
00001040  5484                      98      ADDQ.l  #2,d4           * [8] increment counter twice
00001042  6408                      99      BCC.s       LAB_2_ccc       * [10/.] branch if no overflow
00001044                           100  
00001044                           101  * if there is an overflow here then the period over which the count is done needs to
00001044                           102  * be reduced. this is done by shifting the mask in d7 and re-running the code from the
00001044                           103  * start. for this reason the /.] part of the branch timing, and that for this section,
00001044                           104  * never needs to be taken into account. actually this code should /never/ be executed
00001044                           105  * but, as with all things that should never happen, if the first loop runs a little
00001044                           106  * slow, this one doesn't and the simulator is fast enough that an overflow /could/
00001044                           107  * happen then it's better to be safe than wrong. it also saves us padding this loop to
00001044                           108  * ensure that it's slower than the above loop to make the math easier later
00001044                           109  
00001044  E207                     110      ASR.b       #1,d7           * effectively divide the measure time (q) by 2
00001046  6500 008C                111      BCS     LAB_speederror  * branch if simulator is too fast to time
0000104A                           112                          * this will happen at approximately 380MHz simulated
0000104A                           113  
0000104A  60BA                     114      BRA.s       LAB_time        * go re-run the code
0000104C                           115  
0000104C                           116  LAB_2_ccc
0000104C  5384                     117      SUBQ.l  #1,d4           * [8] decrement counter
0000104E  7008                     118      MOVEQ       #8,d0           * [4] get 100ths of a second since midnight
00001050  4E4F                     119      TRAP        #15         * [x]
00001052  C287                     120      AND.l       d7,d1           * [8] mask q 100ths
00001054  B481                     121      CMP.l       d1,d2           * [6] compare with last q 100ths
00001056  67E8                     122      BEQ.s       LAB_2_count     * [10/8] loop if not yet changed
00001058                           123  
00001058                           124  * ... now we have another measure of speed of the 68000 which is 100*m*(54+x)/q
00001058                           125  * cycles/s. as both loops take the same ammount of time we can find x from these
00001058                           126  * two loops by doing the following ..
00001058                           127  *
00001058                           128  *      100*m*(54+x)/q = 100*n*(46+x)/q
00001058                           129  *                           .. let x = x+46 to simplify loop counts ..
00001058                           130  *       100*m*(8+x)/q = 100*n*x/q
00001058                           131  *                           .. remove common factors ..
00001058                           132  *             m*(8+x) = n*x
00001058                           133  *                           .. multiply out ..
00001058                           134  *             8m + mx = nx
00001058                           135  *                           .. swap x to left hand side ..
00001058                           136  *             nx - mx = 8m
00001058                           137  *                           .. factorise ..
00001058                           138  *           x*(n - m) = 8m
00001058                           139  *                           .. rearrange to give x gives ..
00001058                           140  *                   x = 8m/(n - m)
00001058                           141  *
00001058                           142  * as a test, run the code and try some returned values, m is 38008 n is 43083
00001058                           143  * and q is 16
00001058                           144  *
00001058                           145  *   x = 8m/(n - m)
00001058                           146  *
00001058                           147  *   x = 8*38008/(43083 - 38008) =  304064/(5075) = 59.91
00001058                           148  *
00001058                           149  * having found x it can be substituted in either of the simplified loop equations
00001058                           150  * to give the effective processor speed in Hz. for this use 100*n*x/q which is the
00001058                           151  * simpler of the two
00001058                           152  *
00001058                           153  * speed = 100*n*x/q
00001058                           154  *
00001058                           155  * speed = 100*43083*59.91/16 = 16131890.8125 Hz = 16.132MHz
00001058                           156  *
00001058                           157  * .. or 16.132MHz, which isn't too bad. this is on a 1.8GHz processor so it works
00001058                           158  * out at around 112 real clocks for each 68000 clock.
00001058                           159  *
00001058                           160  * let the 68000 do this calculation but, as the accuracy is probably not great,
00001058                           161  * these equations can be arranged to reduce the risk of overflows should this
00001058                           162  * code ever run on a simulator that fast
00001058                           163  *
00001058                           164  * m is in d4.w and n is in d3.w, the high words are cleared ..
00001058                           165  
00001058                           166                          * x = 8m/(n - m)
00001058  2A03                     167      MOVE.l  d3,d5           * copy n
0000105A  9A44                     168      SUB.w       d4,d5           * (n - m) now in d5.w
0000105C  41FA 00CF                169      LEA     (LAB_LMHz,PC),a0    * get pointer to "Count error!",[CR][LF]
00001060  6772                     170      BEQ.s       LAB_speederror  * branch if the simulator is too slow to time
00001062                           171  
00001062                           172  * at this point x can be calculated and then used in the speed equation but, as x is a
00001062                           173  * small value, some resolution will be lost in the integer nature of the result. to
00001062                           174  * preserve the resolution 8*m/(n - m) is substitutes for x in the 100*n*x/q equation,
00001062                           175  * which expands to 100*n*8*m/(n - m)/q, and the calculation order is changed
00001062                           176  
00001062                           177  * m is in d4.w and n is in d3.w, the high words are cleared ..
00001062                           178  * (n - m) is in d5.w, -q is in d7
00001062                           179  
00001062  7000                     180      MOVEQ       #0,d0           * clear divide result high word register
00001064                           181  
00001064  C6C4                     182      MULU.w  d4,d3           * n*m in d3.l
00001066  2803                     183      MOVE.l  d3,d4           * copy n*m
00001068  3800                     184      MOVE.w  d0,d4           * clear n*m low word
0000106A  4844                     185      SWAP        d4          * swap high word to low word
0000106C                           186  
0000106C  88C5                     187      DIVU.w  d5,d4           * high word divide result in d4.w
0000106E                           188  
0000106E  3004                     189      MOVE.w  d4,d0           * copy divide result
00001070  4840                     190      SWAP        d0          * swap to high word (and clear low word)
00001072                           191  
00001072  C8C5                     192      MULU.w  d5,d4           * multiply back
00001074  9684                     193      SUB.l       d4,d3           * subtract from n*m
00001076                           194  
00001076  86C5                     195      DIVU.w  d5,d3           * low word n*m/(n - m) now in d3
00001078                           196  
00001078  7400                     197      MOVEQ       #0,d2           * set value for rounding
0000107A  4843                     198      SWAP        d3          * remainder from n*m/(n - m) into d3 low word
0000107C  E343                     199      ASL.w       #1,d3           * shift the high bit of the remainder into Xb
0000107E  4243                     200      CLR.w       d3          * clear the rest of the remainder
00001080  4843                     201      SWAP        d3          * swap the result back to the low word (Xb unchanged)
00001082  D742                     202      ADDX.w  d2,d3           * add the rounding bit into the result
00001084                           203  
00001084  D680                     204      ADD.l       d0,d3           * add in the high word result
00001086                           205  
00001086  E78B                     206      LSL.l       #3,d3           * now do the *8 part, d3 = 8*n*m/(n - m)
00001088                           207  
00001088                           208  * as q is always a power of 2, it starts at 128 and gets smaller, it's easy to divide
00001088                           209  * by it by shifting the resut right by the correct number of bits. to do this the mask
00001088                           210  * is shifted by 1 and tested each loop, if a divide is needed the result is shifted
00001088                           211  * and the loop taken again
00001088                           212  
00001088                           213  LAB_divq
00001088  E20F                     214      LSR.b       #1,d7           * shift q
0000108A  6504                     215      BCS.s       LAB_doneq       * exit loop if the /q is done
0000108C                           216  
0000108C  E28B                     217      LSR.l       #1,d3           * shift the (unsigned) result
0000108E  60F8                     218      BRA.s       LAB_divq        * go test again
00001090                           219  
00001090                           220  * now d3 holds 8*n*m/(n - m)/q which is 100th the effective CPU Hz or, looked at
00001090                           221  * in MHz, 10,000th the result. this can be output as a fixed point decimal number
00001090                           222  * without needing to be further scalled
00001090                           223  
00001090                           224  LAB_doneq
00001090  43FA 0060                225      LEA     (B2dec,PC),a1   * get table address
00001094  7200                     226      MOVEQ       #0,d1           * set table index
00001096  7E30                     227      MOVEQ       #'0',d7     * output check character
00001098                           228  LAB_chrloop
00001098  2C31 1000                229      MOVE.l  (a1,d1.w),d6    * get table value
0000109C  6732                     230      BEQ.s       LAB_alldone     * exit if end marker
0000109E                           231  
0000109E  782F                     232      MOVEQ       #'0'-1,d4       * set character to "0"-1
000010A0                           233  LAB_subloop
000010A0  5244                     234      ADDQ.w  #1,d4           * next numeric character
000010A2  9686                     235      SUB.l       d6,d3           * subtract table value
000010A4  6AFA                     236      BPL.s       LAB_subloop     * not overdone so loop
000010A6                           237  
000010A6  D686                     238      ADD.l       d6,d3           * correct value
000010A8  B27C 0018                239      CMP.w       #sB2dec-B2dec,d1    * test index
000010AC  6612                     240      BNE.s       LAB_notdp       * branch if not decimal point
000010AE                           241  
000010AE  3F04                     242      MOVE.w  d4,-(sp)        * save d4
000010B0  4A07                     243      TST.b       d7          * test if zero output
000010B2  6700 0006                244      BEQ     LAB_no0out      * branch if leading character done
000010B6                           245  
000010B6  2807                     246      MOVE.l  d7,d4           * "0" character
000010B8  6128                     247      BSR.s       VEC_OUT     * go print the character
000010BA                           248  LAB_no0out
000010BA  782E                     249      MOVEQ       #'.',d4     * "." character
000010BC  6124                     250      BSR.s       VEC_OUT     * go print the character
000010BE  381F                     251      MOVE.w  (sp)+,d4        * restore d4
000010C0                           252  
000010C0                           253  LAB_notdp
000010C0  6A04                     254      BPL.s       LAB_nolead0s    * branch if no leading 0 supress
000010C2                           255  
000010C2  BE04                     256      CMP.b       d4,d7           * compare with check character
000010C4  6706                     257      BEQ.s       LAB_lead0s      * branch if leading '0' supressed
000010C6                           258  
000010C6                           259  LAB_nolead0s
000010C6  7E00                     260      MOVEQ       #0,d7           * eliminate check character
000010C8  6100 0018                261      BSR     VEC_OUT     * character out to display
000010CC                           262  LAB_lead0s
000010CC  5841                     263      ADDQ.w  #4,d1           * increment table pointer
000010CE  60C8                     264      BRA.s       LAB_chrloop     * loop
000010D0                           265  
000010D0                           266  LAB_alldone
000010D0  41FA 0048                267      LEA     (LAB_MHz,PC),a0 * get pointer to " MHz",[CR][LF]
000010D4                           268  LAB_speederror
000010D4  6106                     269      BSR.s       LAB_string      * output null terminated string
000010D6  6000 FF28                270      BRA     start           * loop forever
000010DA                           271  
000010DA                           272  
000010DA                           273  * output null terminated string
000010DA                           274  
000010DA                           275  LAB_sstring
000010DA  6106                     276      BSR.s       VEC_OUT     * else go print the character
000010DC                           277  LAB_string
000010DC  1818                     278      MOVE.b  (a0)+,d4        * get byte from string
000010DE  66FA                     279      BNE.s       LAB_sstring     * output character if not end
000010E0                           280  
000010E0  4E75                     281      RTS
000010E2                           282  
000010E2                           283  
000010E2                           284  * output character to the console from register d4
000010E2                           285  
000010E2                           286  VEC_OUT
000010E2  48E7 C000                287      MOVEM.l d0-d1,-(sp)     * save d0, d1
000010E6  1204                     288      MOVE.b  d4,d1           * copy character
000010E8  7006                     289      MOVEQ       #6,d0           * character out
000010EA  4E4F                     290      TRAP        #15         * do I/O function
000010EC  4CDF 0003                291      MOVEM.l (sp)+,d0-d1     * restore d0, d1
000010F0  4E75                     292      RTS
000010F2                           293  
000010F2                           294  
000010F2                           295  * binary to unsigned decimal table
000010F2                           296  
000010F2                           297  B2dec
000010F2= 3B9ACA00                 298      dc.l    $3B9ACA00           * 10000.00000
000010F6= 05F5E100                 299      dc.l    $05F5E100           * 1000.00000
000010FA= 00989680                 300      dc.l    $00989680           * 100.00000
000010FE= 000F4240                 301      dc.l    $000F4240           * 10.00000
00001102= 000186A0                 302      dc.l    $000186A0           * 1.00000
00001106= 00002710                 303      dc.l    $00002710           * 0.10000
0000110A                           304  sB2dec
0000110A= 000003E8                 305      dc.l    $000003E8           * 00.10000
0000110E= 00000064                 306      dc.l    $00000064           * 000.10000
00001112= 0000000A                 307      dc.l    $0000000A           * 0000.10000
00001116= 00000000                 308      dc.l    $00000000           * 0 end marker
0000111A                           309  
0000111A                           310  
0000111A                           311  * messages
0000111A                           312  
0000111A                           313  LAB_MHz
0000111A= 20 4D 48 7A 0D 0A 00     314      dc.b    ' MHz',$0D,$0A,$00
00001121                           315  LAB_MMHz
00001121= 54 6F 6F 20 66 61 ...    316      dc.b    'Too fast!',$0D,$0A,$00
0000112D                           317  LAB_LMHz
0000112D= 43 6F 75 6E 74 20 ...    318      dc.b    'Count error!',$0D,$0A,$00
0000113C                           319  
0000113C                           320      END start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B2DEC               10F2
LAB_1_CCC           102A
LAB_1_COUNT         101E
LAB_1_WAIT          1012
LAB_2_CCC           104C
LAB_2_COUNT         1040
LAB_2_WAIT          1034
LAB_ALLDONE         10D0
LAB_CHRLOOP         1098
LAB_DIVQ            1088
LAB_DONEQ           1090
LAB_LEAD0S          10CC
LAB_LMHZ            112D
LAB_MHZ             111A
LAB_MMHZ            1121
LAB_NO0OUT          10BA
LAB_NOLEAD0S        10C6
LAB_NOTDP           10C0
LAB_SPEEDERROR      10D4
LAB_SSTRING         10DA
LAB_STRING          10DC
LAB_SUBLOOP         10A0
LAB_TIME            1006
SB2DEC              110A
START               1000
VEC_OUT             10E2
