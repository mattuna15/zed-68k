00015000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 04/10/2020 12:20:51

00000000                             1  * 12/24/17 trace command in DDT does not mask off interrupts.  mask off 68681 interrupt
00000000                             2  *   in the 68681 device itself.
00000000                             3  * 10/30/17 rev5, fix the console input so data is not filtered at all.  This resolves the
00000000                             4  *  problem with gkermit binary load.
00000000                             5  * 10/28/17 rev 4, DMA address can be odd or even, so word or long word move to/from dma
00000000                             6  *  may cause address error.  Replace the longword move with 4 byte moves.
00000000                             7  * 7/12/17 Rev 3, Add RAM drive to DRAM, 8 megbyte, from $700000 to $F00000
00000000                             8  *  reduce the size of TPA so it is now from $20000 to $700000
00000000                             9  * 7/6/17 Use blocking/deblocking algorithm provided by Roger Hanscom
00000000                            10  *  The blocking/deblocking algorithm is also described in section 5.3.1 of
00000000                            11  *  CP/M-68K System Guide
00000000                            12  * 6/28/2017
00000000                            13  * start with ERGBIOS.s in distribution disk #7 of CPM68kv1_3
00000000                            14  * use CPM15000.SR, CPM S record starts at location 0x15000
00000000                            15  *****************************************************************
00000000  =00F00009                 16  ACIAC    EQU $F00009
00000000  =00F0000B                 17  ACIAD    EQU ACIAC+2
00000000                            18  
00000000  =00F20009                 19  ACIA2C    EQU $F20009
00000000  =00F2000B                 20  ACIA2D    EQU ACIA2C+2
00000000                            21  
00000000  =00002000                 22  INT_ON   EQU  $2000    ; BOTH, SET SUPERVISOR MODE, S=1
00000000  =00002700                 23  INT_OFF  EQU  $2700
00000000                            24  
00000000  =00000000                 25  RDRF    EQU 0           ; ACIAC Receive Data Register Full
00000000  =00000001                 26  TDRE    EQU 1           ; ACIAC Transmit Data Register Empty
00000000                            27  
00000000                            28  
00000000  =00FFF000                 29  DUART    equ $FFF000       * base address of 68692 DUART
00000000  =00FFF001                 30  MRA      equ $FFF001       * mode reg A
00000000  =00FFF003                 31  SRA      equ $FFF003       * status A (read)
00000000  =00FFF003                 32  CSRA     equ $FFF003       * clock select reg (write)
00000000  =00FFF005                 33  CRA      equ $FFF005       * command register (write only)
00000000  =00FFF007                 34  RHRA     equ $FFF007       * Rx Hold reg A (read)
00000000  =00FFF007                 35  THRA     equ $FFF007       * Tx Holding reg (write)
00000000  =00FFF009                 36  IPCR     equ $FFF009       * Input port change reg (read)
00000000  =00FFF009                 37  ACR      equ $FFF009       * Aux control reg (write)
00000000  =00FFF00B                 38  ISRD     equ $FFF00B       * interrupt status reg (read)
00000000  =00FFF00B                 39  IMRD     equ $FFF00B       * interrupt mask reg (write)                          
00000000  =00FFF00D                 40  CTU      equ $FFF00D       * Counter/timer upper (read)
00000000  =00FFF00F                 41  CTL      equ $FFF00F       * counter/timer lower (read)
00000000  =00FFF00D                 42  CTUR     equ $FFF00D       * Counter/timer preload upper (write)
00000000  =00FFF00F                 43  CTLR     equ $FFF00F       * counter/timer preload lower (write)
00000000  =00FFF011                 44  MR1B     equ $FFF011       * mode reg B
00000000  =00FFF013                 45  SRB      equ $FFF013       * status reg B
00000000  =00FFF017                 46  RHRB     equ $FFF017       * Rx holding reg B
00000000  =00FFF019                 47  IVRD     equ $FFF019       * interrupt vector reg
00000000  =00FFF01F                 48  STOPCTR  equ $FFF01F       * stop counter command reg (read)
00000000  =00FFF01D                 49  STARTCTR equ $FFF01D       * start counter command reg (read)
00000000  =00FFF01D                 50  SETOPR   equ $FFF01D       * bit set output register bits (write)
00000000  =00FFF01F                 51  CLROPR   equ $FFF01F       * bit clear output register (write)
00000000  =00FFF01B                 52  OPCR     equ $FFF01B       * output configuration register(write)
00000000                            53  
00000000  =000150BC                 54  _ccp     equ $150BC                  * hard location for _ccp of CPM15000.SR
0001B000                            55           org $1B000                 * this is the hard location for _init for CPM15000.SR
0001B000                            56  _init:   
0001B000  6004                      57           bra.s init1
0001B002= 30 2E 36 00               58           dc.b '0.6',0               * rev 0.6 of TinyBIOS
0001B006                            59  init1:         
0001B006  13FC 0003 00F00009        60             MOVE.B #3,ACIAC.L   ; RESET ACIA
0001B00E  303C 0064                 61             MOVE.W #100,D0
0001B012  51C8 FFFE                 62             DBRA  D0,*
0001B016  13FC 0015 00F00009        63             MOVE.B #$15,ACIAC.L   ; rts enabled 9600 8ne
0001B01E                            64  
0001B01E  4280                      65           clr.l    d0                * log on disk A, user 0
0001B020                            66           ;move.b   #$40,CF2427       * set Logical Address addressing mode
0001B020  4E75                      67           rts
0001B022                            68  
0001B022                            69  traphndl:
0001B022  0C40 0017                 70           cmpi     #nfuncs,d0
0001B026  6400 000A                 71           bcc      trapng
0001B02A  E548                      72           lsl      #2,d0             * multiply bios function by 4
0001B02C                            73  **X won't assemble         movea.l 6(pc,d0),a0        * get handler address
0001B02C                            74  **X replace with this:
0001B02C  207B 0006                 75           movea.l  *+8(pc,d0),a0     * get handler address
0001B030  4E90                      76           jsr      (a0)              * call handler
0001B032                            77  trapng:
0001B032  4E73                      78           rte
0001B034                            79  
0001B034                            80  biosbase:
0001B034= 0001B000                  81           dc.l  _init
0001B038= 0001B090                  82           dc.l  wboot
0001B03C= 0001B0A0                  83           dc.l  constat
0001B040= 0001B0B4                  84           dc.l  conin
0001B044= 0001B0C2                  85           dc.l  conout
0001B048= 0001B0E2                  86           dc.l  lstout
0001B04C= 0001B0E4                  87           dc.l  pun
0001B050= 0001B0E6                  88           dc.l  rdr
0001B054= 0001B0EE                  89           dc.l  home
0001B058= 0001B0F6                  90           dc.l  seldsk
0001B05C= 0001B118                  91           dc.l  settrk
0001B060= 0001B120                  92           dc.l  setsec
0001B064= 0001B12C                  93           dc.l  setdma
0001B068= 0001B134                  94           dc.l  read
0001B06C= 0001B206                  95           dc.l  write
0001B070= 0001B0E8                  96           dc.l  listst
0001B074= 0001B128                  97           dc.l  sectran
0001B078= 0001B12C                  98           dc.l  setdma
0001B07C= 0001B2EC                  99           dc.l  getseg
0001B080= 0001B2F4                 100           dc.l  getiob
0001B084= 0001B2F6                 101           dc.l  setiob
0001B088= 0001B2E8                 102           dc.l  flush
0001B08C= 0001B2F8                 103           dc.l  setexc
0001B090                           104  
0001B090  =00000017                105  nfuncs   equ (*-biosbase)/4
0001B090                           106  
0001B090  47F9 0001BB80            107  wboot:   LEA.L TITLE.L, A3
0001B096  6100 003C                108           BSR PSTR
0001B09A  4EF9 000150BC            109           jmp      _ccp
0001B0A0                           110  
0001B0A0                           111  constat: 
0001B0A0                           112  * Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
0001B0A0                           113  
0001B0A0  0839 0000 00F00009       114           BTST.B #RDRF,ACIAC.L
0001B0A8  6700 0006                115           beq noton         * branch if no input
0001B0AC  7001                     116           moveq.l  #$1,d0            * set result to true
0001B0AE  4E75                     117           rts
0001B0B0  4280                     118  noton:   clr.l    d0                * set result to false
0001B0B2  4E75                     119           rts
0001B0B4                           120  
0001B0B4                           121  conin:   
0001B0B4                           122  * Read single ASCII character from the keyboard into d0
0001B0B4  61EA                     123           bsr      constat           * see if key pressed
0001B0B6  4A40                     124           tst      d0
0001B0B8  67FA                     125           BEQ.S    conin
0001B0BA  1039 00F0000B            126           MOVE.B ACIAD.L,D0
0001B0C0  4E75                     127           RTS
0001B0C2                           128  
0001B0C2                           129  conout: 
0001B0C2  0839 0001 00F00009       130            BTST.B #TDRE,ACIAC.L
0001B0CA  67F6                     131            BEQ.S  conout
0001B0CC  13C1 00F0000B            132            MOVE.B D1,ACIAD.L
0001B0D2  4E75                     133            RTS
0001B0D4                           134            
0001B0D4  121B                     135  PSTR     MOVE.B (A3)+,D1
0001B0D6  B23C 0000                136           CMP.B  #0,D1
0001B0DA  6704                     137           BEQ.S PSTR1
0001B0DC  61E4                     138           BSR conout
0001B0DE  60F4                     139           BRA.S PSTR
0001B0E0                           140  
0001B0E0  4E75                     141  PSTR1    RTS
0001B0E2                           142  
0001B0E2  4E75                     143  lstout:  rts
0001B0E4                           144  
0001B0E4  4E75                     145  pun:     rts
0001B0E6                           146  
0001B0E6  4E75                     147  rdr:     rts
0001B0E8                           148  
0001B0E8  103C 00FF                149  listst:  move.b   #$ff,d0
0001B0EC  4E75                     150           rts
0001B0EE                           151  
0001B0EE                           152  * Compact flash registers
0001B0EE  =00000005                153  maxdsk   equ 5             * five drives
0001B0EE  =0000001A                154  dphlen   equ 26            * length of disk parameter header
0001B0EE                           155  
0001B0EE  =00FFE000                156  CFdata   equ $FFE000       * CF data register
0001B0EE  =00FFE002                157  CFerr    equ $FFE002       * CF error reg
0001B0EE  =00FFE005                158  CFsectcnt equ $FFE005      * CF sector count reg
0001B0EE  =00FFE007                159  CF07     equ $FFE007       * CF LA0-7
0001B0EE  =00FFE009                160  CF815    equ $FFE009       * CF LA8-15
0001B0EE  =00FFE00B                161  CF1623   equ $FFE00B       * CF LA16-23
0001B0EE  =00FFE00D                162  CF2427   equ $FFE00D       * CF LA24-27
0001B0EE  =00FFE00F                163  CFstat   equ $FFE00F       * CF status/command reg
0001B0EE                           164  
0001B0EE  4279 0001B316            165  home:    clr.w    track
0001B0F4  4E75                     166           rts
0001B0F6                           167  
0001B0F6                           168  seldsk:  
0001B0F6                           169  *        select disk given by register d1.b
0001B0F6  7000                     170           moveq    #0,d0
0001B0F8  B23C 0005                171           cmp.b    #maxdsk,d1        * valid drive number?
0001B0FC  6A00 0018                172           bpl      selrtn            * if no, return 0 in d0
0001B100  13C1 0001B310            173           move.b   d1,seldrv         * else, save drive number
0001B106  1039 0001B310            174           move.b   seldrv,d0
0001B10C  C0FC 001A                175           mulu     #dphlen,d0
0001B110  0680 0001B32E            176           add.l    #dph0,d0          * point d0 at correct dph
0001B116  4E75                     177  selrtn:  rts
0001B118                           178  
0001B118  33C1 0001B316            179  settrk:  move.w   d1,track
0001B11E  4E75                     180           rts
0001B120                           181  
0001B120                           182  setsec:  
0001B120  33C1 0001B318            183           move.w   d1,sector
0001B126  4E75                     184           rts
0001B128                           185  
0001B128                           186  sectran:
0001B128                           187  *        no sector translate, put d1 into d0 and return
0001B128  3001                     188           move.w d1,d0
0001B12A  4E75                     189           rts
0001B12C                           190  
0001B12C                           191  setdma:
0001B12C  23C1 0001B31A            192           move.l   d1,dma
0001B132  4E75                     193           rts
0001B134                           194  
0001B134                           195  read:
0001B134                           196  * Read one sector from requested disk, track, sector to dma address
0001B134                           197  * Retry if necessary, return in d0 00 if ok, else non-zero
0001B134  0C39 0004 0001B310       198           cmp.b #4,seldrv            * RAM drive?
0001B13C  6700 0096                199           beq RAMdrvRd               * if RAM drive, handle it differently
0001B140  4280                     200           clr.l d0                   * make sure d0 is all zero
0001B142  3039 0001B318            201           move.w sector,d0           * check if need to read a new sector from CF
0001B148  E458                     202           ror.w #2,d0                * 2 lsb are 128-byte index into CF data, save to high byte
0001B14A                           203  
0001B14A  2239 0001B316            204           move.l track,d1            * this will read in track (in high word) and sector 
0001B150                           205                                      * (in low word)
0001B150  C2BC FFFFFFFC            206           and.l #$fffffffc,d1        * mask off the 2 lsb
0001B156  B2B9 0001B312            207           cmp.l curCFsect,d1         * does it match track/sect of CF data in the buffer?                           
0001B15C                           208  
0001B15C  6700 0050                209           beq move2dma                * data already there, 
0001B160                           210  readCF:         
0001B160  23C1 0001B312            211           move.l d1,curCFsect        * update current CF sector
0001B166  13FC 0001 00FFE005       212           move.b #1,CFsectcnt        * read 1 sector
0001B16E  13F9 0001B316 00FFE00B   213           move.b track,CF1623        * MSB of track goes to LA16-23
0001B178  13F9 0001B317 00FFE009   214           move.b track+1,CF815       * LSB of 16-bit track value goes to LA8-15
0001B182  13C0 00FFE007            215           move.b d0,CF07             * CF sector goes to LA07
0001B188  41F9 0001B480            216           lea sectCF,a0             * read into CF sector data buffer
0001B18E  13FC 0020 00FFE00F       217           move.b #$20,CFstat         * read sector command
0001B196                           218  readdrq:
0001B196  0839 0003 00FFE00F       219           btst.b #3,CFstat           * check data request bit set before reading
0001B19E  67F6                     220           beq readdrq
0001B1A0  343C 00FF                221           move.w #$ff,d2             * read 512 bytes
0001B1A4                           222  readCF1:
0001B1A4  30F9 00FFE000            223           move.w CFdata,(a0)+        * 16-bit read
0001B1AA  51CA FFF8                224           dbra d2,readCF1
0001B1AE                           225  move2dma:
0001B1AE  4200                     226           clr.b d0                   * clear the low byte 
0001B1B0  EE48                     227           lsr.w #7,d0                * forming 128 byte offset using values in high byte of d0
0001B1B2  0680 0001B480            228           add.l #sectCF,d0          * index into CF data buffer
0001B1B8  2040                     229           move.l d0,a0               * a0 points to the CP/M sector 
0001B1BA  2279 0001B31A            230           move.l dma,a1              * a1 points to buffer pointed by dma
0001B1C0  343C 001F                231           move.w #31,d2              * transfer 128 bytes
0001B1C4                           232  cpdma:
0001B1C4                           233  *         move.l (a0)+,(a1)+         * copy long word at a time
0001B1C4  12D8                     234           move.b (a0)+,(a1)+         * move long word, byte at a time
0001B1C6  12D8                     235           move.b (a0)+,(a1)+         * DMA pointer may be odd or even address
0001B1C8  12D8                     236           move.b (a0)+,(a1)+         *  so move word or move longword may cause address error
0001B1CA                           237  
0001B1CA  12D8                     238           move.b (a0)+,(a1)+
0001B1CC  51CA FFF6                239           dbra d2,cpdma 
0001B1D0  6000 0012                240           bra readexit
0001B1D4                           241  RAMdrvRd:
0001B1D4  6100 0012                242           bsr setupRD                * translate track/sector values into RAM loc
0001B1D8                           243  RAMdrvR:
0001B1D8                           244  *         move.l (a0)+,(a1)+
0001B1D8  12D8                     245           move.b (a0)+,(a1)+         * move long word, byte at a time
0001B1DA  12D8                     246           move.b (a0)+,(a1)+         * DMA pointer may be odd or even address
0001B1DC  12D8                     247           move.b (a0)+,(a1)+         *  so move word or move longword may cause address error
0001B1DE                           248  
0001B1DE  12D8                     249           move.b (a0)+,(a1)+
0001B1E0  51CA FFF6                250           dbra d2,RAMdrvR
0001B1E4                           251  readexit:
0001B1E4  4280                     252           clr.l d0                   * return OK status         
0001B1E6  4E75                     253           rts         
0001B1E8                           254  setupRD:
0001B1E8                           255  * translate track/sector into RAM location on the RAM drive
0001B1E8  2039 0001B316            256           move.l track,d0            * get track & sector values
0001B1EE  ED48                     257           lsl.w #6,d0                * multiply by 64
0001B1F0  E388                     258           lsl.l #1,d0                * multiply the track/sector by 128 to index into RAM
0001B1F2  0680 00700000            259           add.l #$700000,d0          * add base address of RAM drive
0001B1F8  2040                     260           move.l d0,a0               * point to the track/sector in RAM drive
0001B1FA  2279 0001B31A            261           move.l dma,a1             * get dma
0001B200  343C 001F                262           move.w #(128/4)-1,d2        * long word move 128 bytes of sector data
0001B204  4E75                     263           rts
0001B206                           264  write:
0001B206                           265  * Write one sector to requested disk, track, sector from dma address
0001B206                           266  * Retry if necessary, return in d0 00 if ok, else non-zero
0001B206                           267  *         cmp.w #2,d1                * if new block, skip pre-read
0001B206                           268  *         beq writeCF         
0001B206  0C39 0004 0001B310       269           cmp.b #4,seldrv            * RAM drive?
0001B20E  6700 00C4                270           beq RAMdrvWr               * if RAM drive, handle it differently
0001B212  4280                     271           clr.l d0                   * make sure d0 is all zero
0001B214  3039 0001B318            272           move.w sector,d0           * pre-read the CF sector before write
0001B21A  E458                     273           ror.w #2,d0                * 2 lsb are 128-byte index into CF data, save to high byte
0001B21C  2239 0001B316            274           move.l track,d1            * this will read in track (in high word) and sector 
0001B222                           275                                      * (in low word)
0001B222  C2BC FFFFFFFC            276           and.l #$fffffffc,d1        * mask off the 2 lsb
0001B228  23C1 0001B312            277           move.l d1,curCFsect        * update current CF sector 
0001B22E  13FC 0001 00FFE005       278           move.b #1,CFsectcnt        * read 1 sector
0001B236  13F9 0001B316 00FFE00B   279           move.b track,CF1623        * MSB of track goes to LA16-23
0001B240  13F9 0001B317 00FFE009   280           move.b track+1,CF815       * LSB of 16-bit track value goes to LA8-15
0001B24A  13C0 00FFE007            281           move.b d0,CF07             * CF sector goes to LA07
0001B250                           282  
0001B250  41F9 0001B480            283           lea sectCF,a0             * read into CF sector data buffer
0001B256  13FC 0020 00FFE00F       284           move.b #$20,CFstat         * read sector command
0001B25E                           285  readdrqw:
0001B25E  0839 0003 00FFE00F       286           btst.b #3,CFstat           * check data request bit set before reading
0001B266  67F6                     287           beq readdrqw
0001B268  343C 00FF                288           move.w #$ff,d2             * read 512 bytes
0001B26C                           289  preadCF:
0001B26C  30F9 00FFE000            290           move.w CFdata,(a0)+        * 16-bit read
0001B272  51CA FFF8                291           dbra d2,preadCF
0001B276                           292  
0001B276                           293  writeCF:
0001B276                           294  * calculate the index into CF data block
0001B276  4200                     295           clr.b d0                   * clear the low byte 
0001B278  EE48                     296           lsr.w #7,d0                * forming 128 byte offset with values in high byte of d0
0001B27A  0680 0001B480            297           add.l #sectCF,d0          * index into CF data buffer
0001B280  2040                     298           move.l d0,a0               * a0 points to the CP/M sector 
0001B282  2279 0001B31A            299           move.l dma,a1              * a1 points to buffer pointed by dma
0001B288  343C 001F                300           move.w #31,d2              * transfer 128 bytes
0001B28C                           301  wrcpdma:
0001B28C                           302  *         move.l (a1)+,(a0)+         * copy data to be written, long word at a time
0001B28C  10D9                     303           move.b (a1)+,(a0)+         * move long word, byte at a time
0001B28E  10D9                     304           move.b (a1)+,(a0)+         * DMA pointer may be odd or even address
0001B290  10D9                     305           move.b (a1)+,(a0)+         *  so move word or move longword may cause address error
0001B292  10D9                     306           move.b (a1)+,(a0)+
0001B294  51CA FFF6                307           dbra d2,wrcpdma 
0001B298                           308                         
0001B298  41F9 0001B480            309           lea sectCF,a0             * points to the 512 byte CF buffer to be written
0001B29E  13FC 0001 00FFE005       310           move.b #1,CFsectcnt        * read 1 sector
0001B2A6                           311  * no need to write CF07, CF815, CF1623.  They are already done with pre-read
0001B2A6  13FC 0030 00FFE00F       312           move.b #$30,CFstat
0001B2AE                           313  writedrq
0001B2AE  0839 0003 00FFE00F       314           btst.b #3,CFstat          * check data request bit set before writing sector
0001B2B6  67F6                     315           beq writedrq        
0001B2B8  343C 00FF                316           move.w #$ff,d2            * write 512 bytes
0001B2BC                           317  WriteCF1:
0001B2BC  33D8 00FFE000            318           move.w (a0)+,CFdata        * write data
0001B2C2  51CA FFF8                319           dbra d2,WriteCF1           * write 512 bytes of data
0001B2C6                           320  WriteCF2:
0001B2C6  0839 0007 00FFE00F       321           btst.b #7,CFstat           * check busy bit for write completed
0001B2CE  66F6                     322           bne WriteCF2         
0001B2D0  6000 0012                323           bra wrexit
0001B2D4                           324  RAMdrvWr:
0001B2D4  6100 FF12                325           bsr setupRD                * translate track/sector values into RAM loc
0001B2D8                           326  RAMdrvW:
0001B2D8                           327  *         move.l (a1)+,(a0)+
0001B2D8  10D9                     328           move.b (a1)+,(a0)+         * move long word, byte at a time
0001B2DA  10D9                     329           move.b (a1)+,(a0)+         * DMA pointer may be odd or even address
0001B2DC  10D9                     330           move.b (a1)+,(a0)+         *  so move word or move longword may cause address error
0001B2DE                           331  
0001B2DE  10D9                     332           move.b (a1)+,(a0)+
0001B2E0  51CA FFF6                333           dbra d2,RAMdrvW
0001B2E4                           334  wrexit:
0001B2E4  4280                     335           clr.l d0
0001B2E6  4E75                     336           rts         
0001B2E8                           337  
0001B2E8                           338  flush:
0001B2E8  4280                     339           clr.l    d0                * return successful
0001B2EA  4E75                     340           rts
0001B2EC                           341  
0001B2EC                           342  getseg:
0001B2EC  203C 0001B324            343           move.l   #memrgn,d0        * return address of mem region table
0001B2F2  4E75                     344           rts
0001B2F4                           345  
0001B2F4                           346  getiob:
0001B2F4  4E75                     347           rts
0001B2F6                           348  
0001B2F6                           349  setiob:
0001B2F6  4E75                     350           rts
0001B2F8                           351  
0001B2F8                           352  setexc:
0001B2F8  0281 000000FF            353           andi.l   #$ff,d1           * do only for exceptions 0 - 255
0001B2FE  0C41 002F                354           cmpi     #47,d1
0001B302  6700 000A                355           beq      noset             * this BIOS doesn't set Trap 15
0001B306                           356  *        cmpi     #9,d1             * or Trace
0001B306                           357  *        beq      noset
0001B306  E549                     358           lsl      #2,d1             * multiply exception nmbr by 4
0001B308  2041                     359           movea.l  d1,a0
0001B30A  2010                     360           move.l   (a0),d0           * return old vector value
0001B30C  2082                     361           move.l   d2,(a0)           * insert new vector
0001B30E  4E75                     362  noset:   rts
0001B310                           363  
0001B310                           364  
0001B310                           365  **X      .data
0001B310                           366  
0001B310= FF                       367  seldrv:  dc.b     $ff      * drive requested by seldsk
0001B311= 00                       368  resv:    dc.b    0         * reserve byte, padding
0001B312= FFFFFFFF                 369  curCFsect: dc.l   -1 * current CF sector, the 512 bytes data of curtrk is in sectCF
0001B316= 0000                     370  track:   dc.w     0        * track requested by settrk
0001B318= 0000                     371  sector:  dc.w     0        * max sector value is 0x3FF
0001B31A= 00000000                 372  dma:     dc.l     0
0001B31E= 00                       373  selcode: dc.b     0        * reserve byte
0001B31F= 00                       374  resv1:   dc.b     0        * reserve byte, padding
0001B320= 00C00000                 375  pLog     dc.l     $c00000  * diagnostic buffer
0001B324                           376  
0001B324= 0001                     377  memrgn:  dc.w     1        * 1 memory region
0001B326= 00020000                 378           dc.l     $20000   * starts above CP/M
0001B32A= 006E0000                 379           dc.l     $6e0000  * goes until $7000000.  RAM drive above it
0001B32E                           380  *         dc.l     $dd0000   * goes until $df0000, TPA is ~14meg bytes
0001B32E                           381  
0001B32E                           382  * disk parameter headers
0001B32E                           383  
0001B32E                           384  dph0:    
0001B32E= 00000000                 385           dc.l     0        * no sector translation table
0001B332= 0000                     386           dc.w     0        * dummy
0001B334= 0000                     387           dc.w     0
0001B336= 0000                     388           dc.w     0
0001B338= 0001B400                 389           dc.l     dirbuf   * ptr to directory buffer
0001B33C= 0001B3B0                 390           dc.l     dpb0     * ptr to disk parameter block
0001B340= 00000000                 391           dc.l     0        * permanent drive, no check vector
0001B344= 0001B680                 392           dc.l     alv0     * ptr to allocation vector
0001B348                           393  
0001B348                           394  dph1:
0001B348= 00000000                 395           dc.l     0        * no sector translation table
0001B34C= 0000                     396           dc.w     0        * dummy
0001B34E= 0000                     397           dc.w     0
0001B350= 0000                     398           dc.w     0
0001B352= 0001B400                 399           dc.l     dirbuf   * ptr to directory buffer
0001B356= 0001B3C0                 400           dc.l     dpb1     * ptr to disk parameter block
0001B35A= 00000000                 401           dc.l     0        * permanent drive, no check vector
0001B35E= 0001B780                 402           dc.l     alv1     * ptr to allocation vector
0001B362                           403  
0001B362                           404  dph2:
0001B362= 00000000                 405           dc.l     0        * no sector translation table
0001B366= 0000                     406           dc.w     0        * dummy
0001B368= 0000                     407           dc.w     0
0001B36A= 0000                     408           dc.w     0
0001B36C= 0001B400                 409           dc.l     dirbuf   * ptr to directory buffer
0001B370= 0001B3D0                 410           dc.l     dpb2     * ptr to disk parameter block
0001B374= 00000000                 411           dc.l     0        * permanent drive, no check vector
0001B378= 0001B880                 412           dc.l     alv2     * ptr to allocation vector
0001B37C                           413  
0001B37C                           414  dph3:
0001B37C= 00000000                 415           dc.l     0        * no sector translation table
0001B380= 0000                     416           dc.w     0        * dummy
0001B382= 0000                     417           dc.w     0
0001B384= 0000                     418           dc.w     0
0001B386= 0001B400                 419           dc.l     dirbuf   * ptr to directory buffer
0001B38A= 0001B3E0                 420           dc.l     dpb3     * ptr to disk parameter block
0001B38E= 00000000                 421           dc.l     0        * permanent drive, no check vector
0001B392= 0001B980                 422           dc.l     alv3     * ptr to allocation vector
0001B396                           423           
0001B396                           424  dph4:
0001B396= 00000000                 425           dc.l     0        * no sector translation table
0001B39A= 0000                     426           dc.w     0        * dummy
0001B39C= 0000                     427           dc.w     0
0001B39E= 0000                     428           dc.w     0
0001B3A0= 0001B400                 429           dc.l     dirbuf   * ptr to directory buffer
0001B3A4= 0001B3F0                 430           dc.l     dpb4     * ptr to disk parameter block
0001B3A8= 00000000                 431           dc.l     0        * permanent drive, no check vector
0001B3AC= 0001BA80                 432           dc.l     alv4     * ptr to allocation vector
0001B3B0                           433  
0001B3B0                           434  * disk parameter block
0001B3B0                           435  * choose a BLS of 4096
0001B3B0                           436  * 1024 sectors (128 byte sector) per track
0001B3B0                           437  * 64 sectors per block
0001B3B0                           438  * 62 tracks per drive 
0001B3B0                           439  dpb0:    
0001B3B0= 0400                     440           dc.w     1024      * 1024 sectors per track
0001B3B2= 05                       441           dc.b     5        * block shift for BLS of 4096
0001B3B3= 1F                       442           dc.b     31       * block mask for BLS of 4096
0001B3B4= 01                       443           dc.b     1        * extent mask, EXM
0001B3B5= 00                       444           dc.b     0        * dummy fill
0001B3B6= 07BF                     445           dc.w     1983     * DSM, does not count the 1st track, and leave a head room of 1 track
0001B3B8                           446                             * 62 tracks * 1024 sectors * 128 bytes = 1984 blocks or ~8meg
0001B3B8= 01FF                     447           dc.w     511      * DRM, 512 directory entries
0001B3BA= 0000                     448           dc.w     0        * directory mask
0001B3BC= 0000                     449           dc.w     0        * permanent mounted drive, check size is zero
0001B3BE= 0001                     450           dc.w     1        * track offset of 1
0001B3C0                           451  
0001B3C0                           452  * disk parameter block
0001B3C0                           453  * choose a BLS of 4096
0001B3C0                           454  * 1024 sectors (128 byte sector) per track
0001B3C0                           455  * 64 sectors per block
0001B3C0                           456  * 63 tracks per drive 
0001B3C0                           457  dpb1:    
0001B3C0= 0400                     458           dc.w     1024      * 1024 sectors per track
0001B3C2= 05                       459           dc.b     5        * block shift for BLS of 4096
0001B3C3= 1F                       460           dc.b     31       * block mask for BLS of 4096
0001B3C4= 01                       461           dc.b     1        * extent mask, EXM
0001B3C5= 00                       462           dc.b     0        * dummy fill
0001B3C6= 07DF                     463           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3C8                           464                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3C8= 01FF                     465           dc.w     511      * DRM, 512 directory entries
0001B3CA= 0000                     466           dc.w     0        * directory mask
0001B3CC= 0000                     467           dc.w     0        * permanent mounted drive, check size is zero
0001B3CE= 0040                     468           dc.w     64       * track offset of 64
0001B3D0                           469  
0001B3D0                           470  * disk parameter block
0001B3D0                           471  * choose a BLS of 4096
0001B3D0                           472  * 1024 sectors (128 byte sector) per track
0001B3D0                           473  * 64 sectors per block
0001B3D0                           474  * 63 tracks per drive 
0001B3D0                           475  dpb2:    
0001B3D0= 0400                     476           dc.w     1024      * 1024 sectors per track
0001B3D2= 05                       477           dc.b     5        * block shift for BLS of 4096
0001B3D3= 1F                       478           dc.b     31       * block mask for BLS of 4096
0001B3D4= 01                       479           dc.b     1        * extent mask, EXM
0001B3D5= 00                       480           dc.b     0        * dummy fill
0001B3D6= 07DF                     481           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3D8                           482                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3D8= 01FF                     483           dc.w     511      * DRM, 512 directory entries
0001B3DA= 0000                     484           dc.w     0        * directory mask
0001B3DC= 0000                     485           dc.w     0        * permanent mounted drive, check size is zero
0001B3DE= 0080                     486           dc.w     128       * track offset of 128
0001B3E0                           487           
0001B3E0                           488  * disk parameter block
0001B3E0                           489  * choose a BLS of 4096
0001B3E0                           490  * 1024 sectors (128 byte sector) per track
0001B3E0                           491  * 64 sectors per block
0001B3E0                           492  * 63 tracks per drive 
0001B3E0                           493  dpb3:    
0001B3E0= 0400                     494           dc.w     1024      * 1024 sectors per track
0001B3E2= 05                       495           dc.b     5        * block shift for BLS of 4096
0001B3E3= 1F                       496           dc.b     31       * block mask for BLS of 4096
0001B3E4= 01                       497           dc.b     1        * extent mask, EXM
0001B3E5= 00                       498           dc.b     0        * dummy fill
0001B3E6= 07DF                     499           dc.w     2015     * DSM, leave a head room of 1 track before next drive
0001B3E8                           500                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3E8= 01FF                     501           dc.w     511      * DRM, 512 directory entries
0001B3EA= 0000                     502           dc.w     0        * directory mask
0001B3EC= 0000                     503           dc.w     0        * permanent mounted drive, check size is zero
0001B3EE= 00C0                     504           dc.w     192        * track offset of 192
0001B3F0                           505  
0001B3F0                           506  * RAM drive in memory from $700000 to $E00000
0001B3F0                           507  * disk parameter block
0001B3F0                           508  * choose a BLS of 4096
0001B3F0                           509  * 1024 sectors (128 byte sector) per track
0001B3F0                           510  * 64 sectors per block
0001B3F0                           511  * 63 tracks per drive 
0001B3F0                           512  dpb4:    
0001B3F0= 0400                     513           dc.w     1024      * 1024 sectors per track
0001B3F2= 05                       514           dc.b     5        * block shift for BLS of 4096
0001B3F3= 1F                       515           dc.b     31       * block mask for BLS of 4096
0001B3F4= 01                       516           dc.b     1        * extent mask, EXM
0001B3F5= 00                       517           dc.b     0        * dummy fill
0001B3F6= 07FF                     518           dc.w     2047     * DSM, leave a head room of 1 track before next drive
0001B3F8                           519                             * 63 tracks * 1024 sectors * 128 bytes ~ 8 meg or 2016 blocks
0001B3F8= 01FF                     520           dc.w     511      * DRM, 512 directory entries
0001B3FA= 0000                     521           dc.w     0        * directory mask
0001B3FC= 0000                     522           dc.w     0        * permanent mounted drive, check size is zero
0001B3FE= 0000                     523           dc.w     0        * no track offset
0001B400                           524  
0001B400                           525  **X no sector translation table
0001B400                           526  
0001B400                           527  **X      .bss
0001B400                           528  
0001B400                           529  dirbuf:  ds.b     128      * directory buffer
0001B480                           530  
0001B480                           531  * block/deblock buffer area
0001B480                           532  * data from a CF sector (512 bytes) are stored here
0001B480                           533  sectCF:  ds.b     512      * CF sector data buffer
0001B680                           534  
0001B680                           535  alv0:    ds.b     256      * allocation vector, DSM/8+1 = 249
0001B780                           536  alv1:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001B880                           537  alv2:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001B980                           538  alv3:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001BA80                           539  alv4:    ds.b     256      * DSM/8 +1 = 253, round up to 256
0001BB80                           540  
0001BB80= 0D 0A 43 50 4D 0D 0A     541  TITLE  DC.B 13,10,'CPM',13,10,0
          00                    
0001BB88                           543  
0001BB88                           544           end $15000        * start executing CPM at $15000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA2C              F20009
ACIA2D              F2000B
ACIAC               F00009
ACIAD               F0000B
ACR                 FFF009
ALV0                1B680
ALV1                1B780
ALV2                1B880
ALV3                1B980
ALV4                1BA80
BIOSBASE            1B034
CF07                FFE007
CF1623              FFE00B
CF2427              FFE00D
CF815               FFE009
CFDATA              FFE000
CFERR               FFE002
CFSECTCNT           FFE005
CFSTAT              FFE00F
CLROPR              FFF01F
CONIN               1B0B4
CONOUT              1B0C2
CONSTAT             1B0A0
CPDMA               1B1C4
CRA                 FFF005
CSRA                FFF003
CTL                 FFF00F
CTLR                FFF00F
CTU                 FFF00D
CTUR                FFF00D
CURCFSECT           1B312
DIRBUF              1B400
DMA                 1B31A
DPB0                1B3B0
DPB1                1B3C0
DPB2                1B3D0
DPB3                1B3E0
DPB4                1B3F0
DPH0                1B32E
DPH1                1B348
DPH2                1B362
DPH3                1B37C
DPH4                1B396
DPHLEN              1A
DUART               FFF000
FLUSH               1B2E8
GETIOB              1B2F4
GETSEG              1B2EC
HOME                1B0EE
IMRD                FFF00B
INIT1               1B006
INT_OFF             2700
INT_ON              2000
IPCR                FFF009
ISRD                FFF00B
IVRD                FFF019
LISTST              1B0E8
LSTOUT              1B0E2
MAXDSK              5
MEMRGN              1B324
MOVE2DMA            1B1AE
MR1B                FFF011
MRA                 FFF001
NFUNCS              17
NOSET               1B30E
NOTON               1B0B0
OPCR                FFF01B
PLOG                1B320
PREADCF             1B26C
PSTR                1B0D4
PSTR1               1B0E0
PUN                 1B0E4
RAMDRVR             1B1D8
RAMDRVRD            1B1D4
RAMDRVW             1B2D8
RAMDRVWR            1B2D4
RDR                 1B0E6
RDRF                0
READ                1B134
READCF              1B160
READCF1             1B1A4
READDRQ             1B196
READDRQW            1B25E
READEXIT            1B1E4
RESV                1B311
RESV1               1B31F
RHRA                FFF007
RHRB                FFF017
SECTCF              1B480
SECTOR              1B318
SECTRAN             1B128
SELCODE             1B31E
SELDRV              1B310
SELDSK              1B0F6
SELRTN              1B116
SETDMA              1B12C
SETEXC              1B2F8
SETIOB              1B2F6
SETOPR              FFF01D
SETSEC              1B120
SETTRK              1B118
SETUPRD             1B1E8
SRA                 FFF003
SRB                 FFF013
STARTCTR            FFF01D
STOPCTR             FFF01F
TDRE                1
THRA                FFF007
TITLE               1BB80
TRACK               1B316
TRAPHNDL            1B022
TRAPNG              1B032
WBOOT               1B090
WRCPDMA             1B28C
WREXIT              1B2E4
WRITE               1B206
WRITECF             1B276
WRITECF1            1B2BC
WRITECF2            1B2C6
WRITEDRQ            1B2AE
_CCP                150BC
_INIT               1B000
