00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 22/07/2020 14:23:01

00000000                             1  * 7/29/17, fork from rev 3 of TinyBIOS for Tiny68000
00000000                             2  * This BIOS assumes CPM15000 will be loaded
00000000                             3  * It also assume the disk is reside in flash from location $420000 to $5FFFFF
00000000                             4  * The disk already contains CP/M 68K distribution files
00000000                             5  *****************************************************************
00000000                             6           org $0 
00000000  4EF9 0001B088              7           jmp wboot
0001B000                             8           org $1B000                 * this is the hard location for _init for CPM15000.SR
0001B000  =000150BC                  9  _ccp     equ $150BC                  * hard location for _ccp of CPM15000.SR
0001B000                            10  _init:   
0001B000  46FC 2700                 11           move.w #$2700,sr           * mask off all interrupts
0001B004                            12  **********remove for real hardware
0001B004  103C 000C                 13           move.b #12,d0              * don't echo back keyboard
0001B008  123C 0000                 14           move.b #0,d1               * no echo -- use this for simulation
0001B00C                            15  *         move.b #1,d1              * echo back -- use this for real hardware
0001B00C  4E4F                      16           trap #15
0001B00E                            17  **********remove for real hardware
0001B00E  21FC 0001B01A 008C        18           move.l   #traphndl,$8c     * set up trap #3 handler
0001B016  4280                      19           clr.l    d0                * log on disk A, user 0
0001B018                            20  *        move.b   #$40,CF2427       * set Logical Address addressing mode
0001B018  4E75                      21           rts
0001B01A                            22  
0001B01A                            23  traphndl:
0001B01A  0C40 0017                 24           cmpi     #nfuncs,d0
0001B01E  6400 000A                 25           bcc      trapng
0001B022  E548                      26           lsl      #2,d0             * multiply bios function by 4
0001B024                            27  **X won't assemble         movea.l 6(pc,d0),a0        * get handler address
0001B024                            28  **X replace with this:
0001B024  207B 0006                 29           movea.l  *+8(pc,d0),a0     * get handler address
0001B028  4E90                      30           jsr      (a0)              * call handler
0001B02A                            31  trapng:
0001B02A  4E73                      32           rte
0001B02C                            33  
0001B02C                            34  biosbase:
0001B02C= 0001B000                  35           dc.l  _init
0001B030= 0001B088                  36           dc.l  wboot
0001B034= 0001B08E                  37           dc.l  constat
0001B038= 0001B09A                  38           dc.l  conin
0001B03C= 0001B0B0                  39           dc.l  conout
0001B040= 0001B0B8                  40           dc.l  lstout
0001B044= 0001B0BA                  41           dc.l  pun
0001B048= 0001B0BC                  42           dc.l  rdr
0001B04C= 0001B0C4                  43           dc.l  home
0001B050= 0001B0CC                  44           dc.l  seldsk
0001B054= 0001B0EE                  45           dc.l  settrk
0001B058= 0001B0F6                  46           dc.l  setsec
0001B05C= 0001B102                  47           dc.l  setdma
0001B060= 0001B10A                  48           dc.l  read
0001B064= 0001B14C                  49           dc.l  write
0001B068= 0001B0BE                  50           dc.l  listst
0001B06C= 0001B0FE                  51           dc.l  sectran
0001B070= 0001B102                  52           dc.l  setdma
0001B074= 0001B16C                  53           dc.l  getseg
0001B078= 0001B174                  54           dc.l  getiob
0001B07C= 0001B176                  55           dc.l  setiob
0001B080= 0001B168                  56           dc.l  flush
0001B084= 0001B178                  57           dc.l  setexc
0001B088                            58  
0001B088  =00000017                 59  nfuncs   equ (*-biosbase)/4
0001B088                            60  
0001B088  4EF9 000150BC             61  wboot:   jmp      _ccp
0001B08E                            62  
0001B08E                            63  constat: 
0001B08E                            64  * Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
0001B08E                            65  
0001B08E  103C 0007                 66           move.b #7,d0      * use EASy68k trap 15 task 7
0001B092  4E4F                      67           trap #15          * d1.b = 1 if keyboard ready, otherwise = 0
0001B094  4280                      68           clr.l d0
0001B096  1001                      69           move.b d1,d0
0001B098  4E75                      70           rts
0001B09A                            71           
0001B09A                            72  conin:   
0001B09A                            73  * Read single ASCII character from the keyboard into d0
0001B09A  61F2                      74           bsr constat                * see if key pressed
0001B09C  4A40                      75           tst d0
0001B09E  67FA                      76           beq conin
0001B0A0  103C 0005                 77           move.b #5,d0               * use EASy68k trap 15 task 5
0001B0A4  4E4F                      78           trap #15          * d1.b contains the ascii character
0001B0A6  1001                      79           move.b d1,d0      
0001B0A8  C0BC 0000007F             80           and.l #$7f,d0     * only use 7 bit character set
0001B0AE  4E75                      81           rts
0001B0B0                            82  
0001B0B0                            83  conout: 
0001B0B0                            84  * Display single ASCII character in d1
0001B0B0  103C 0006                 85           move.b #6,d0               * use EASy68k trap 15 task 6
0001B0B4  4E4F                      86           trap #15
0001B0B6  4E75                      87           rts                        * and exit
0001B0B8                            88  
0001B0B8  4E75                      89  lstout:  rts
0001B0BA                            90  
0001B0BA  4E75                      91  pun:     rts
0001B0BC                            92  
0001B0BC  4E75                      93  rdr:     rts
0001B0BE                            94  
0001B0BE  103C 00FF                 95  listst:  move.b   #$ff,d0
0001B0C2  4E75                      96           rts
0001B0C4                            97  
0001B0C4  =00000003                 98  maxdsk   equ 3             * three RAM drives
0001B0C4  =0000001A                 99  dphlen   equ 26            * length of disk parameter header
0001B0C4                           100  
0001B0C4  4239 0001B19E            101  home:    clr.b    track
0001B0CA  4E75                     102           rts
0001B0CC                           103  
0001B0CC                           104  seldsk:  
0001B0CC                           105  *        select disk given by register d1.b
0001B0CC  7000                     106           moveq    #0,d0
0001B0CE  B23C 0003                107           cmp.b    #maxdsk,d1        * valid drive number?
0001B0D2  6A00 0018                108           bpl      selrtn            * if no, return 0 in d0
0001B0D6  13C1 0001B198            109           move.b   d1,seldrv         * else, save drive number
0001B0DC  1039 0001B198            110           move.b   seldrv,d0
0001B0E2  C0FC 001A                111           mulu     #dphlen,d0
0001B0E6  0680 0001B1B2            112           add.l    #dph0,d0          * point d0 at correct dph
0001B0EC  4E75                     113  selrtn:  rts
0001B0EE                           114  
0001B0EE  33C1 0001B19E            115  settrk:  move.w   d1,track
0001B0F4  4E75                     116           rts
0001B0F6                           117  
0001B0F6                           118  setsec:  
0001B0F6  33C1 0001B1A0            119           move.w   d1,sector
0001B0FC  4E75                     120           rts
0001B0FE                           121  
0001B0FE                           122  sectran:
0001B0FE                           123  *        no sector translate, put d1 into d0 and return
0001B0FE  3001                     124           move.w d1,d0
0001B100  4E75                     125           rts
0001B102                           126  
0001B102                           127  setdma:
0001B102  23C1 0001B1A2            128           move.l   d1,dma
0001B108  4E75                     129           rts
0001B10A                           130  
0001B10A                           131  read:
0001B10A                           132  * Read one sector from requested disk, track, sector to dma address
0001B10A                           133  * Both drive A, B & C are RAM drives
0001B10A                           134  * drive A starts from 0x420000 to 0x5BFFFF
0001B10A                           135  * drive B starts from 0xC0000 to 0xFFFFF
0001B10A                           136  
0001B10A                           137  
0001B10A  6100 000C                138           bsr setupRD                * translate track/sector values into RAM loc
0001B10E                           139  RAMdrvR:
0001B10E  22D8                     140           move.l (a0)+,(a1)+
0001B110  51CA FFFC                141           dbra d2,RAMdrvR
0001B114                           142  readexit:
0001B114  4280                     143           clr.l d0                   * return OK status         
0001B116  4E75                     144           rts         
0001B118                           145  setupRD:
0001B118                           146  * translate track/sector into RAM location on the RAM drive
0001B118  2039 0001B19E            147           move.l track,d0            * get track & sector values
0001B11E  ED48                     148           lsl.w #6,d0                * multiply by 64
0001B120  E388                     149           lsl.l #1,d0                * multiply the track/sector by 128 to index into RAM
0001B122  0C39 0002 0001B198       150           cmp.b #2,seldrv            * drive C is RAM drive
0001B12A  6700 000C                151           beq RAMdrv
0001B12E  0680 00420000            152           add.l #$420000,d0          * add base address of RAM drive
0001B134  6000 0008                153           bra getdata
0001B138  0680 000C0000            154  RAMdrv:  add.l #$C0000,d0
0001B13E                           155  getdata:
0001B13E  2040                     156           move.l d0,a0               * point to the track/sector in RAM drive
0001B140  2279 0001B1A2            157           move.l dma,a1             * get dma
0001B146  343C 001F                158           move.w #(128/4)-1,d2        * long word move 128 bytes of sector data
0001B14A  4E75                     159           rts
0001B14C                           160  
0001B14C                           161  write:
0001B14C                           162  * Write one sector to requested disk, track, sector from dma address
0001B14C                           163  * Both drive A & B are RAM drive
0001B14C  0C39 0002 0001B198       164           cmp.b #2,seldrv            * only drive C can be written
0001B154  6600 000E                165           bne wrbad
0001B158  61BE                     166           bsr setupRD                * translate track/sector values into RAM loc
0001B15A                           167  RAMdrvW:
0001B15A  20D9                     168           move.l (a1)+,(a0)+
0001B15C  51CA FFFC                169           dbra d2,RAMdrvW
0001B160                           170  wrexit:
0001B160  4280                     171           clr.l d0
0001B162  4E75                     172           rts         
0001B164                           173  wrbad:
0001B164  70FF                     174           move.l #-1,d0
0001B166  4E75                     175           rts
0001B168                           176  flush:
0001B168  4280                     177           clr.l    d0                * return successful
0001B16A  4E75                     178           rts
0001B16C                           179  
0001B16C                           180  getseg:
0001B16C  203C 0001B1A8            181           move.l   #memrgn,d0        * return address of mem region table
0001B172  4E75                     182           rts
0001B174                           183  
0001B174                           184  getiob:
0001B174  4E75                     185           rts
0001B176                           186  
0001B176                           187  setiob:
0001B176  4E75                     188           rts
0001B178                           189  
0001B178                           190  setexc:
0001B178  0281 000000FF            191           andi.l   #$ff,d1           * do only for exceptions 0 - 255
0001B17E  0C41 002F                192           cmpi     #47,d1
0001B182  6700 0012                193           beq      noset             * this BIOS doesn't set Trap 15
0001B186  0C41 0009                194           cmpi     #9,d1             * or Trace
0001B18A  6700 000A                195           beq      noset
0001B18E  E549                     196           lsl      #2,d1             * multiply exception nmbr by 4
0001B190  2041                     197           movea.l  d1,a0
0001B192  2010                     198           move.l   (a0),d0           * return old vector value
0001B194  2082                     199           move.l   d2,(a0)           * insert new vector
0001B196  4E75                     200  noset:   rts
0001B198                           201  
0001B198                           202  
0001B198                           203  **X      .data
0001B198                           204  
0001B198= FF                       205  seldrv:  dc.b     $ff      * drive requested by seldsk
0001B199= 00                       206  resv:    dc.b    0         * reserve byte, padding
0001B19A= FFFFFFFF                 207  curCFsect: dc.l   -1 * current CF sector, the 512 bytes data of curtrk is in sectCF
0001B19E= 0000                     208  track:   dc.w     0        * track requested by settrk
0001B1A0= 0000                     209  sector:  dc.w     0        * max sector value is 0x3FF
0001B1A2= 00000000                 210  dma:     dc.l     0
0001B1A6= 00                       211  selcode: dc.b     0        * reserve byte
0001B1A7= 00                       212  resv1:   dc.b     0        * reserve byte, padding
0001B1A8                           213  
0001B1A8= 0001                     214  memrgn:  dc.w     1        * 1 memory region
0001B1AA= 00020000                 215           dc.l     $20000   * right after the CP/M 
0001B1AE= 000A0000                 216           dc.l     $A0000  * goes until $C0000, 655K bytes  
0001B1B2                           217  
0001B1B2                           218  * disk parameter headers
0001B1B2                           219  
0001B1B2                           220  dph0:    
0001B1B2= 00000000                 221           dc.l     0        * no sector translation table
0001B1B6= 0000                     222           dc.w     0        * dummy
0001B1B8= 0000                     223           dc.w     0
0001B1BA= 0000                     224           dc.w     0
0001B1BC= 0001B230                 225           dc.l     dirbuf   * ptr to directory buffer
0001B1C0= 0001B200                 226           dc.l     dpb0     * ptr to disk parameter block
0001B1C4= 00000000                 227           dc.l     0        * permanent drive, no check vector
0001B1C8= 0001B2B0                 228           dc.l     alv0     * ptr to allocation vector
0001B1CC                           229  
0001B1CC                           230  dph1:
0001B1CC= 00000000                 231           dc.l     0        * no sector translation table
0001B1D0= 0000                     232           dc.w     0        * dummy
0001B1D2= 0000                     233           dc.w     0
0001B1D4= 0000                     234           dc.w     0
0001B1D6= 0001B230                 235           dc.l     dirbuf   * ptr to directory buffer
0001B1DA= 0001B210                 236           dc.l     dpb1     * ptr to disk parameter block
0001B1DE= 00000000                 237           dc.l     0        * permanent drive, no check vector
0001B1E2= 0001B3B0                 238           dc.l     alv1     * ptr to allocation vector
0001B1E6                           239  dph2:
0001B1E6= 00000000                 240           dc.l     0        * no sector translation table
0001B1EA= 0000                     241           dc.w     0        * dummy
0001B1EC= 0000                     242           dc.w     0
0001B1EE= 0000                     243           dc.w     0
0001B1F0= 0001B230                 244           dc.l     dirbuf   * ptr to directory buffer
0001B1F4= 0001B220                 245           dc.l     dpb2     * ptr to disk parameter block
0001B1F8= 00000000                 246           dc.l     0        * permanent drive, no check vector
0001B1FC= 0001B4B0                 247           dc.l     alv2     * ptr to allocation vector
0001B200                           248  
0001B200                           249  * disk parameter block
0001B200                           250  * flash drive from $420000 to 59FFFF,
0001B200                           251  * choose a BLS of 2048
0001B200                           252  * 1024 sectors (128 byte sector) per track
0001B200                           253  * 16 sectors per block
0001B200                           254  * 12 tracks per drive 
0001B200                           255  dpb0:    
0001B200= 0400                     256           dc.w     1024     * 1024 sectors per track
0001B202= 04                       257           dc.b     4        * block shift for BLS of 2048
0001B203= 0F                       258           dc.b     15       * block mask for BLS of 2048
0001B204= 00                       259           dc.b     0        * extent mask, EXM
0001B205= 00                       260           dc.b     0        * dummy fill
0001B206= 02FF                     261           dc.w     767     * DSM, (12 tracks * 1024 sectors * 128 bytes /2048)-1
0001B208                           262                             
0001B208= 00FF                     263           dc.w     255      * DRM, 256 directory entries
0001B20A= 0000                     264           dc.w     0        * directory mask
0001B20C= 0000                     265           dc.w     0        * permanent mounted drive, check size is zero
0001B20E= 0000                     266           dc.w     0        * no track offset
0001B210                           267  
0001B210                           268  * flash drive from $5A0000 to $5FFFFF
0001B210                           269  * choose a BLS of 2048
0001B210                           270  * 1024 sectors (128 byte sector) per track
0001B210                           271  * 16 sectors per block
0001B210                           272  * 3 tracks per drive 
0001B210                           273  dpb1:    
0001B210= 0400                     274           dc.w     1024     * 1024 sectors per track
0001B212= 04                       275           dc.b     4        * block shift for BLS of 2048
0001B213= 0F                       276           dc.b     15       * block mask for BLS of 2048
0001B214= 00                       277           dc.b     0        * extent mask, EXM
0001B215= 00                       278           dc.b     0        * dummy fill
0001B216= 00BF                     279           dc.w     191     * DSM, (3 tracks * 1024 sectors * 128 bytes /2048)-1
0001B218                           280                             
0001B218= 00FF                     281           dc.w     255      * DRM, 256 directory entries
0001B21A= 0000                     282           dc.w     0        * directory mask
0001B21C= 0000                     283           dc.w     0        * permanent mounted drive, check size is zero
0001B21E= 000C                     284           dc.w     12        * no track offset
0001B220                           285           
0001B220                           286  * use the battery-back RAM in ADC MPU as small RAMdisk, $C0000-$FFFFF
0001B220                           287  * disk parameter block
0001B220                           288  * choose a BLS of 1024
0001B220                           289  * 1024 sectors (128 byte sector) per track
0001B220                           290  * 8 sectors per block
0001B220                           291  * 2 tracks per drive 
0001B220                           292  dpb2:    
0001B220= 0400                     293           dc.w     1024     * 1024 sectors per track
0001B222= 03                       294           dc.b     3        * block shift for BLS of 1024
0001B223= 07                       295           dc.b     7       * block mask for BLS of 1024
0001B224= 00                       296           dc.b     0        * extent mask, EXM
0001B225= 00                       297           dc.b     0        * dummy fill
0001B226= 00FF                     298           dc.w     255     * DSM, (2 tracks * 1024 sectors * 128 bytes /2048)-1
0001B228                           299  * force the block number to be words rather than bytes                           
0001B228= 007F                     300           dc.w     127      * DRM, 128 directory entries
0001B22A= 0000                     301           dc.w     0        * directory mask
0001B22C= 0000                     302           dc.w     0        * permanent mounted drive, check size is zero
0001B22E= 0000                     303           dc.w     0        * no track offset
0001B230                           304  
0001B230                           305  **X no sector translation table
0001B230                           306  
0001B230                           307  **X      .bss
0001B230                           308  
0001B230                           309  dirbuf:  ds.b     128      * directory buffer
0001B2B0                           310  
0001B2B0                           311  alv0:    ds.b     256      * allocation vector, DSM/8+1 = 128
0001B3B0                           312  alv1:    ds.b     256      * DSM/8 +1 = 128, round up to 256
0001B4B0                           313  alv2:    ds.b     256      * DSM/8 +1 = 128, round up to 256
0001B5B0                           314  
0001B5B0                           315  *        end $15000        * start executing CPM at $15000
0001B5B0                           316           end 0

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ALV0                1B2B0
ALV1                1B3B0
ALV2                1B4B0
BIOSBASE            1B02C
CONIN               1B09A
CONOUT              1B0B0
CONSTAT             1B08E
CURCFSECT           1B19A
DIRBUF              1B230
DMA                 1B1A2
DPB0                1B200
DPB1                1B210
DPB2                1B220
DPH0                1B1B2
DPH1                1B1CC
DPH2                1B1E6
DPHLEN              1A
FLUSH               1B168
GETDATA             1B13E
GETIOB              1B174
GETSEG              1B16C
HOME                1B0C4
LISTST              1B0BE
LSTOUT              1B0B8
MAXDSK              3
MEMRGN              1B1A8
NFUNCS              17
NOSET               1B196
PUN                 1B0BA
RAMDRV              1B138
RAMDRVR             1B10E
RAMDRVW             1B15A
RDR                 1B0BC
READ                1B10A
READEXIT            1B114
RESV                1B199
RESV1               1B1A7
SECTOR              1B1A0
SECTRAN             1B0FE
SELCODE             1B1A6
SELDRV              1B198
SELDSK              1B0CC
SELRTN              1B0EC
SETDMA              1B102
SETEXC              1B178
SETIOB              1B176
SETSEC              1B0F6
SETTRK              1B0EE
SETUPRD             1B118
TRACK               1B19E
TRAPHNDL            1B01A
TRAPNG              1B02A
WBOOT               1B088
WRBAD               1B164
WREXIT              1B160
WRITE               1B14C
_CCP                150BC
_INIT               1B000
